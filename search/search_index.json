{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GTFS: Making Public Transit Data Universally Accessible \u00b6 The General Transit Feed Specification (GTFS) is a data specification that allows public transit agencies to publish their transit data in a format that can be consumed by a wide variety of software applications . Today, the GTFS data format is used by thousands of public transport providers. GTFS is split into a schedule component that contains schedule, fare, and geographic transit information and a real-time component that contains arrival predictions, vehicle positions and service advisories. More GTFS background GTFS Schedule GTFS Realtime Resources Extensions","title":"Home"},{"location":"#gtfs-making-public-transit-data-universally-accessible","text":"The General Transit Feed Specification (GTFS) is a data specification that allows public transit agencies to publish their transit data in a format that can be consumed by a wide variety of software applications . Today, the GTFS data format is used by thousands of public transport providers. GTFS is split into a schedule component that contains schedule, fare, and geographic transit information and a real-time component that contains arrival predictions, vehicle positions and service advisories. More GTFS background GTFS Schedule GTFS Realtime Resources Extensions","title":"GTFS: Making Public Transit Data Universally Accessible"},{"location":"about/","text":"About \u00b6 GTFS.org is maintained by MobilityData , a Canadian non-profit that aims to broaden adoption and increase the functionality of the GTFS & GBFS data formats. Thank you to Andrew Byrd for purchasing and lending use of the gtfs.org domain name and providing leadership for the GTFS community. For more information, contact documentation@mobilitydata.org . MobilityData \u00b6 MobilityData began in 2015 as a Rocky Mountain Institute project with the mission to improve travelers' information. It extended its mission and reach by becoming a Canadian non-profit in 2019 and a French one in 2021. The MobilityData team includes a number of transportation thinkers and technical experts. With over 20 employees worldwide, MobilityData brings together and supports international mobility stakeholders such as transport agencies, software vendors, mobility apps, and cities to standardize and expand data formats such as GTFS and GBFS for public transport and shared mobility. MobilityData acts as an industry facilitator, creating opportunities for strengthened interoperability while assisting the industry\u2019s rapid transformation through training and tools. Learn more at mobilitydata.org . Editing this site \u00b6 The GTFS Documentation Platform is based on open source content pulled from various repositories. To propose edits to content, open an issue or pull request in the respective source-of-truth repository found in the README . To propose a feature, content addition, or UI/UX improvement, open an issue in the GTFS.org repository. License \u00b6 Except as otherwise noted, the content of this site is licensed under the Creative Commons Attribution 3.0 License , and code samples are licensed under the Apache 2.0 License .","title":"About"},{"location":"about/#about","text":"GTFS.org is maintained by MobilityData , a Canadian non-profit that aims to broaden adoption and increase the functionality of the GTFS & GBFS data formats. Thank you to Andrew Byrd for purchasing and lending use of the gtfs.org domain name and providing leadership for the GTFS community. For more information, contact documentation@mobilitydata.org .","title":"About"},{"location":"about/#mobilitydata","text":"MobilityData began in 2015 as a Rocky Mountain Institute project with the mission to improve travelers' information. It extended its mission and reach by becoming a Canadian non-profit in 2019 and a French one in 2021. The MobilityData team includes a number of transportation thinkers and technical experts. With over 20 employees worldwide, MobilityData brings together and supports international mobility stakeholders such as transport agencies, software vendors, mobility apps, and cities to standardize and expand data formats such as GTFS and GBFS for public transport and shared mobility. MobilityData acts as an industry facilitator, creating opportunities for strengthened interoperability while assisting the industry\u2019s rapid transformation through training and tools. Learn more at mobilitydata.org .","title":"MobilityData"},{"location":"about/#editing-this-site","text":"The GTFS Documentation Platform is based on open source content pulled from various repositories. To propose edits to content, open an issue or pull request in the respective source-of-truth repository found in the README . To propose a feature, content addition, or UI/UX improvement, open an issue in the GTFS.org repository.","title":"Editing this site"},{"location":"about/#license","text":"Except as otherwise noted, the content of this site is licensed under the Creative Commons Attribution 3.0 License , and code samples are licensed under the Apache 2.0 License .","title":"License"},{"location":"background/","text":"Background \u00b6 TriMet in Portland, Oregon, along with Google, was one of the first public agencies to try and tackle the problem of online transit trip planners through the use of open datasets that are shared with the general public ( How Google and Portland\u2019s TriMet Set the Standard for Open Transit Data in Streetsblog SF ). TriMet worked with Google to format their transit data into an easily maintainable and consumable format that could be imported into Google Maps. This transit data format was originally known as the Google Transit Feed Specification (GTFS). As a result of developer innovation, GTFS data is now being used by a variety of third-party software applications for many different purposes, including trip planning, timetable creation, mobile data, data visualization, accessibility, analysis tools for planning, and real-time information systems. In 2010, the GTFS format name was changed to the General Transit Feed Specification to accurately represent its use in many different applications outside of Google products. Among public transportation data formats, GTFS stands out because it was conceived to meet specific, practical needs in communicating service information to passengers, not as an exhaustive vocabulary for managing operational details. It is designed to be relatively simple to create and read for both people and machines. Even organizations that work with highly detailed data internally using standards like NeTEx find GTFS useful as a way to publish data for wider consumption in consumer applications. For further background on the origins of GTFS, see Pioneering Open Data Standards: The GTFS Story .","title":"Background"},{"location":"background/#background","text":"TriMet in Portland, Oregon, along with Google, was one of the first public agencies to try and tackle the problem of online transit trip planners through the use of open datasets that are shared with the general public ( How Google and Portland\u2019s TriMet Set the Standard for Open Transit Data in Streetsblog SF ). TriMet worked with Google to format their transit data into an easily maintainable and consumable format that could be imported into Google Maps. This transit data format was originally known as the Google Transit Feed Specification (GTFS). As a result of developer innovation, GTFS data is now being used by a variety of third-party software applications for many different purposes, including trip planning, timetable creation, mobile data, data visualization, accessibility, analysis tools for planning, and real-time information systems. In 2010, the GTFS format name was changed to the General Transit Feed Specification to accurately represent its use in many different applications outside of Google products. Among public transportation data formats, GTFS stands out because it was conceived to meet specific, practical needs in communicating service information to passengers, not as an exhaustive vocabulary for managing operational details. It is designed to be relatively simple to create and read for both people and machines. Even organizations that work with highly detailed data internally using standards like NeTEx find GTFS useful as a way to publish data for wider consumption in consumer applications. For further background on the origins of GTFS, see Pioneering Open Data Standards: The GTFS Story .","title":"Background"},{"location":"extensions/","text":"Extensions \u00b6 GTFS is a community driven data format. Users can propose and vote on changes. For detailed information see the GTFS Schedule and GTFS Realtime amendment process. Extensions that are currently in development can be found on MobilityData's roadmap . Extension proposals can be found in the following places: MobilityData maintains a portal with a list of GTFS extension proposals . The roadmap is based on their members' prioritization. You can contribute ideas or extensions via the portal. TransitWiki.org contains a list GTFS extension projects . For more information, contact specifications@mobilitydata.org","title":"Extensions"},{"location":"extensions/#extensions","text":"GTFS is a community driven data format. Users can propose and vote on changes. For detailed information see the GTFS Schedule and GTFS Realtime amendment process. Extensions that are currently in development can be found on MobilityData's roadmap . Extension proposals can be found in the following places: MobilityData maintains a portal with a list of GTFS extension proposals . The roadmap is based on their members' prioritization. You can contribute ideas or extensions via the portal. TransitWiki.org contains a list GTFS extension projects . For more information, contact specifications@mobilitydata.org","title":"Extensions"},{"location":"realtime/","text":"GTFS Realtime Overview \u00b6 Reference Best Practices Examples Changes Getting Started \u00b6 Providing users transit data updates in real time greatly enhances their experience of your transit services. Providing up-to-date information about current arrival and departure times allows users to smoothly plan their trips. As a result, in case of an unfortunate delay, a rider would be relieved to know that they can stay home a little bit longer. GTFS Realtime is a feed specification that allows public transportation agencies to provide realtime updates about their fleet to application developers. It is an extension to GTFS (General Transit Feed Specification), an open data format for public transportation schedules and associated geographic information. GTFS Realtime was designed around ease of implementation, good GTFS interoperability and a focus on passenger information. The specification was designed through a partnership of the initial Live Transit Updates partner agencies, a number of transit developers and Google. The specification is published under the Apache 2.0 License . How do I start? \u00b6 Continue reading the overview below. Decide which feed entities you will be providing. Take a look at example feeds . Create your own feeds using the reference . Publish your feed . Overview of GTFS Realtime feeds \u00b6 The specification currently supports the following types of information: Trip updates - delays, cancellations, changed routes Service alerts - stop moved, unforeseen events affecting a station, route or the entire network Vehicle positions - information about the vehicles including location and congestion level A feed may, although not required to, combine entities of different types. Feeds are served via HTTP and updated frequently. The file itself is a regular binary file, so any type of webserver can host and serve the file (other transfer protocols might be used as well). Alternatively, web application servers could also be used which as a response to a valid HTTP GET request will return the feed. There are no constraints on how frequently nor on the exact method of how the feed should be updated or retrieved. Because GTFS Realtime allows you to present the actual status of your fleet, the feed needs to be updated regularly - preferably whenever new data comes in from your Automatic Vehicle Location system. More about feed entities... Data format \u00b6 The GTFS Realtime data exchange format is based on Protocol Buffers . Protocol buffers are a language- and platform-neutral mechanism for serializing structured data (think XML, but smaller, faster, and simpler). The data structure is defined in a gtfs-realtime.proto file, which then is used to generate source code to easily read and write your structured data from and to a variety of data streams, using a variety of languages \u2013 e.g. Java, C++ or Python. More about Protocol Buffers.... Data structure \u00b6 The hierarchy of elements and their type definitions are specified in the gtfs-realtime.proto file. This text file is used to generate the necessary libraries in your choice of programming language. These libraries provide the classes and functions needed for generating valid GTFS Realtime feeds. The libraries not only make feed creation easier but also ensure that only valid feeds are produced. More about the data structure... Getting Help \u00b6 To participate in discussions around GTFS Realtime and suggest changes and additions to the specification, join the GTFS Realtime mailing list and follow conversations on the google/transit GitHub repository .","title":"Getting Started"},{"location":"realtime/#gtfs-realtime-overview","text":"Reference Best Practices Examples Changes","title":"GTFS Realtime Overview"},{"location":"realtime/#getting-started","text":"Providing users transit data updates in real time greatly enhances their experience of your transit services. Providing up-to-date information about current arrival and departure times allows users to smoothly plan their trips. As a result, in case of an unfortunate delay, a rider would be relieved to know that they can stay home a little bit longer. GTFS Realtime is a feed specification that allows public transportation agencies to provide realtime updates about their fleet to application developers. It is an extension to GTFS (General Transit Feed Specification), an open data format for public transportation schedules and associated geographic information. GTFS Realtime was designed around ease of implementation, good GTFS interoperability and a focus on passenger information. The specification was designed through a partnership of the initial Live Transit Updates partner agencies, a number of transit developers and Google. The specification is published under the Apache 2.0 License .","title":"Getting Started"},{"location":"realtime/#how-do-i-start","text":"Continue reading the overview below. Decide which feed entities you will be providing. Take a look at example feeds . Create your own feeds using the reference . Publish your feed .","title":"How do I start?"},{"location":"realtime/#overview-of-gtfs-realtime-feeds","text":"The specification currently supports the following types of information: Trip updates - delays, cancellations, changed routes Service alerts - stop moved, unforeseen events affecting a station, route or the entire network Vehicle positions - information about the vehicles including location and congestion level A feed may, although not required to, combine entities of different types. Feeds are served via HTTP and updated frequently. The file itself is a regular binary file, so any type of webserver can host and serve the file (other transfer protocols might be used as well). Alternatively, web application servers could also be used which as a response to a valid HTTP GET request will return the feed. There are no constraints on how frequently nor on the exact method of how the feed should be updated or retrieved. Because GTFS Realtime allows you to present the actual status of your fleet, the feed needs to be updated regularly - preferably whenever new data comes in from your Automatic Vehicle Location system. More about feed entities...","title":"Overview of GTFS Realtime feeds"},{"location":"realtime/#data-format","text":"The GTFS Realtime data exchange format is based on Protocol Buffers . Protocol buffers are a language- and platform-neutral mechanism for serializing structured data (think XML, but smaller, faster, and simpler). The data structure is defined in a gtfs-realtime.proto file, which then is used to generate source code to easily read and write your structured data from and to a variety of data streams, using a variety of languages \u2013 e.g. Java, C++ or Python. More about Protocol Buffers....","title":"Data format"},{"location":"realtime/#data-structure","text":"The hierarchy of elements and their type definitions are specified in the gtfs-realtime.proto file. This text file is used to generate the necessary libraries in your choice of programming language. These libraries provide the classes and functions needed for generating valid GTFS Realtime feeds. The libraries not only make feed creation easier but also ensure that only valid feeds are produced. More about the data structure...","title":"Data structure"},{"location":"realtime/#getting-help","text":"To participate in discussions around GTFS Realtime and suggest changes and additions to the specification, join the GTFS Realtime mailing list and follow conversations on the google/transit GitHub repository .","title":"Getting Help"},{"location":"realtime/best-practices/","text":"GTFS Realtime Best Practices \u00b6 Introduction \u00b6 These are recommended practices for describing realtime public transportation information in the GTFS Realtime data format. Document Structure \u00b6 Recommended practices are organized into two primary sections Practice Recommendations Organized by Message : Recommendations are organized by message and field in the same order described in the official GTFS Realtime reference. Practice Recommendations Organized by Case : With particular cases, such as frequency-based service (vs. schedule-based service), practices may need to be applied across several messages and fields as well as the corresponding GTFS schedule data. Such recommendations are consolidated in this section. Feed Publishing & General Practices \u00b6 Feeds should be published at a public, permanent URL The URL should be directly accessible without requiring a login to access the feed. If desired, API keys may be used but registration for API keys should be automated and available to all. Maintain persistent identifiers (id fields) within a GTFS Realtime feed (e.g., FeedEntity.id, VehicleDescriptor.id, CarriageDetails.id) across feed iterations. GTFS Realtime feeds should be refreshed at least once every 30 seconds, or whenever the information represented within the feed (position of a vehicle) changes, whichever is more frequent. VehiclePositions tend to change more frequently than other feed entities and should be updated as frequently as possible. If the content has not changed, the feed should be updated with a new FeedHeader.timestamp reflecting that the information is still relevant as of that timestamp. Data within a GTFS Realtime feed should not be older than 90 seconds for Trip Updates and Vehicle Positions and not older than 10 minutes for Service Alerts. For example, even if a producer is continuously refreshing the FeedHeader.timestamp timestamp every 30 seconds, the age of VehiclePositions within that feed should not be older than 90 seconds. The server hosting GTFS Realtime data should be reliable and consistently return validly-formatted protobuf-encoded responses. Fewer than 1% of responses should be invalid (protobuf errors or fetching errors). The web-server hosting GTFS Realtime data should be configured to correctly report the file modification date (see HTTP/1.1 - Request for Comments 2616, under Section 14.29) so consumers can leverage the If-Modified-Since HTTP header. This saves producers and consumers bandwidth by avoiding transferring feed contents that haven't changed. Feeds should provide protocol buffer-encoded feed content by default when queried via an HTTP request at the given URL - consumers should not need to define special HTTP accept headers to receive protocol-buffer encoded content. Due to how protocol buffers encode optional values , before reading data from a GTFS Realtime feed consumers should check for the presence of values using the protocol buffer-generated hasX() methods before using that value and should only use the value if hasX() is true (where X is the name of the field). If hasX() returns false , the default value for that field defined in the gtfs-realtime.proto value should be assumed. If the consumer uses the value without checking the hasX() method first, it may be reading default data that wasn't intentionally published by the producer. Feeds should use HTTPS instead of HTTP (without encryption) to ensure feed integrity. Feeds should cover the vast majority of trips included in the companion static GTFS dataset. In particular, it should include data for high-density and high-traffic city areas and busy routes. Practice Recommendations Organized by Message \u00b6 FeedHeader \u00b6 Field Name Recommendation gtfs_realtime_version Current version is \"2.0\". All GTFS Realtime feeds should be \"2.0\" or higher, as early version of GTFS Realtime did not require all fields needed to represent various transit situations adequately. incrementality timestamp This timestamp should not decrease between two sequential feed iterations. This timestamp value should always change if the feed contents change - the feed contents should not change without updating the header timestamp . Common mistakes - If there are multiple instances of GTFS Realtime feed behind a load balancer, each instance may be pulling information from the realtime data source and publishing it to consumers slightly out of sync. If a GTFS Realtime consumer makes two back-to-back requests, and each request is served by a different GTFS Realtime feed instance, the same feed contents could potentially be returned to the consumer with different timestamps. Possible solution - Configure the load balancer for \"sticky routes\", so that the consumer always receives the GTFS Realtime feed contents from the same GTFS Realtime instance. FeedEntity \u00b6 All entities should only be removed from a GTFS Realtime feed when they are no longer relevant to users. Feeds are considered to be stateless, meaning that each feed reflects the entire real-time state of the transit system. If an entity is provided in one feed instance but dropped in a subsequent feed update, it should be assumed that there is no real-time information for that entity. Field Name Recommendation id Should be kept stable over the entire trip duration is_deleted trip_update vehicle alert TripUpdate \u00b6 General guidelines for trip cancellations: * When canceling trips over a number of days, producers should provide TripUpdates referencing the given trip_ids and start_dates as CANCELED as well as an Alert with NO_SERVICE referencing the same trip_ids and TimeRange that can be shown to riders explaining the cancellation (e.g., detour). * If no stops in a trip will be visited, the trip should be CANCELED instead of having all stop_time_updates being marked as SKIPPED . Field Name Recommendation trip refer to message TripDescriptor If separate VehiclePosition and TripUpdate feeds are provided, TripDescriptor and VehicleDescriptor ID values pairing should match between the two feeds. For example, a VehiclePosition entity has vehicle_id:A and trip_id:4 , then the corresponding TripUpdate entity should also have vehicle_id:A and trip_id:4 . If any TripUpdate entity has trip_id:4 and any vehicle_id other than 4, this is an error. vehicle refer to message VehicleDescriptor If separate VehiclePosition and TripUpdate feeds are provided, TripDescriptor and VehicleDescriptor ID values pairing should match between the two feeds. For example, a VehiclePosition entity has vehicle_id:A and trip_id:4 , then the corresponding TripUpdate entity should also have vehicle_id:A and trip_id:4 . If any TripUpdate entity has trip_id:4 and any vehicle_id other than 4, this is an error. stop_time_update stop_time_updates for a given trip_id should be strictly ordered by increasing stop_sequence and no stop_sequence should be repeated. All TripUpdates should include at least one stop_time_update with a predicted arrival or departure time in the future. If all stop_time_updates for a trip reference past arrival and departure times, consumers should assume that no real-time data is available for the trip. timestamp Should reflect the time this prediction for this trip was updated delay TripUpdate.delay should represent schedule deviation, i.e., the observed past value for how ahead/behind schedule the vehicle is. Predictions for future stops should be provided through StopTimeEvent.delay or StopTimeEvent.time TripDescriptor \u00b6 If separate VehiclePosition and TripUpdate feeds are provided, TripDescriptor and VehicleDescriptor ID values pairing should match between the two feeds. For example, a VehiclePosition entity has vehicle_id:A and trip_id:4 , then the corresponding TripUpdate entity should also have vehicle_id:A and trip_id:4 . Field Name Recommendation trip_id route_id direction_id start_time start_date schedule_relationship The behavior of ADDED trips are unspecified and the use of this enumeration is not recommended. VehicleDescriptor \u00b6 If separate VehiclePosition and TripUpdate feeds are provided, TripDescriptor and VehicleDescriptor ID values pairing should match between the two feeds. For example, a VehiclePosition entity has vehicle_id:A and trip_id:4 , then the corresponding TripUpdate entity should also have vehicle_id:A and trip_id:4 . Field Name Recommendation id Should uniquely and stably identify a vehicle over the entire trip duration label license_plate StopTimeUpdate \u00b6 Field Name Recommendation stop_sequence Provide stop_sequence whenever possible, as it unambiguously resolves to a GTFS stop time in stop_times.txt unlike stop_id , which can occur more than once in a trip (e.g., loop route). stop_id arrival Arrival times between sequential stops should increase - they should not be the same or decrease. Arrival time (specified in StopTimeEvent ) should be before the departure time for the same stop if a layover or dwell time is expected - otherwise, arrival time should be be the same as departure time . departure Departure times between sequential stops should increase - they should not be the same or decrease. Departure time (specified in StopTimeEvent ) should be the same as the arrival time for the same stop if no layover or dwell time is expected - otherwise, departure time should be after arrival time . schedule_relationship StopTimeEvent \u00b6 Field Name Recommendation delay If only delay is provided in a stop_time_update arrival or departure (and not time ), then the GTFS stop_times.txt should contain arrival_times and/or departure_times for these corresponding stops. A delay value in the realtime feed is meaningless unless you have a clock time to add it to in the GTFS stop_times.txt file. time uncertainty VehiclePosition \u00b6 Following are the recommended fields that should be included for a VehiclePostions feed to provide consumers with high-quality data (e.g., for generating predictions) Field name Notes entity.id Should be kept stable over the entire trip duration vehicle (VehiclePosition) vehicle.timestamp Providing the timestamp at which vehicle position was measured is strongly recommended. Otherwise, consumers must use the message timestamp, which can have misleading results for riders when the last message was updated more frequently than the individual position. vehicle.trip vehicle.trip.trip_id vehicle.trip.start_time vehicle.trip.start_date vehicle.trip.schedule_relationship vehicle.position vehicle.position.latitude vehicle.position.longitude vehicle.vehicle (VehicleDescriptor) vehicle.vehicle.id Should uniquely and stably identify a vehicle over the entire trip duration Position \u00b6 The vehicle position should be within 200 meters of the GTFS shapes.txt data for the current trip unless there is an alert with the effect of DETOUR for this trip_id . Field Name Recommendation latitude longitude bearing odometer speed Alert \u00b6 General guidelines for alerts: * When trip_id and start_time are within exact_time=1 interval, start_time should be later than the beginning of the interval by an exact multiple of headway_secs . * When canceling trips over a number of days, producers should provide TripUpdates referencing the given trip_ids and start_dates as CANCELED as well as an Alert with NO_SERVICE referencing the same trip_ids and TimeRange that can be shown to riders explaining the cancellation (e.g., detour). * If an alert affects all stops on a line, use a line-based alert instead of a stop-based alert. Do not apply the alert to every stop of the line. * While there is no character limit for service alerts, transit riders will often be viewing alerts on mobile devices. Please be concise. Field Name Recommendation active_period informed_entity cause effect url header_text description_text Use line breaks to make your service alert easier to read. tts_header_text tts_description_text severity_level Practice Recommendations Organized by Use Case \u00b6 Frequency-based trips \u00b6 A frequency-based trip does not follow a fixed schedule but attempts to maintain predetermined headways. These trips are denoted in GTFS frequency.txt by setting exact_times=0 or omitting the exact_times field (note that exact_times=1 trips are NOT frequency-based trips - frequencies.txt with exact_times=1 is simply used as a convenience method for storing schedule-based trips in a more compact manner). There are several best practices to keep in mind when constructing GTFS Realtime feeds for frequency-based trips. In TripUpdate.StopTimeUpdate , the StopTimeEvent for arrival and departure should not contain delay because frequency-based trips do not follow a fixed schedule. Instead, time should be provided to indicate arrival/departure predictions. As required by the spec, when describing trip in TripUpdate or VehiclePosition by using TripDescriptor , all of trip_id , start_time , and start_date must be provided. Additionally, schedule_relationship should be UNSCHEDULED . (e.g., re-enforcement trips). About This Document \u00b6 Objectives \u00b6 The objectives of maintaining GTFS Realtime Best Practices are to: Improve end-user customer experience in public transportation apps Make it easier for software developers to deploy and scale applications, products, and services How to propose or amend published GTFS Realtime Best Practices \u00b6 GTFS applications and practices evolve, and so this document may need to be amended from time to time. To propose an amendment to this document, open a pull request in the GTFS Realtime Best Practices GitHub repository and advocate for the change. Linking to This Document \u00b6 Please link here in order to provide feed producers with guidance for correct formation of GTFS Realtime data. Each individual recommendation has an anchor link. Click the recommendation to get the URL for the in-page anchor link. If a GTFS Realtime-consuming application makes requirements or recommendations for GTFS Realtime data practices that are not described here, it is recommended to publish a document with those requirements or recommendations to supplement these common best practices.","title":"Best Practices"},{"location":"realtime/best-practices/#gtfs-realtime-best-practices","text":"","title":"GTFS Realtime Best Practices"},{"location":"realtime/best-practices/#introduction","text":"These are recommended practices for describing realtime public transportation information in the GTFS Realtime data format.","title":"Introduction"},{"location":"realtime/best-practices/#document-structure","text":"Recommended practices are organized into two primary sections Practice Recommendations Organized by Message : Recommendations are organized by message and field in the same order described in the official GTFS Realtime reference. Practice Recommendations Organized by Case : With particular cases, such as frequency-based service (vs. schedule-based service), practices may need to be applied across several messages and fields as well as the corresponding GTFS schedule data. Such recommendations are consolidated in this section.","title":"Document Structure"},{"location":"realtime/best-practices/#feed-publishing-general-practices","text":"Feeds should be published at a public, permanent URL The URL should be directly accessible without requiring a login to access the feed. If desired, API keys may be used but registration for API keys should be automated and available to all. Maintain persistent identifiers (id fields) within a GTFS Realtime feed (e.g., FeedEntity.id, VehicleDescriptor.id, CarriageDetails.id) across feed iterations. GTFS Realtime feeds should be refreshed at least once every 30 seconds, or whenever the information represented within the feed (position of a vehicle) changes, whichever is more frequent. VehiclePositions tend to change more frequently than other feed entities and should be updated as frequently as possible. If the content has not changed, the feed should be updated with a new FeedHeader.timestamp reflecting that the information is still relevant as of that timestamp. Data within a GTFS Realtime feed should not be older than 90 seconds for Trip Updates and Vehicle Positions and not older than 10 minutes for Service Alerts. For example, even if a producer is continuously refreshing the FeedHeader.timestamp timestamp every 30 seconds, the age of VehiclePositions within that feed should not be older than 90 seconds. The server hosting GTFS Realtime data should be reliable and consistently return validly-formatted protobuf-encoded responses. Fewer than 1% of responses should be invalid (protobuf errors or fetching errors). The web-server hosting GTFS Realtime data should be configured to correctly report the file modification date (see HTTP/1.1 - Request for Comments 2616, under Section 14.29) so consumers can leverage the If-Modified-Since HTTP header. This saves producers and consumers bandwidth by avoiding transferring feed contents that haven't changed. Feeds should provide protocol buffer-encoded feed content by default when queried via an HTTP request at the given URL - consumers should not need to define special HTTP accept headers to receive protocol-buffer encoded content. Due to how protocol buffers encode optional values , before reading data from a GTFS Realtime feed consumers should check for the presence of values using the protocol buffer-generated hasX() methods before using that value and should only use the value if hasX() is true (where X is the name of the field). If hasX() returns false , the default value for that field defined in the gtfs-realtime.proto value should be assumed. If the consumer uses the value without checking the hasX() method first, it may be reading default data that wasn't intentionally published by the producer. Feeds should use HTTPS instead of HTTP (without encryption) to ensure feed integrity. Feeds should cover the vast majority of trips included in the companion static GTFS dataset. In particular, it should include data for high-density and high-traffic city areas and busy routes.","title":"Feed Publishing &amp; General Practices"},{"location":"realtime/best-practices/#practice-recommendations-organized-by-message","text":"","title":"Practice Recommendations Organized by Message"},{"location":"realtime/best-practices/#feedheader","text":"Field Name Recommendation gtfs_realtime_version Current version is \"2.0\". All GTFS Realtime feeds should be \"2.0\" or higher, as early version of GTFS Realtime did not require all fields needed to represent various transit situations adequately. incrementality timestamp This timestamp should not decrease between two sequential feed iterations. This timestamp value should always change if the feed contents change - the feed contents should not change without updating the header timestamp . Common mistakes - If there are multiple instances of GTFS Realtime feed behind a load balancer, each instance may be pulling information from the realtime data source and publishing it to consumers slightly out of sync. If a GTFS Realtime consumer makes two back-to-back requests, and each request is served by a different GTFS Realtime feed instance, the same feed contents could potentially be returned to the consumer with different timestamps. Possible solution - Configure the load balancer for \"sticky routes\", so that the consumer always receives the GTFS Realtime feed contents from the same GTFS Realtime instance.","title":"FeedHeader"},{"location":"realtime/best-practices/#feedentity","text":"All entities should only be removed from a GTFS Realtime feed when they are no longer relevant to users. Feeds are considered to be stateless, meaning that each feed reflects the entire real-time state of the transit system. If an entity is provided in one feed instance but dropped in a subsequent feed update, it should be assumed that there is no real-time information for that entity. Field Name Recommendation id Should be kept stable over the entire trip duration is_deleted trip_update vehicle alert","title":"FeedEntity"},{"location":"realtime/best-practices/#tripupdate","text":"General guidelines for trip cancellations: * When canceling trips over a number of days, producers should provide TripUpdates referencing the given trip_ids and start_dates as CANCELED as well as an Alert with NO_SERVICE referencing the same trip_ids and TimeRange that can be shown to riders explaining the cancellation (e.g., detour). * If no stops in a trip will be visited, the trip should be CANCELED instead of having all stop_time_updates being marked as SKIPPED . Field Name Recommendation trip refer to message TripDescriptor If separate VehiclePosition and TripUpdate feeds are provided, TripDescriptor and VehicleDescriptor ID values pairing should match between the two feeds. For example, a VehiclePosition entity has vehicle_id:A and trip_id:4 , then the corresponding TripUpdate entity should also have vehicle_id:A and trip_id:4 . If any TripUpdate entity has trip_id:4 and any vehicle_id other than 4, this is an error. vehicle refer to message VehicleDescriptor If separate VehiclePosition and TripUpdate feeds are provided, TripDescriptor and VehicleDescriptor ID values pairing should match between the two feeds. For example, a VehiclePosition entity has vehicle_id:A and trip_id:4 , then the corresponding TripUpdate entity should also have vehicle_id:A and trip_id:4 . If any TripUpdate entity has trip_id:4 and any vehicle_id other than 4, this is an error. stop_time_update stop_time_updates for a given trip_id should be strictly ordered by increasing stop_sequence and no stop_sequence should be repeated. All TripUpdates should include at least one stop_time_update with a predicted arrival or departure time in the future. If all stop_time_updates for a trip reference past arrival and departure times, consumers should assume that no real-time data is available for the trip. timestamp Should reflect the time this prediction for this trip was updated delay TripUpdate.delay should represent schedule deviation, i.e., the observed past value for how ahead/behind schedule the vehicle is. Predictions for future stops should be provided through StopTimeEvent.delay or StopTimeEvent.time","title":"TripUpdate"},{"location":"realtime/best-practices/#tripdescriptor","text":"If separate VehiclePosition and TripUpdate feeds are provided, TripDescriptor and VehicleDescriptor ID values pairing should match between the two feeds. For example, a VehiclePosition entity has vehicle_id:A and trip_id:4 , then the corresponding TripUpdate entity should also have vehicle_id:A and trip_id:4 . Field Name Recommendation trip_id route_id direction_id start_time start_date schedule_relationship The behavior of ADDED trips are unspecified and the use of this enumeration is not recommended.","title":"TripDescriptor"},{"location":"realtime/best-practices/#vehicledescriptor","text":"If separate VehiclePosition and TripUpdate feeds are provided, TripDescriptor and VehicleDescriptor ID values pairing should match between the two feeds. For example, a VehiclePosition entity has vehicle_id:A and trip_id:4 , then the corresponding TripUpdate entity should also have vehicle_id:A and trip_id:4 . Field Name Recommendation id Should uniquely and stably identify a vehicle over the entire trip duration label license_plate","title":"VehicleDescriptor"},{"location":"realtime/best-practices/#stoptimeupdate","text":"Field Name Recommendation stop_sequence Provide stop_sequence whenever possible, as it unambiguously resolves to a GTFS stop time in stop_times.txt unlike stop_id , which can occur more than once in a trip (e.g., loop route). stop_id arrival Arrival times between sequential stops should increase - they should not be the same or decrease. Arrival time (specified in StopTimeEvent ) should be before the departure time for the same stop if a layover or dwell time is expected - otherwise, arrival time should be be the same as departure time . departure Departure times between sequential stops should increase - they should not be the same or decrease. Departure time (specified in StopTimeEvent ) should be the same as the arrival time for the same stop if no layover or dwell time is expected - otherwise, departure time should be after arrival time . schedule_relationship","title":"StopTimeUpdate"},{"location":"realtime/best-practices/#stoptimeevent","text":"Field Name Recommendation delay If only delay is provided in a stop_time_update arrival or departure (and not time ), then the GTFS stop_times.txt should contain arrival_times and/or departure_times for these corresponding stops. A delay value in the realtime feed is meaningless unless you have a clock time to add it to in the GTFS stop_times.txt file. time uncertainty","title":"StopTimeEvent"},{"location":"realtime/best-practices/#vehicleposition","text":"Following are the recommended fields that should be included for a VehiclePostions feed to provide consumers with high-quality data (e.g., for generating predictions) Field name Notes entity.id Should be kept stable over the entire trip duration vehicle (VehiclePosition) vehicle.timestamp Providing the timestamp at which vehicle position was measured is strongly recommended. Otherwise, consumers must use the message timestamp, which can have misleading results for riders when the last message was updated more frequently than the individual position. vehicle.trip vehicle.trip.trip_id vehicle.trip.start_time vehicle.trip.start_date vehicle.trip.schedule_relationship vehicle.position vehicle.position.latitude vehicle.position.longitude vehicle.vehicle (VehicleDescriptor) vehicle.vehicle.id Should uniquely and stably identify a vehicle over the entire trip duration","title":"VehiclePosition"},{"location":"realtime/best-practices/#position","text":"The vehicle position should be within 200 meters of the GTFS shapes.txt data for the current trip unless there is an alert with the effect of DETOUR for this trip_id . Field Name Recommendation latitude longitude bearing odometer speed","title":"Position"},{"location":"realtime/best-practices/#alert","text":"General guidelines for alerts: * When trip_id and start_time are within exact_time=1 interval, start_time should be later than the beginning of the interval by an exact multiple of headway_secs . * When canceling trips over a number of days, producers should provide TripUpdates referencing the given trip_ids and start_dates as CANCELED as well as an Alert with NO_SERVICE referencing the same trip_ids and TimeRange that can be shown to riders explaining the cancellation (e.g., detour). * If an alert affects all stops on a line, use a line-based alert instead of a stop-based alert. Do not apply the alert to every stop of the line. * While there is no character limit for service alerts, transit riders will often be viewing alerts on mobile devices. Please be concise. Field Name Recommendation active_period informed_entity cause effect url header_text description_text Use line breaks to make your service alert easier to read. tts_header_text tts_description_text severity_level","title":"Alert"},{"location":"realtime/best-practices/#practice-recommendations-organized-by-use-case","text":"","title":"Practice Recommendations Organized by Use Case"},{"location":"realtime/best-practices/#frequency-based-trips","text":"A frequency-based trip does not follow a fixed schedule but attempts to maintain predetermined headways. These trips are denoted in GTFS frequency.txt by setting exact_times=0 or omitting the exact_times field (note that exact_times=1 trips are NOT frequency-based trips - frequencies.txt with exact_times=1 is simply used as a convenience method for storing schedule-based trips in a more compact manner). There are several best practices to keep in mind when constructing GTFS Realtime feeds for frequency-based trips. In TripUpdate.StopTimeUpdate , the StopTimeEvent for arrival and departure should not contain delay because frequency-based trips do not follow a fixed schedule. Instead, time should be provided to indicate arrival/departure predictions. As required by the spec, when describing trip in TripUpdate or VehiclePosition by using TripDescriptor , all of trip_id , start_time , and start_date must be provided. Additionally, schedule_relationship should be UNSCHEDULED . (e.g., re-enforcement trips).","title":"Frequency-based trips"},{"location":"realtime/best-practices/#about-this-document","text":"","title":"About This Document"},{"location":"realtime/best-practices/#objectives","text":"The objectives of maintaining GTFS Realtime Best Practices are to: Improve end-user customer experience in public transportation apps Make it easier for software developers to deploy and scale applications, products, and services","title":"Objectives"},{"location":"realtime/best-practices/#how-to-propose-or-amend-published-gtfs-realtime-best-practices","text":"GTFS applications and practices evolve, and so this document may need to be amended from time to time. To propose an amendment to this document, open a pull request in the GTFS Realtime Best Practices GitHub repository and advocate for the change.","title":"How to propose or amend published GTFS Realtime Best Practices"},{"location":"realtime/best-practices/#linking-to-this-document","text":"Please link here in order to provide feed producers with guidance for correct formation of GTFS Realtime data. Each individual recommendation has an anchor link. Click the recommendation to get the URL for the in-page anchor link. If a GTFS Realtime-consuming application makes requirements or recommendations for GTFS Realtime data practices that are not described here, it is recommended to publish a document with those requirements or recommendations to supplement these common best practices.","title":"Linking to This Document"},{"location":"realtime/code-examples/","text":"Code Examples \u00b6 GTFS-realtime data is encoded and decoded using Protocol Buffers, a compact binary representation designed for fast and efficient processing. How does one generate or parse this binary data? Read on for code samples to help you get started. Language Bindings \u00b6 To work with GTFS realtime data, a developer would typically use the gtfs-realtime.proto schema to generate classes in the programming language of their choice. These classes can then be used for constructing GTFS realtime data model objects and serializing them as binary data or, in the reverse direction, parsing binary data into data model objects. Because generating GTFS realtime data model classes from the gtfs-realtime.proto schema is such a common task, but also one that sometimes causes confusion for first-time developers, we provide pre-generated GTFS realtime language bindings for a number of the most popular programming languages through the open-source gtfs-realtime-bindings project. Read on for language-specific details on parsing GTFS realtime data. Other Languages \u00b6 We have tried to provide language bindings for all programming languages where (a) developers want to use GTFS realtime and (b) there is a mechanism for packaging code for easy re-use. If you feel that your favorite language has been unjustly left off the list, you have two options: Open an issue at the gtfs-realtime-bindings project page requesting that the language be added. Generate your own Protocol Buffer bindings, possibly using a Third-Party Add On. .NET \u00b6 To use the gtfs-realtime-bindings .NET classes in your own project, you need to first install the module from the NuGet repository . Install-Package GtfsRealtimeBindings The following code snippet demonstrates downloading a GTFS realtime data feed from a particular URL, parsing it as a FeedMessage (the root type of the GTFS realtime schema), and iterating over the results. using System.Net; using ProtoBuf; using transit_realtime; WebRequest req = HttpWebRequest.Create(\"URL OF YOUR GTFS-REALTIME SOURCE GOES HERE\"); FeedMessage feed = Serializer.Deserialize<FeedMessage>(req.GetResponse().GetResponseStream()); foreach (FeedEntity entity in feed.entity) { ... } For more details, see the .NET project page . Java \u00b6 To use the gtfs-realtime-bindings Java classes in your own project, you need to add an appropriate dependency. We publish our module to the Maven Central Repository so that it can be easily referenced by Java build tools like Maven, Ivy, and Gradle. In the dependency snippets below, replace version string X.Y.Z with the latest version available in the Maven Central Repository . For Maven , add the following to your pom.xml dependencies section: <dependency> <groupId> com.google.transit </groupId> <artifactId> gtfs-realtime-bindings </artifactId> <version> X.Y.Z </version> </dependency> For Gradle , add the following to your build.gradle dependencies section: compile group : ' org . google . transit ' , name : ' gtfs - realtime - bindings ' , version : ' X . Y . Z ' The following code snippet demonstrates downloading a GTFS realtime data feed from a particular URL, parsing it as a FeedMessage (the root type of the GTFS realtime schema), and iterating over the results. import java.net.URL ; import com.google.transit.realtime.GtfsRealtime.FeedEntity ; import com.google.transit.realtime.GtfsRealtime.FeedMessage ; public class GtfsRealtimeExample { public static void main ( String [] args ) throws Exception { URL url = new URL ( \"URL OF YOUR GTFS-REALTIME SOURCE GOES HERE\" ); FeedMessage feed = FeedMessage . parseFrom ( url . openStream ()); for ( FeedEntity entity : feed . getEntityList ()) { if ( entity . hasTripUpdate ()) { System . out . println ( entity . getTripUpdate ()); } } } } For more details, see the Java project page . JaveScript/Node.js \u00b6 To use the gtfs-realtime-bindings JavaScript Node.js classes in your own project, you need to first install our Node.js npm package : npm install gtfs-realtime-bindings These bindings are designed to be used in the Node.js environment, but with some effort, they can probably be used in other JavaScript environments as well. The following Node.js code snippet demonstrates downloading a GTFS realtime data feed from a particular URL, parsing it as a FeedMessage (the root type of the GTFS realtime schema), and iterating over the results. var GtfsRealtimeBindings = require ( 'gtfs-realtime-bindings' ); var request = require ( 'request' ); var requestSettings = { method : 'GET' , url : 'URL OF YOUR GTFS-REALTIME SOURCE GOES HERE' , encoding : null }; request ( requestSettings , function ( error , response , body ) { if ( ! error && response . statusCode == 200 ) { var feed = GtfsRealtimeBindings . transit_realtime . FeedMessage . decode ( body ); feed . entity . forEach ( function ( entity ) { if ( entity . trip_update ) { console . log ( entity . trip_update ); } }); } }); For more details, see the JavaScript / Node.js project page . PHP \u00b6 To use the gtfs-realtime-bindings PHP classes in your own project, you need to first add a dependency for the google/gtfs-realtime-bindings package in your Composer-based PHP project. In the require section of your composer.json file, add the dependency: \"require\" : { \"google/gtfs-realtime-bindings\" : \"x.y.z\" } Where x.y.z is the latest release version of the package . The following code snippet demonstrates downloading a GTFS realtime data feed from a particular URL, parsing it as a FeedMessage (the root type of the GTFS realtime schema), and iterating over the results. require_once 'vendor/autoload.php'; use transit_realtime\\FeedMessage; $data = file_get_contents(\"URL OF YOUR GTFS-REALTIME SOURCE GOES HERE\"); $feed = new FeedMessage(); $feed->parse($data); foreach ($feed->getEntityList() as $entity) { if ($entity->hasTripUpdate()) { error_log(\"trip: \" . $entity->getId()); } } For more details, see the PHP project page . Python \u00b6 To use the gtfs-realtime-bindings Python classes in your own project, you need to first install the module from the PyPI repository . # Using easy_install easy_install -- upgrade gtfs - realtime - bindings # Using pip pip install -- upgrade gtfs - realtime - bindings The following code snippet demonstrates downloading a GTFS-realtime data feed from a particular URL, parsing it as a FeedMessage (the root type of the GTFS-realtime schema), and iterating over the results. from google.transit import gtfs_realtime_pb2 import urllib feed = gtfs_realtime_pb2 . FeedMessage () response = urllib . urlopen ( 'URL OF YOUR GTFS-REALTIME SOURCE GOES HERE' ) feed . ParseFromString ( response . read ()) for entity in feed . entity : if entity . HasField ( 'trip_update' ): print entity . trip_update For more details, see the Python project page . Ruby \u00b6 To use the gtfs-realtime-bindings classes in your own project, you need to first install Ruby gem : gem install gtfs-realtime-bindings The following code snippet demonstrates downloading a GTFS realtime data feed from a particular URL, parsing it as a FeedMessage (the root type of the GTFS realtime schema), and iterating over the results. require 'protobuf' require 'google/transit/gtfs-realtime.pb' require 'net/http' require 'uri' data = Net :: HTTP . get ( URI . parse ( \"URL OF YOUR GTFS-REALTIME SOURCE GOES HERE\" )) feed = Transit_realtime :: FeedMessage . decode ( data ) for entity in feed . entity do if entity . field? ( :trip_update ) p entity . trip_update end end For more details, see the Ruby project page .","title":"Code Examples"},{"location":"realtime/code-examples/#code-examples","text":"GTFS-realtime data is encoded and decoded using Protocol Buffers, a compact binary representation designed for fast and efficient processing. How does one generate or parse this binary data? Read on for code samples to help you get started.","title":"Code Examples"},{"location":"realtime/code-examples/#language-bindings","text":"To work with GTFS realtime data, a developer would typically use the gtfs-realtime.proto schema to generate classes in the programming language of their choice. These classes can then be used for constructing GTFS realtime data model objects and serializing them as binary data or, in the reverse direction, parsing binary data into data model objects. Because generating GTFS realtime data model classes from the gtfs-realtime.proto schema is such a common task, but also one that sometimes causes confusion for first-time developers, we provide pre-generated GTFS realtime language bindings for a number of the most popular programming languages through the open-source gtfs-realtime-bindings project. Read on for language-specific details on parsing GTFS realtime data.","title":"Language Bindings"},{"location":"realtime/code-examples/#other-languages","text":"We have tried to provide language bindings for all programming languages where (a) developers want to use GTFS realtime and (b) there is a mechanism for packaging code for easy re-use. If you feel that your favorite language has been unjustly left off the list, you have two options: Open an issue at the gtfs-realtime-bindings project page requesting that the language be added. Generate your own Protocol Buffer bindings, possibly using a Third-Party Add On.","title":"Other Languages"},{"location":"realtime/code-examples/#net","text":"To use the gtfs-realtime-bindings .NET classes in your own project, you need to first install the module from the NuGet repository . Install-Package GtfsRealtimeBindings The following code snippet demonstrates downloading a GTFS realtime data feed from a particular URL, parsing it as a FeedMessage (the root type of the GTFS realtime schema), and iterating over the results. using System.Net; using ProtoBuf; using transit_realtime; WebRequest req = HttpWebRequest.Create(\"URL OF YOUR GTFS-REALTIME SOURCE GOES HERE\"); FeedMessage feed = Serializer.Deserialize<FeedMessage>(req.GetResponse().GetResponseStream()); foreach (FeedEntity entity in feed.entity) { ... } For more details, see the .NET project page .","title":".NET"},{"location":"realtime/code-examples/#java","text":"To use the gtfs-realtime-bindings Java classes in your own project, you need to add an appropriate dependency. We publish our module to the Maven Central Repository so that it can be easily referenced by Java build tools like Maven, Ivy, and Gradle. In the dependency snippets below, replace version string X.Y.Z with the latest version available in the Maven Central Repository . For Maven , add the following to your pom.xml dependencies section: <dependency> <groupId> com.google.transit </groupId> <artifactId> gtfs-realtime-bindings </artifactId> <version> X.Y.Z </version> </dependency> For Gradle , add the following to your build.gradle dependencies section: compile group : ' org . google . transit ' , name : ' gtfs - realtime - bindings ' , version : ' X . Y . Z ' The following code snippet demonstrates downloading a GTFS realtime data feed from a particular URL, parsing it as a FeedMessage (the root type of the GTFS realtime schema), and iterating over the results. import java.net.URL ; import com.google.transit.realtime.GtfsRealtime.FeedEntity ; import com.google.transit.realtime.GtfsRealtime.FeedMessage ; public class GtfsRealtimeExample { public static void main ( String [] args ) throws Exception { URL url = new URL ( \"URL OF YOUR GTFS-REALTIME SOURCE GOES HERE\" ); FeedMessage feed = FeedMessage . parseFrom ( url . openStream ()); for ( FeedEntity entity : feed . getEntityList ()) { if ( entity . hasTripUpdate ()) { System . out . println ( entity . getTripUpdate ()); } } } } For more details, see the Java project page .","title":"Java"},{"location":"realtime/code-examples/#javescriptnodejs","text":"To use the gtfs-realtime-bindings JavaScript Node.js classes in your own project, you need to first install our Node.js npm package : npm install gtfs-realtime-bindings These bindings are designed to be used in the Node.js environment, but with some effort, they can probably be used in other JavaScript environments as well. The following Node.js code snippet demonstrates downloading a GTFS realtime data feed from a particular URL, parsing it as a FeedMessage (the root type of the GTFS realtime schema), and iterating over the results. var GtfsRealtimeBindings = require ( 'gtfs-realtime-bindings' ); var request = require ( 'request' ); var requestSettings = { method : 'GET' , url : 'URL OF YOUR GTFS-REALTIME SOURCE GOES HERE' , encoding : null }; request ( requestSettings , function ( error , response , body ) { if ( ! error && response . statusCode == 200 ) { var feed = GtfsRealtimeBindings . transit_realtime . FeedMessage . decode ( body ); feed . entity . forEach ( function ( entity ) { if ( entity . trip_update ) { console . log ( entity . trip_update ); } }); } }); For more details, see the JavaScript / Node.js project page .","title":"JaveScript/Node.js"},{"location":"realtime/code-examples/#php","text":"To use the gtfs-realtime-bindings PHP classes in your own project, you need to first add a dependency for the google/gtfs-realtime-bindings package in your Composer-based PHP project. In the require section of your composer.json file, add the dependency: \"require\" : { \"google/gtfs-realtime-bindings\" : \"x.y.z\" } Where x.y.z is the latest release version of the package . The following code snippet demonstrates downloading a GTFS realtime data feed from a particular URL, parsing it as a FeedMessage (the root type of the GTFS realtime schema), and iterating over the results. require_once 'vendor/autoload.php'; use transit_realtime\\FeedMessage; $data = file_get_contents(\"URL OF YOUR GTFS-REALTIME SOURCE GOES HERE\"); $feed = new FeedMessage(); $feed->parse($data); foreach ($feed->getEntityList() as $entity) { if ($entity->hasTripUpdate()) { error_log(\"trip: \" . $entity->getId()); } } For more details, see the PHP project page .","title":"PHP"},{"location":"realtime/code-examples/#python","text":"To use the gtfs-realtime-bindings Python classes in your own project, you need to first install the module from the PyPI repository . # Using easy_install easy_install -- upgrade gtfs - realtime - bindings # Using pip pip install -- upgrade gtfs - realtime - bindings The following code snippet demonstrates downloading a GTFS-realtime data feed from a particular URL, parsing it as a FeedMessage (the root type of the GTFS-realtime schema), and iterating over the results. from google.transit import gtfs_realtime_pb2 import urllib feed = gtfs_realtime_pb2 . FeedMessage () response = urllib . urlopen ( 'URL OF YOUR GTFS-REALTIME SOURCE GOES HERE' ) feed . ParseFromString ( response . read ()) for entity in feed . entity : if entity . HasField ( 'trip_update' ): print entity . trip_update For more details, see the Python project page .","title":"Python"},{"location":"realtime/code-examples/#ruby","text":"To use the gtfs-realtime-bindings classes in your own project, you need to first install Ruby gem : gem install gtfs-realtime-bindings The following code snippet demonstrates downloading a GTFS realtime data feed from a particular URL, parsing it as a FeedMessage (the root type of the GTFS realtime schema), and iterating over the results. require 'protobuf' require 'google/transit/gtfs-realtime.pb' require 'net/http' require 'uri' data = Net :: HTTP . get ( URI . parse ( \"URL OF YOUR GTFS-REALTIME SOURCE GOES HERE\" )) feed = Transit_realtime :: FeedMessage . decode ( data ) for entity in feed . entity do if entity . field? ( :trip_update ) p entity . trip_update end end For more details, see the Ruby project page .","title":"Ruby"},{"location":"realtime/extensions/","text":"Extensions \u00b6 To allow producers to add custom information to a GTFS Realtime feed, we will take advantage of the Extensions feature of Protocol Buffers . Extensions allow us to define a namespace in a Protocol Buffer message where third-party developers can define additional fields without the need to modify the original proto definition. When possible we should avoid extensions and add fields useful to many agencies to the main specification to avoid fragmentation and extra work for consumers to support various extensions to the spec. Before requesting an extension id, producers should propose adding the field to the specification (see Adding new fields to GTFS Realtime ) The extension IDs within the range 9000-9999 are reserved for private use by GTFS-rt producers. These IDs should only be used to convey information internally to your organization. Extensions in this range must not be used in public feeds. To create a new extension, we will assign a producer the next available extension id, picked incrementally from a list of numbers starting at 1000 and going up and documented in the Extension Registry section found below. These assigned extension ids corresponds to the tag ids available in the \"extension\" namespace for each GTFS Realtime message definition. Now that the developer has an assigned extension id, they will use that id when extending any and all GTFS Realtime messages. Even if the developer only plans to extend a single message, the assigned extension id will be reserved for ALL messages. For a developer extending the spec, instead of adding a single field like a \"string\" or \"int32\" with their extension id, the preferred model is to define a new message like \"MyTripDescriptorExtension\", extend the underlying GTFS Realtime message with your new message, and then put all your new fields in there. This has the nice property that you can manage fields within your extension message however you want, without needing to reserve a new extension id from the master list. message MyTripDescriptorExtension { optional string some_string = 1 ; optional bool some_bool = 2 ; ... } extend transit_realtime . TripDescriptor { optional MyTripDescriptorExtension my_trip_descriptor = YOUR_EXTENSION_ID ; } When creating extensions, developers should follow the Protocol Buffers Language Guide . A common mistake is re-using an extension field number. In the Assigning Field Numbers section , the Language Guide says: Each field in the message definition has a unique number. These numbers are used to identify your fields in the message binary format, and should not be changed once your message type is in use. For example, in the first example some_string was assigned field number 1 . When the developer no longer wishes to use some_string , or when some_string has been adopted in the official GTFS Realtime spec and there is no need for the extension, the developer cannot re-use field number 1 for a new field. Instead, the developer should deprecate the field and use a new number for the new field: message MyTripDescriptorExtension { optional string some_string = 1 [ deprecated = true ]; optional bool some_bool = 2 ; optional string some_new_string = 3 ; ... } Extension Registry \u00b6 Extension ID Developer Contact Details 1000 OneBusAway onebusaway-developers https://github.com/OneBusAway/onebusaway/wiki/GTFS-Realtime-Resources 1001 New York City MTA mtadeveloperresources https://mta.info/developers/ 1002 Google transit-realtime-partner-support@google.com Google Maps Live Transit Updates 1003 OVapi gtfs-rt at ovapi.nl https://gtfs.ovapi.nl 1004 Metra William Ashbaugh w.l.ashbaugh@gmail.com 1005 Metro-North Railroad John Larsen 1006 realCity David Varga https://realcity.io 1007 Transport for NSW timetable@transport.nsw.gov.au Group discussion 1008 SEPTA - Southeastern Pennsylvania Transportation Authority Gregory Apessos https://github.com/septadev 1009 Swiftly mike@goswift.ly Group Discussion 1010 IBI Group Ritesh Warade GitHub proposal for new timestamps in Service Alerts 9000-9999 RESERVED - INTERNAL USE ONLY GTFS Community Group discussion","title":"Realtime Extensions"},{"location":"realtime/extensions/#extensions","text":"To allow producers to add custom information to a GTFS Realtime feed, we will take advantage of the Extensions feature of Protocol Buffers . Extensions allow us to define a namespace in a Protocol Buffer message where third-party developers can define additional fields without the need to modify the original proto definition. When possible we should avoid extensions and add fields useful to many agencies to the main specification to avoid fragmentation and extra work for consumers to support various extensions to the spec. Before requesting an extension id, producers should propose adding the field to the specification (see Adding new fields to GTFS Realtime ) The extension IDs within the range 9000-9999 are reserved for private use by GTFS-rt producers. These IDs should only be used to convey information internally to your organization. Extensions in this range must not be used in public feeds. To create a new extension, we will assign a producer the next available extension id, picked incrementally from a list of numbers starting at 1000 and going up and documented in the Extension Registry section found below. These assigned extension ids corresponds to the tag ids available in the \"extension\" namespace for each GTFS Realtime message definition. Now that the developer has an assigned extension id, they will use that id when extending any and all GTFS Realtime messages. Even if the developer only plans to extend a single message, the assigned extension id will be reserved for ALL messages. For a developer extending the spec, instead of adding a single field like a \"string\" or \"int32\" with their extension id, the preferred model is to define a new message like \"MyTripDescriptorExtension\", extend the underlying GTFS Realtime message with your new message, and then put all your new fields in there. This has the nice property that you can manage fields within your extension message however you want, without needing to reserve a new extension id from the master list. message MyTripDescriptorExtension { optional string some_string = 1 ; optional bool some_bool = 2 ; ... } extend transit_realtime . TripDescriptor { optional MyTripDescriptorExtension my_trip_descriptor = YOUR_EXTENSION_ID ; } When creating extensions, developers should follow the Protocol Buffers Language Guide . A common mistake is re-using an extension field number. In the Assigning Field Numbers section , the Language Guide says: Each field in the message definition has a unique number. These numbers are used to identify your fields in the message binary format, and should not be changed once your message type is in use. For example, in the first example some_string was assigned field number 1 . When the developer no longer wishes to use some_string , or when some_string has been adopted in the official GTFS Realtime spec and there is no need for the extension, the developer cannot re-use field number 1 for a new field. Instead, the developer should deprecate the field and use a new number for the new field: message MyTripDescriptorExtension { optional string some_string = 1 [ deprecated = true ]; optional bool some_bool = 2 ; optional string some_new_string = 3 ; ... }","title":"Extensions"},{"location":"realtime/extensions/#extension-registry","text":"Extension ID Developer Contact Details 1000 OneBusAway onebusaway-developers https://github.com/OneBusAway/onebusaway/wiki/GTFS-Realtime-Resources 1001 New York City MTA mtadeveloperresources https://mta.info/developers/ 1002 Google transit-realtime-partner-support@google.com Google Maps Live Transit Updates 1003 OVapi gtfs-rt at ovapi.nl https://gtfs.ovapi.nl 1004 Metra William Ashbaugh w.l.ashbaugh@gmail.com 1005 Metro-North Railroad John Larsen 1006 realCity David Varga https://realcity.io 1007 Transport for NSW timetable@transport.nsw.gov.au Group discussion 1008 SEPTA - Southeastern Pennsylvania Transportation Authority Gregory Apessos https://github.com/septadev 1009 Swiftly mike@goswift.ly Group Discussion 1010 IBI Group Ritesh Warade GitHub proposal for new timestamps in Service Alerts 9000-9999 RESERVED - INTERNAL USE ONLY GTFS Community Group discussion","title":"Extension Registry"},{"location":"realtime/feed-examples/","text":"Feed Examples \u00b6 The following examples show a textual representation of feeds. During development it is more convenient to produce ASCII protocol buffer output for easier debugging. You can compare your text output with these examples to check for the validity of data. Service alert \u00b6 The following example is an ASCII representation of an Alert feed. # header information header { # version of speed specification. Currently \"2.0\". Valid versions are \"2.0\", \"1.0\". gtfs_realtime_version : \"2.0\" # determines whether dataset is incremental or full incrementality : FULL_DATASET # the time where this dataset was generated on server # for determining the sequence of alert feeds timestamp : 1284457468 } # multiple entities can be included in the feed entity { # unique identifier for the entity id : \"0\" # \"type\" of the entity alert { # multiple periods can be defined when alert is active active_period { # start time in POSIX epoch format start : 1284457468 # end time in POSIX epoch format end : 1284468072 } # selects which GTFS entities will be affected informed_entity { # valid parameters: # agency_id, route_id, route_type, stop_id, trip (see TripDescriptor) route_id : \"219\" } # multiple selectors (informed_entity) can be included in one alert entity informed_entity { stop_id : \"16230\" } # multiple fields can be included in one informed_entity informed_entity { stop_id : \"16299\" route_id : \"100\" # This example means route 100 at stop 16299. # This does not apply to any other stop on route 100 and any other route at stop 16299. } # cause of the alert - see gtfs-realtime.proto for valid values cause : CONSTRUCTION # effect of the alert - see gtfs-realtime.proto for valid values effect : DETOUR # the given url provides additional information url { # multiple languages/translations supported translation { # page hosted outside of Google (at provider/agency, etc.) text : \"https://www.sometransitagency/alerts\" language : \"en\" } } # header for the alert will be highlighted header_text { # multiple languages/translations supported translation { text : \"Stop at Elm street is closed, temporary stop at Oak street\" language : \"en\" } } # Alert description. Additional info to the header text description_text { # multiple languages/translations supported translation { text : \"Due to construction at Elm street the stop is closed. The temporary stop can be found 300 meters north at Oak street\" language : \"en\" } } } } Trip Update \u00b6 The following example is an ASCII representation of an full-dataset Trip Update feed. # header information header { # version of speed specification. Currently \"2.0\". Valid versions are \"2.0\", \"1.0\". gtfs_realtime_version : \"2.0\" # determines whether dataset is incremental or full incrementality : FULL_DATASET # the moment where this dataset was generated on server timestamp : 1284457468 } # multiple entities can be included in the feed entity { # unique identifier for the entity id : \"simple-trip\" # \"type\" of the entity trip_update { trip { # selects which GTFS entity (trip) will be affected trip_id : \"trip-1\" } # schedule information update stop_time_update { # selecting which stop is affected stop_sequence : 3 # for the vehicle's arrival time arrival { # to be delayed with 5 seconds delay : 5 } } # ...this vehicle's delay is propagated to its subsequent stops. # Next information update on the vehicle's schedule stop_time_update { # selected by stop_sequence. It will update stop_sequence : 8 # the vehicle's original (scheduled) arrival time with a arrival { # 1 second delay. delay : 1 } } # ...likewise the delay is propagated to subsequent stops. # Next information update on the vehicle's schedule stop_time_update { # selected by stop_sequence. It will update the vehicle's arrival time stop_sequence : 10 # with the default delay of 0 (on time) and propagate this update # for the rest of the vehicle's stops. } } } # second entity containing update information for another trip entity { id : \"3\" trip_update { trip { # frequency based trips are defined by their # trip_id in GTFS and trip_id : \"frequency-expanded-trip\" # start_time start_time : \"11:15:35\" } stop_time_update { stop_sequence : 1 arrival { # negative delay means vehicle is 2 seconds ahead of schedule delay : - 2 } } stop_time_update { stop_sequence : 9 } } }","title":"Feed Examples"},{"location":"realtime/feed-examples/#feed-examples","text":"The following examples show a textual representation of feeds. During development it is more convenient to produce ASCII protocol buffer output for easier debugging. You can compare your text output with these examples to check for the validity of data.","title":"Feed Examples"},{"location":"realtime/feed-examples/#service-alert","text":"The following example is an ASCII representation of an Alert feed. # header information header { # version of speed specification. Currently \"2.0\". Valid versions are \"2.0\", \"1.0\". gtfs_realtime_version : \"2.0\" # determines whether dataset is incremental or full incrementality : FULL_DATASET # the time where this dataset was generated on server # for determining the sequence of alert feeds timestamp : 1284457468 } # multiple entities can be included in the feed entity { # unique identifier for the entity id : \"0\" # \"type\" of the entity alert { # multiple periods can be defined when alert is active active_period { # start time in POSIX epoch format start : 1284457468 # end time in POSIX epoch format end : 1284468072 } # selects which GTFS entities will be affected informed_entity { # valid parameters: # agency_id, route_id, route_type, stop_id, trip (see TripDescriptor) route_id : \"219\" } # multiple selectors (informed_entity) can be included in one alert entity informed_entity { stop_id : \"16230\" } # multiple fields can be included in one informed_entity informed_entity { stop_id : \"16299\" route_id : \"100\" # This example means route 100 at stop 16299. # This does not apply to any other stop on route 100 and any other route at stop 16299. } # cause of the alert - see gtfs-realtime.proto for valid values cause : CONSTRUCTION # effect of the alert - see gtfs-realtime.proto for valid values effect : DETOUR # the given url provides additional information url { # multiple languages/translations supported translation { # page hosted outside of Google (at provider/agency, etc.) text : \"https://www.sometransitagency/alerts\" language : \"en\" } } # header for the alert will be highlighted header_text { # multiple languages/translations supported translation { text : \"Stop at Elm street is closed, temporary stop at Oak street\" language : \"en\" } } # Alert description. Additional info to the header text description_text { # multiple languages/translations supported translation { text : \"Due to construction at Elm street the stop is closed. The temporary stop can be found 300 meters north at Oak street\" language : \"en\" } } } }","title":"Service alert"},{"location":"realtime/feed-examples/#trip-update","text":"The following example is an ASCII representation of an full-dataset Trip Update feed. # header information header { # version of speed specification. Currently \"2.0\". Valid versions are \"2.0\", \"1.0\". gtfs_realtime_version : \"2.0\" # determines whether dataset is incremental or full incrementality : FULL_DATASET # the moment where this dataset was generated on server timestamp : 1284457468 } # multiple entities can be included in the feed entity { # unique identifier for the entity id : \"simple-trip\" # \"type\" of the entity trip_update { trip { # selects which GTFS entity (trip) will be affected trip_id : \"trip-1\" } # schedule information update stop_time_update { # selecting which stop is affected stop_sequence : 3 # for the vehicle's arrival time arrival { # to be delayed with 5 seconds delay : 5 } } # ...this vehicle's delay is propagated to its subsequent stops. # Next information update on the vehicle's schedule stop_time_update { # selected by stop_sequence. It will update stop_sequence : 8 # the vehicle's original (scheduled) arrival time with a arrival { # 1 second delay. delay : 1 } } # ...likewise the delay is propagated to subsequent stops. # Next information update on the vehicle's schedule stop_time_update { # selected by stop_sequence. It will update the vehicle's arrival time stop_sequence : 10 # with the default delay of 0 (on time) and propagate this update # for the rest of the vehicle's stops. } } } # second entity containing update information for another trip entity { id : \"3\" trip_update { trip { # frequency based trips are defined by their # trip_id in GTFS and trip_id : \"frequency-expanded-trip\" # start_time start_time : \"11:15:35\" } stop_time_update { stop_sequence : 1 arrival { # negative delay means vehicle is 2 seconds ahead of schedule delay : - 2 } } stop_time_update { stop_sequence : 9 } } }","title":"Trip Update"},{"location":"realtime/guiding-principles/","text":"Guiding Principles \u00b6 In order to preserve the original vision of GTFS Realtime, a number of guiding principles have been established to take into consideration when extending the spec: Feeds should be efficient to produce and consume in realtime. Realtime information is a continuous, dynamic stream of data that necessarily requires efficient processing. We chose Protocol Buffers as the basis for the specification because they offer a good trade-off in terms of ease of use for developers and in terms of efficiency for transmitting data. Unlike GTFS, we do not imagine many agencies will be editing GTFS Realtime feeds by hand. The choice of Protocol Buffers reflects the conclusion that most GTFS Realtime feeds will be produced and consumed programmatically. The spec is about passenger information. Like GTFS before it, GTFS Realtime is primarily concerned with passenger information. That is, the spec should include information that can help power tools for riders, first and foremost. There is potentially a large amount of operations-oriented information that transit agencies might want to transmit internally between systems. GTFS Realtime is not intended for that purpose and there are potentially other operations-oriented data-standards that may be more appropriate. Changes to the spec should be backwards-compatible. When adding features to the specification, we want to avoid making changes that will make existing feeds invalid. We don't want to create more work for existing feed publishers until they want to add capabilities to their feeds. Also, whenever possible, we want existing parsers to be able to continue to read the older parts of newer feeds. The conventions for extending Protocol Buffers will enforce backwards-compatibility to a certain extent. However, we wish to avoid semantic changes to existing fields that might break backwards-compatibility as well. Speculative features are discouraged. Every new feature adds complexity to creating and reading of feeds. Therefore, we want to take care to only add features that we know to be useful. Ideally, any proposal will have been tested by generating data for a real transit system that uses the new feature and writing software to read and display it.","title":"Guiding Principles"},{"location":"realtime/guiding-principles/#guiding-principles","text":"In order to preserve the original vision of GTFS Realtime, a number of guiding principles have been established to take into consideration when extending the spec: Feeds should be efficient to produce and consume in realtime. Realtime information is a continuous, dynamic stream of data that necessarily requires efficient processing. We chose Protocol Buffers as the basis for the specification because they offer a good trade-off in terms of ease of use for developers and in terms of efficiency for transmitting data. Unlike GTFS, we do not imagine many agencies will be editing GTFS Realtime feeds by hand. The choice of Protocol Buffers reflects the conclusion that most GTFS Realtime feeds will be produced and consumed programmatically. The spec is about passenger information. Like GTFS before it, GTFS Realtime is primarily concerned with passenger information. That is, the spec should include information that can help power tools for riders, first and foremost. There is potentially a large amount of operations-oriented information that transit agencies might want to transmit internally between systems. GTFS Realtime is not intended for that purpose and there are potentially other operations-oriented data-standards that may be more appropriate. Changes to the spec should be backwards-compatible. When adding features to the specification, we want to avoid making changes that will make existing feeds invalid. We don't want to create more work for existing feed publishers until they want to add capabilities to their feeds. Also, whenever possible, we want existing parsers to be able to continue to read the older parts of newer feeds. The conventions for extending Protocol Buffers will enforce backwards-compatibility to a certain extent. However, we wish to avoid semantic changes to existing fields that might break backwards-compatibility as well. Speculative features are discouraged. Every new feature adds complexity to creating and reading of feeds. Therefore, we want to take care to only add features that we know to be useful. Ideally, any proposal will have been tested by generating data for a real transit system that uses the new feature and writing software to read and display it.","title":"Guiding Principles"},{"location":"realtime/process/","text":"Adding new fields to GTFS Realtime \u00b6 When a producer or consumer is interested in adding a new field to the GTFS Realtime specification, they should open a new issue on the GTFS Realtime GitHub repository describing the proposed field and announce this new field (including a link to the issue) on the GTFS Realtime mailing list . Specification amendment process \u00b6 Create a git branch with update of all relevant parts of protocol definition, specification and documentation files (except for translations). Create pull request on https://github.com/google/transit. Pull request must contain an extended description of the patch. The creator of the pull request becomes the advocate . Once pull request is registered, it must be announced by its advocate in the GTFS Realtime mailing list . Once announced, the pull request is considered a proposal. Since the advocate is a contributor, they must sign the Contributor License Agreement before pull request can be accepted. The discussion of the proposal follows. Pull request comments should be used as the sole discussion forum. The discussion lasts for as long as the advocate feels necessary, but must be at least 7 calendar days. The advocate is responsible for timely update of the proposal (i.e. pull request) based on the comments for which they agree to. At any point in time the advocate can claim proposal abandoned. The advocate can call for a vote on a version of the proposal at any point in time following the initial 7-day interval required for discussion. Before calling for a vote, at least one GTFS-realtime producer and one GTFS-realtime consumer should implement the proposed change. It is expected that the GTFS-realtime producer(s) include the change in a public-facing GTFS-realtime feed and provide a link to that data within the pull request comments, and that the GTFS-realtime consumer(s) provides a link in the pull request comments to an application that is utilizing the change in a non-trivial manner (i.e, it is supporting new or improved functionality). When calling for a vote, the advocate should clearly state whether the vote is for official adoption of the field into the spec or for an experimental field. Vote lasts the minimum period sufficient to cover 7 full calendar days and 5 full Swiss business days. Vote ends at 23:59:59 UTC. The advocate should announce the specific end time at the start of the vote. During voting period only editorial changes to the proposal are allowed (typos, wording may change as long as it does not change the meaning). Anyone is allowed to vote yes/no in a form of comment to the pull request, and votes can be changed until the end of the voting period. If a voter changes her vote, it is recommended to do it by updating the original vote comment by striking through the vote and writing the new vote. Votes before the start of the voting period are not considered. The proposal is accepted if there is a unanimous consensus yes with at least 3 votes. The proposer's vote does not count towards the 3 vote total. For example, if Proposer X creates a pull request and votes yes, and User Y and Z vote yes, this is counted as 2 total yes votes. Votes against shall be motivated, and ideally provide actionable feedback. If the vote has failed, then the advocate may choose to continue work on the proposal, or to abandon the proposal. Either decision of the advocate must be announced in the mailing list. If the advocate continues the work on proposal then a new vote can be called for at any point in time. Any pull request remaining inactive for 30 calendar days will be closed. When a pull request is closed, the corresponding proposal is considered abandoned. The advocate may reopen the pull request at any time if they wish to continue or maintain the conversation. Note that the advocate may choose to implement the feature as an custom extension instead of part of the official spec. If the proposal is accepted: Google is committed to merging the voted upon version of the pull request (provided that the contributors have signed the CLA , and performing the pull request within 5 business days. Google is committed to timely updating https://github.com/google/gtfs-realtime-bindings repository. Commits to gtfs-realtime-bindigs that are a result of a proposal, should reference the pull request of the proposal. Translations must not be included into the original pull request. Google is responsible for eventually updating relevant translations into supported languages, but pure translation pull requests from the community are welcome and will be accepted as soon as all editorial comments are addressed. Experimental fields \u00b6 If the community can come to consensus (a) that the proposed field seems useful and (b) on the type of the field ( optional vs repeated , string vs int vs bool ), then a field number will be allocated in the GTFS Realtime message and a note will be made in the .proto file and documentation that this is an experimental field that may change in the future. Consensus is reached via a discussion and voting process that is the same as the below Specification amendment process , but instead of unanimous consent only 80% yes votes are required for approval. GTFS Realtime producers and consumers that wish to use the new experimental field will re-generate their library using the .proto file with the new field (e.g., Google will update the gtfs-realtime-bindings library ), and start populating and parsing the field with live data. Once we are satisfied that the experimental field is worthwhile and both producers and consumers are using the field, then we will follow the below Specification amendment process to officially add the field to the spec. If the experimental field is not adopted via the Specification amendment process within 2 years of being approved as an experimental field, it will be deprecated by adding [deprecated=true] next to the field value in the .proto file file. By using [deprecated=true] (instead of RESERVED ), producers and consumers that have already adopted the field do not have to remove it from use. Additionally, the field may be \"un-deprecated\" in the future if it is approved in a subsequent vote following the Specification amendment process (e.g., when additional producers and/or consumers start using the field). If the new field is considered specific to a single producer or there is dispute over the data type, then we will assign a custom extension to the producer so they can use the field in their own feed. When possible we should avoid extensions and add fields useful to many agencies to the main specification to avoid fragmentation and extra work for consumers to support various extensions to the spec.","title":"Specification Amendment Process"},{"location":"realtime/process/#adding-new-fields-to-gtfs-realtime","text":"When a producer or consumer is interested in adding a new field to the GTFS Realtime specification, they should open a new issue on the GTFS Realtime GitHub repository describing the proposed field and announce this new field (including a link to the issue) on the GTFS Realtime mailing list .","title":"Adding new fields to GTFS Realtime"},{"location":"realtime/process/#specification-amendment-process","text":"Create a git branch with update of all relevant parts of protocol definition, specification and documentation files (except for translations). Create pull request on https://github.com/google/transit. Pull request must contain an extended description of the patch. The creator of the pull request becomes the advocate . Once pull request is registered, it must be announced by its advocate in the GTFS Realtime mailing list . Once announced, the pull request is considered a proposal. Since the advocate is a contributor, they must sign the Contributor License Agreement before pull request can be accepted. The discussion of the proposal follows. Pull request comments should be used as the sole discussion forum. The discussion lasts for as long as the advocate feels necessary, but must be at least 7 calendar days. The advocate is responsible for timely update of the proposal (i.e. pull request) based on the comments for which they agree to. At any point in time the advocate can claim proposal abandoned. The advocate can call for a vote on a version of the proposal at any point in time following the initial 7-day interval required for discussion. Before calling for a vote, at least one GTFS-realtime producer and one GTFS-realtime consumer should implement the proposed change. It is expected that the GTFS-realtime producer(s) include the change in a public-facing GTFS-realtime feed and provide a link to that data within the pull request comments, and that the GTFS-realtime consumer(s) provides a link in the pull request comments to an application that is utilizing the change in a non-trivial manner (i.e, it is supporting new or improved functionality). When calling for a vote, the advocate should clearly state whether the vote is for official adoption of the field into the spec or for an experimental field. Vote lasts the minimum period sufficient to cover 7 full calendar days and 5 full Swiss business days. Vote ends at 23:59:59 UTC. The advocate should announce the specific end time at the start of the vote. During voting period only editorial changes to the proposal are allowed (typos, wording may change as long as it does not change the meaning). Anyone is allowed to vote yes/no in a form of comment to the pull request, and votes can be changed until the end of the voting period. If a voter changes her vote, it is recommended to do it by updating the original vote comment by striking through the vote and writing the new vote. Votes before the start of the voting period are not considered. The proposal is accepted if there is a unanimous consensus yes with at least 3 votes. The proposer's vote does not count towards the 3 vote total. For example, if Proposer X creates a pull request and votes yes, and User Y and Z vote yes, this is counted as 2 total yes votes. Votes against shall be motivated, and ideally provide actionable feedback. If the vote has failed, then the advocate may choose to continue work on the proposal, or to abandon the proposal. Either decision of the advocate must be announced in the mailing list. If the advocate continues the work on proposal then a new vote can be called for at any point in time. Any pull request remaining inactive for 30 calendar days will be closed. When a pull request is closed, the corresponding proposal is considered abandoned. The advocate may reopen the pull request at any time if they wish to continue or maintain the conversation. Note that the advocate may choose to implement the feature as an custom extension instead of part of the official spec. If the proposal is accepted: Google is committed to merging the voted upon version of the pull request (provided that the contributors have signed the CLA , and performing the pull request within 5 business days. Google is committed to timely updating https://github.com/google/gtfs-realtime-bindings repository. Commits to gtfs-realtime-bindigs that are a result of a proposal, should reference the pull request of the proposal. Translations must not be included into the original pull request. Google is responsible for eventually updating relevant translations into supported languages, but pure translation pull requests from the community are welcome and will be accepted as soon as all editorial comments are addressed.","title":"Specification amendment process"},{"location":"realtime/process/#experimental-fields","text":"If the community can come to consensus (a) that the proposed field seems useful and (b) on the type of the field ( optional vs repeated , string vs int vs bool ), then a field number will be allocated in the GTFS Realtime message and a note will be made in the .proto file and documentation that this is an experimental field that may change in the future. Consensus is reached via a discussion and voting process that is the same as the below Specification amendment process , but instead of unanimous consent only 80% yes votes are required for approval. GTFS Realtime producers and consumers that wish to use the new experimental field will re-generate their library using the .proto file with the new field (e.g., Google will update the gtfs-realtime-bindings library ), and start populating and parsing the field with live data. Once we are satisfied that the experimental field is worthwhile and both producers and consumers are using the field, then we will follow the below Specification amendment process to officially add the field to the spec. If the experimental field is not adopted via the Specification amendment process within 2 years of being approved as an experimental field, it will be deprecated by adding [deprecated=true] next to the field value in the .proto file file. By using [deprecated=true] (instead of RESERVED ), producers and consumers that have already adopted the field do not have to remove it from use. Additionally, the field may be \"un-deprecated\" in the future if it is approved in a subsequent vote following the Specification amendment process (e.g., when additional producers and/or consumers start using the field). If the new field is considered specific to a single producer or there is dispute over the data type, then we will assign a custom extension to the producer so they can use the field in their own feed. When possible we should avoid extensions and add fields useful to many agencies to the main specification to avoid fragmentation and extra work for consumers to support various extensions to the spec.","title":"Experimental fields"},{"location":"realtime/proto/","text":"GTFS Realtime Protobuf \u00b6 Download the gtfs-realtime.proto file and use it to compile your GTFS-realtime feed. The contents of the file are shown inline below. For more information about using protobufs, see the Protocol Buffers Developer Guide . // Copyright 2015 The GTFS Specifications Authors. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // https://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // Protocol definition file for GTFS Realtime. // // GTFS Realtime lets transit agencies provide consumers with realtime // information about disruptions to their service (stations closed, lines not // operating, important delays etc), location of their vehicles and expected // arrival times. // // This protocol is published at: // https://github.com/google/transit/tree/master/gtfs-realtime syntax = \"proto2\" ; option java_package = \"com.google.transit.realtime\" ; package transit_realtime ; // The contents of a feed message. // A feed is a continuous stream of feed messages. Each message in the stream is // obtained as a response to an appropriate HTTP GET request. // A realtime feed is always defined with relation to an existing GTFS feed. // All the entity ids are resolved with respect to the GTFS feed. // Note that \"required\" and \"optional\" as stated in this file refer to Protocol // Buffer cardinality, not semantic cardinality. See reference.md at // https://github.com/google/transit/tree/master/gtfs-realtime for field // semantic cardinality. message FeedMessage { // Metadata about this feed and feed message. required FeedHeader header = 1 ; // Contents of the feed. repeated FeedEntity entity = 2 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // Metadata about a feed, included in feed messages. message FeedHeader { // Version of the feed specification. // The current version is 2.0. Valid versions are \"2.0\", \"1.0\". required string gtfs_realtime_version = 1 ; // Determines whether the current fetch is incremental. Currently, // DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds // that use this mode. There are discussions on the GTFS Realtime mailing // list around fully specifying the behavior of DIFFERENTIAL mode and the // documentation will be updated when those discussions are finalized. enum Incrementality { FULL_DATASET = 0 ; DIFFERENTIAL = 1 ; } optional Incrementality incrementality = 2 [ default = FULL_DATASET ]; // This timestamp identifies the moment when the content of this feed has been // created (in server time). In POSIX time (i.e., number of seconds since // January 1st 1970 00:00:00 UTC). optional uint64 timestamp = 3 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // A definition (or update) of an entity in the transit feed. message FeedEntity { // The ids are used only to provide incrementality support. The id should be // unique within a FeedMessage. Consequent FeedMessages may contain // FeedEntities with the same id. In case of a DIFFERENTIAL update the new // FeedEntity with some id will replace the old FeedEntity with the same id // (or delete it - see is_deleted below). // The actual GTFS entities (e.g. stations, routes, trips) referenced by the // feed must be specified by explicit selectors (see EntitySelector below for // more info). required string id = 1 ; // Whether this entity is to be deleted. Relevant only for incremental // fetches. optional bool is_deleted = 2 [ default = false ]; // Data about the entity itself. Exactly one of the following fields must be // present (unless the entity is being deleted). optional TripUpdate trip_update = 3 ; optional VehiclePosition vehicle = 4 ; optional Alert alert = 5 ; // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional Shape shape = 6 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // // Entities used in the feed. // // Realtime update of the progress of a vehicle along a trip. // Depending on the value of ScheduleRelationship, a TripUpdate can specify: // - A trip that proceeds along the schedule. // - A trip that proceeds along a route but has no fixed schedule. // - A trip that have been added or removed with regard to schedule. // // The updates can be for future, predicted arrival/departure events, or for // past events that already occurred. // Normally, updates should get more precise and more certain (see // uncertainty below) as the events gets closer to current time. // Even if that is not possible, the information for past events should be // precise and certain. In particular, if an update points to time in the past // but its update's uncertainty is not 0, the client should conclude that the // update is a (wrong) prediction and that the trip has not completed yet. // // Note that the update can describe a trip that is already completed. // To this end, it is enough to provide an update for the last stop of the trip. // If the time of that is in the past, the client will conclude from that that // the whole trip is in the past (it is possible, although inconsequential, to // also provide updates for preceding stops). // This option is most relevant for a trip that has completed ahead of schedule, // but according to the schedule, the trip is still proceeding at the current // time. Removing the updates for this trip could make the client assume // that the trip is still proceeding. // Note that the feed provider is allowed, but not required, to purge past // updates - this is one case where this would be practically useful. message TripUpdate { // The Trip that this message applies to. There can be at most one // TripUpdate entity for each actual trip instance. // If there is none, that means there is no prediction information available. // It does *not* mean that the trip is progressing according to schedule. required TripDescriptor trip = 1 ; // Additional information on the vehicle that is serving this trip. optional VehicleDescriptor vehicle = 3 ; // Timing information for a single predicted event (either arrival or // departure). // Timing consists of delay and/or estimated time, and uncertainty. // - delay should be used when the prediction is given relative to some // existing schedule in GTFS. // - time should be given whether there is a predicted schedule or not. If // both time and delay are specified, time will take precedence // (although normally, time, if given for a scheduled trip, should be // equal to scheduled time in GTFS + delay). // // Uncertainty applies equally to both time and delay. // The uncertainty roughly specifies the expected error in true delay (but // note, we don't yet define its precise statistical meaning). It's possible // for the uncertainty to be 0, for example for trains that are driven under // computer timing control. message StopTimeEvent { // Delay (in seconds) can be positive (meaning that the vehicle is late) or // negative (meaning that the vehicle is ahead of schedule). Delay of 0 // means that the vehicle is exactly on time. optional int32 delay = 1 ; // Event as absolute time. // In Unix time (i.e., number of seconds since January 1st 1970 00:00:00 // UTC). optional int64 time = 2 ; // If uncertainty is omitted, it is interpreted as unknown. // If the prediction is unknown or too uncertain, the delay (or time) field // should be empty. In such case, the uncertainty field is ignored. // To specify a completely certain prediction, set its uncertainty to 0. optional int32 uncertainty = 3 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features // and modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // Realtime update for arrival and/or departure events for a given stop on a // trip. Updates can be supplied for both past and future events. // The producer is allowed, although not required, to drop past events. message StopTimeUpdate { // The update is linked to a specific stop either through stop_sequence or // stop_id, so one of the fields below must necessarily be set. // See the documentation in TripDescriptor for more information. // Must be the same as in stop_times.txt in the corresponding GTFS feed. optional uint32 stop_sequence = 1 ; // Must be the same as in stops.txt in the corresponding GTFS feed. optional string stop_id = 4 ; optional StopTimeEvent arrival = 2 ; optional StopTimeEvent departure = 3 ; // Expected occupancy after departure from the given stop. // Should be provided only for future stops. // In order to provide departure_occupancy_status without either arrival or // departure StopTimeEvents, ScheduleRelationship should be set to NO_DATA. optional VehiclePosition.OccupancyStatus departure_occupancy_status = 7 ; // The relation between the StopTimeEvents and the static schedule. enum ScheduleRelationship { // The vehicle is proceeding in accordance with its static schedule of // stops, although not necessarily according to the times of the schedule. // At least one of arrival and departure must be provided. If the schedule // for this stop contains both arrival and departure times then so must // this update. Frequency-based trips (GTFS frequencies.txt with exact_times = 0) // should not have a SCHEDULED value and should use UNSCHEDULED instead. SCHEDULED = 0 ; // The stop is skipped, i.e., the vehicle will not stop at this stop. // Arrival and departure are optional. SKIPPED = 1 ; // No StopTimeEvents are given for this stop. // The main intention for this value is to give time predictions only for // part of a trip, i.e., if the last update for a trip has a NO_DATA // specifier, then StopTimeEvents for the rest of the stops in the trip // are considered to be unspecified as well. // Neither arrival nor departure should be supplied. NO_DATA = 2 ; // The vehicle is operating a trip defined in GTFS frequencies.txt with exact_times = 0. // This value should not be used for trips that are not defined in GTFS frequencies.txt, // or trips in GTFS frequencies.txt with exact_times = 1. Trips containing StopTimeUpdates // with ScheduleRelationship=UNSCHEDULED must also set TripDescriptor.ScheduleRelationship=UNSCHEDULED. // NOTE: This field is still experimental, and subject to change. It may be // formally adopted in the future. UNSCHEDULED = 3 ; } optional ScheduleRelationship schedule_relationship = 5 [ default = SCHEDULED ]; // Provides the updated values for the stop time. // NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future. message StopTimeProperties { // Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt. // The new assigned_stop_id should not result in a significantly different trip experience for the end user than // the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an // \"unusual change\" if the new stop was presented within an app without any additional context. // For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the // same station as the stop originally defined in GTFS stop_times.txt. // To assign a stop without providing any real-time arrival or departure predictions, populate this field and set // StopTimeUpdate.schedule_relationship = NO_DATA. // If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If // `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`. // Platform assignments should be reflected in other GTFS-realtime fields as well // (e.g., `VehiclePosition.stop_id`). // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional string assigned_stop_id = 1 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features // and modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // Realtime updates for certain properties defined within GTFS stop_times.txt // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional StopTimeProperties stop_time_properties = 6 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features // and modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // Updates to StopTimes for the trip (both future, i.e., predictions, and in // some cases, past ones, i.e., those that already happened). // The updates must be sorted by stop_sequence, and apply for all the // following stops of the trip up to the next specified one. // // Example 1: // For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure // delay of 0 for stop_sequence of the current stop means that the trip is // exactly on time. // // Example 2: // For the same trip instance, 3 StopTimeUpdates are provided: // - delay of 5 min for stop_sequence 3 // - delay of 1 min for stop_sequence 8 // - delay of unspecified duration for stop_sequence 10 // This will be interpreted as: // - stop_sequences 3,4,5,6,7 have delay of 5 min. // - stop_sequences 8,9 have delay of 1 min. // - stop_sequences 10,... have unknown delay. repeated StopTimeUpdate stop_time_update = 2 ; // The most recent moment at which the vehicle's real-time progress was measured // to estimate StopTimes in the future. When StopTimes in the past are provided, // arrival/departure times may be earlier than this value. In POSIX // time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC). optional uint64 timestamp = 4 ; // The current schedule deviation for the trip. Delay should only be // specified when the prediction is given relative to some existing schedule // in GTFS. // // Delay (in seconds) can be positive (meaning that the vehicle is late) or // negative (meaning that the vehicle is ahead of schedule). Delay of 0 // means that the vehicle is exactly on time. // // Delay information in StopTimeUpdates take precedent of trip-level delay // information, such that trip-level delay is only propagated until the next // stop along the trip with a StopTimeUpdate delay value specified. // // Feed providers are strongly encouraged to provide a TripUpdate.timestamp // value indicating when the delay value was last updated, in order to // evaluate the freshness of the data. // // NOTE: This field is still experimental, and subject to change. It may be // formally adopted in the future. optional int32 delay = 5 ; // Defines updated properties of the trip, such as a new shape_id when there is a detour. Or defines the // trip_id, start_date, and start_time of a DUPLICATED trip. // NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future. message TripProperties { // Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt // but will start at a different service date and/or time (defined using the TripProperties.start_date and // TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different // than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not // be populated and will be ignored by consumers. // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional string trip_id = 1 ; // Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if // schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers. // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional string start_date = 2 ; // Defines the departure start time of the trip when it\u2019s duplicated. See definition of stop_times.departure_time // in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset // between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a // departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value // of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction // delay values are applied to this calculated schedule time to determine the predicted time. For example, if a // departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time // prediction time values do not have any offset applied to them and indicate the predicted time as provided. // For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time // is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be // populated and will be ignored by consumers. // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional string start_time = 3 ; // Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in // (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing // paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS // nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt // or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as // (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should // be marked as schedule_relationship=SKIPPED. // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional string shape_id = 4 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features // and modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } optional TripProperties trip_properties = 6 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // Realtime positioning information for a given vehicle. message VehiclePosition { // The Trip that this vehicle is serving. // Can be empty or partial if the vehicle can not be identified with a given // trip instance. optional TripDescriptor trip = 1 ; // Additional information on the vehicle that is serving this trip. optional VehicleDescriptor vehicle = 8 ; // Current position of this vehicle. optional Position position = 2 ; // The stop sequence index of the current stop. The meaning of // current_stop_sequence (i.e., the stop that it refers to) is determined by // current_status. // If current_status is missing IN_TRANSIT_TO is assumed. optional uint32 current_stop_sequence = 3 ; // Identifies the current stop. The value must be the same as in stops.txt in // the corresponding GTFS feed. optional string stop_id = 7 ; enum VehicleStopStatus { // The vehicle is just about to arrive at the stop (on a stop // display, the vehicle symbol typically flashes). INCOMING_AT = 0 ; // The vehicle is standing at the stop. STOPPED_AT = 1 ; // The vehicle has departed and is in transit to the next stop. IN_TRANSIT_TO = 2 ; } // The exact status of the vehicle with respect to the current stop. // Ignored if current_stop_sequence is missing. optional VehicleStopStatus current_status = 4 [ default = IN_TRANSIT_TO ]; // Moment at which the vehicle's position was measured. In POSIX time // (i.e., number of seconds since January 1st 1970 00:00:00 UTC). optional uint64 timestamp = 5 ; // Congestion level that is affecting this vehicle. enum CongestionLevel { UNKNOWN_CONGESTION_LEVEL = 0 ; RUNNING_SMOOTHLY = 1 ; STOP_AND_GO = 2 ; CONGESTION = 3 ; SEVERE_CONGESTION = 4 ; // People leaving their cars. } optional CongestionLevel congestion_level = 6 ; // The state of passenger occupancy for the vehicle or carriage. // Individual producers may not publish all OccupancyStatus values. Therefore, consumers // must not assume that the OccupancyStatus values follow a linear scale. // Consumers should represent OccupancyStatus values as the state indicated // and intended by the producer. Likewise, producers must use OccupancyStatus values that // correspond to actual vehicle occupancy states. // For describing passenger occupancy levels on a linear scale, see `occupancy_percentage`. // This field is still experimental, and subject to change. It may be formally adopted in the future. enum OccupancyStatus { // The vehicle or carriage is considered empty by most measures, and has few or no // passengers onboard, but is still accepting passengers. EMPTY = 0 ; // The vehicle or carriage has a large number of seats available. // The amount of free seats out of the total seats available to be // considered large enough to fall into this category is determined at the // discretion of the producer. MANY_SEATS_AVAILABLE = 1 ; // The vehicle or carriage has a relatively small number of seats available. // The amount of free seats out of the total seats available to be // considered small enough to fall into this category is determined at the // discretion of the feed producer. FEW_SEATS_AVAILABLE = 2 ; // The vehicle or carriage can currently accommodate only standing passengers. STANDING_ROOM_ONLY = 3 ; // The vehicle or carriage can currently accommodate only standing passengers // and has limited space for them. CRUSHED_STANDING_ROOM_ONLY = 4 ; // The vehicle or carriage is considered full by most measures, but may still be // allowing passengers to board. FULL = 5 ; // The vehicle or carriage is not accepting passengers, but usually accepts passengers for boarding. NOT_ACCEPTING_PASSENGERS = 6 ; // The vehicle or carriage doesn't have any occupancy data available at that time. NO_DATA_AVAILABLE = 7 ; // The vehicle or carriage is not boardable and never accepts passengers. // Useful for special vehicles or carriages (engine, maintenance carriage, etc\u2026). NOT_BOARDABLE = 8 ; } // If multi_carriage_status is populated with per-carriage OccupancyStatus, // then this field should describe the entire vehicle with all carriages accepting passengers considered. optional OccupancyStatus occupancy_status = 9 ; // A percentage value indicating the degree of passenger occupancy in the vehicle. // The values are represented as an integer without decimals. 0 means 0% and 100 means 100%. // The value 100 should represent the total maximum occupancy the vehicle was designed for, // including both seated and standing capacity, and current operating regulations allow. // The value may exceed 100 if there are more passengers than the maximum designed capacity. // The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle. // If multi_carriage_status is populated with per-carriage occupancy_percentage, // then this field should describe the entire vehicle with all carriages accepting passengers considered. // This field is still experimental, and subject to change. It may be formally adopted in the future. optional uint32 occupancy_percentage = 10 ; // Carriage specific details, used for vehicles composed of several carriages // This message/field is still experimental, and subject to change. It may be formally adopted in the future. message CarriageDetails { // Identification of the carriage. Should be unique per vehicle. optional string id = 1 ; // User visible label that may be shown to the passenger to help identify // the carriage. Example: \"7712\", \"Car ABC-32\", etc... // This message/field is still experimental, and subject to change. It may be formally adopted in the future. optional string label = 2 ; // Occupancy status for this given carriage, in this vehicle // This message/field is still experimental, and subject to change. It may be formally adopted in the future. optional OccupancyStatus occupancy_status = 3 [ default = NO_DATA_AVAILABLE ]; // Occupancy percentage for this given carriage, in this vehicle. // Follows the same rules as \"VehiclePosition.occupancy_percentage\" // -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise) // This message/field is still experimental, and subject to change. It may be formally adopted in the future. optional int32 occupancy_percentage = 4 [ default = - 1 ]; // Identifies the order of this carriage with respect to the other // carriages in the vehicle's list of CarriageDetails. // The first carriage in the direction of travel must have a value of 1. // The second value corresponds to the second carriage in the direction // of travel and must have a value of 2, and so forth. // For example, the first carriage in the direction of travel has a value of 1. // If the second carriage in the direction of travel has a value of 3, // consumers will discard data for all carriages (i.e., the multi_carriage_details field). // Carriages without data must be represented with a valid carriage_sequence number and the fields // without data should be omitted (alternately, those fields could also be included and set to the \"no data\" values). // This message/field is still experimental, and subject to change. It may be formally adopted in the future. optional uint32 carriage_sequence = 5 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // Details of the multiple carriages of this given vehicle. // The first occurrence represents the first carriage of the vehicle, // given the current direction of travel. // The number of occurrences of the multi_carriage_details // field represents the number of carriages of the vehicle. // It also includes non boardable carriages, // like engines, maintenance carriages, etc\u2026 as they provide valuable // information to passengers about where to stand on a platform. // This message/field is still experimental, and subject to change. It may be formally adopted in the future. repeated CarriageDetails multi_carriage_details = 11 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // An alert, indicating some sort of incident in the public transit network. message Alert { // Time when the alert should be shown to the user. If missing, the // alert will be shown as long as it appears in the feed. // If multiple ranges are given, the alert will be shown during all of them. repeated TimeRange active_period = 1 ; // Entities whose users we should notify of this alert. repeated EntitySelector informed_entity = 5 ; // Cause of this alert. enum Cause { UNKNOWN_CAUSE = 1 ; OTHER_CAUSE = 2 ; // Not machine-representable. TECHNICAL_PROBLEM = 3 ; STRIKE = 4 ; // Public transit agency employees stopped working. DEMONSTRATION = 5 ; // People are blocking the streets. ACCIDENT = 6 ; HOLIDAY = 7 ; WEATHER = 8 ; MAINTENANCE = 9 ; CONSTRUCTION = 10 ; POLICE_ACTIVITY = 11 ; MEDICAL_EMERGENCY = 12 ; } optional Cause cause = 6 [ default = UNKNOWN_CAUSE ]; // What is the effect of this problem on the affected entity. enum Effect { NO_SERVICE = 1 ; REDUCED_SERVICE = 2 ; // We don't care about INsignificant delays: they are hard to detect, have // little impact on the user, and would clutter the results as they are too // frequent. SIGNIFICANT_DELAYS = 3 ; DETOUR = 4 ; ADDITIONAL_SERVICE = 5 ; MODIFIED_SERVICE = 6 ; OTHER_EFFECT = 7 ; UNKNOWN_EFFECT = 8 ; STOP_MOVED = 9 ; NO_EFFECT = 10 ; ACCESSIBILITY_ISSUE = 11 ; } optional Effect effect = 7 [ default = UNKNOWN_EFFECT ]; // The URL which provides additional information about the alert. optional TranslatedString url = 8 ; // Alert header. Contains a short summary of the alert text as plain-text. optional TranslatedString header_text = 10 ; // Full description for the alert as plain-text. The information in the // description should add to the information of the header. optional TranslatedString description_text = 11 ; // Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text. optional TranslatedString tts_header_text = 12 ; // Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text. optional TranslatedString tts_description_text = 13 ; // Severity of this alert. enum SeverityLevel { UNKNOWN_SEVERITY = 1 ; INFO = 2 ; WARNING = 3 ; SEVERE = 4 ; } optional SeverityLevel severity_level = 14 [ default = UNKNOWN_SEVERITY ]; // TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text. // The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional TranslatedImage image = 15 ; // Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed // or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt. // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional TranslatedString image_alternative_text = 16 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features // and modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // // Low level data structures used above. // // A time interval. The interval is considered active at time 't' if 't' is // greater than or equal to the start time and less than the end time. message TimeRange { // Start time, in POSIX time (i.e., number of seconds since January 1st 1970 // 00:00:00 UTC). // If missing, the interval starts at minus infinity. optional uint64 start = 1 ; // End time, in POSIX time (i.e., number of seconds since January 1st 1970 // 00:00:00 UTC). // If missing, the interval ends at plus infinity. optional uint64 end = 2 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // A position. message Position { // Degrees North, in the WGS-84 coordinate system. required float latitude = 1 ; // Degrees East, in the WGS-84 coordinate system. required float longitude = 2 ; // Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East. // This can be the compass bearing, or the direction towards the next stop // or intermediate location. // This should not be direction deduced from the sequence of previous // positions, which can be computed from previous data. optional float bearing = 3 ; // Odometer value, in meters. optional double odometer = 4 ; // Momentary speed measured by the vehicle, in meters per second. optional float speed = 5 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // A descriptor that identifies an instance of a GTFS trip, or all instances of // a trip along a route. // - To specify a single trip instance, the trip_id (and if necessary, // start_time) is set. If route_id is also set, then it should be same as one // that the given trip corresponds to. // - To specify all the trips along a given route, only the route_id should be // set. Note that if the trip_id is not known, then stop sequence ids in // TripUpdate are not sufficient, and stop_ids must be provided as well. In // addition, absolute arrival/departure times must be provided. message TripDescriptor { // The trip_id from the GTFS feed that this selector refers to. // For non frequency-based trips, this field is enough to uniquely identify // the trip. For frequency-based trip, start_time and start_date might also be // necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from // static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id // identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id. optional string trip_id = 1 ; // The route_id from the GTFS that this selector refers to. optional string route_id = 5 ; // The direction_id from the GTFS feed trips.txt file, indicating the // direction of travel for trips this selector refers to. optional uint32 direction_id = 6 ; // The initially scheduled start time of this trip instance. // When the trip_id corresponds to a non-frequency-based trip, this field // should either be omitted or be equal to the value in the GTFS feed. When // the trip_id correponds to a frequency-based trip, the start_time must be // specified for trip updates and vehicle positions. If the trip corresponds // to exact_times=1 GTFS record, then start_time must be some multiple // (including zero) of headway_secs later than frequencies.txt start_time for // the corresponding time period. If the trip corresponds to exact_times=0, // then its start_time may be arbitrary, and is initially expected to be the // first departure of the trip. Once established, the start_time of this // frequency-based trip should be considered immutable, even if the first // departure time changes -- that time change may instead be reflected in a // StopTimeUpdate. // Format and semantics of the field is same as that of // GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35. optional string start_time = 2 ; // The scheduled start date of this trip instance. // Must be provided to disambiguate trips that are so late as to collide with // a scheduled trip on a next day. For example, for a train that departs 8:00 // and 20:00 every day, and is 12 hours late, there would be two distinct // trips on the same time. // This field can be provided but is not mandatory for schedules in which such // collisions are impossible - for example, a service running on hourly // schedule where a vehicle that is one hour late is not considered to be // related to schedule anymore. // In YYYYMMDD format. optional string start_date = 3 ; // The relation between this trip and the static schedule. If a trip is done // in accordance with temporary schedule, not reflected in GTFS, then it // shouldn't be marked as SCHEDULED, but likely as ADDED. enum ScheduleRelationship { // Trip that is running in accordance with its GTFS schedule, or is close // enough to the scheduled trip to be associated with it. SCHEDULED = 0 ; // An extra trip that was added in addition to a running schedule, for // example, to replace a broken vehicle or to respond to sudden passenger // load. // NOTE: Currently, behavior is unspecified for feeds that use this mode. There are discussions on the GTFS GitHub // [(1)](https://github.com/google/transit/issues/106) [(2)](https://github.com/google/transit/pull/221) // [(3)](https://github.com/google/transit/pull/219) around fully specifying or deprecating ADDED trips and the // documentation will be updated when those discussions are finalized. ADDED = 1 ; // A trip that is running with no schedule associated to it (GTFS frequencies.txt exact_times=0). // Trips with ScheduleRelationship=UNSCHEDULED must also set all StopTimeUpdates.ScheduleRelationship=UNSCHEDULED. UNSCHEDULED = 2 ; // A trip that existed in the schedule but was removed. CANCELED = 3 ; // Should not be used - for backwards-compatibility only. REPLACEMENT = 5 [ deprecated = true ]; // An extra trip that was added in addition to a running schedule, for example, to replace a broken vehicle or to // respond to sudden passenger load. Used with TripUpdate.TripProperties.trip_id, TripUpdate.TripProperties.start_date, // and TripUpdate.TripProperties.start_time to copy an existing trip from static GTFS but start at a different service // date and/or time. Duplicating a trip is allowed if the service related to the original trip in (CSV) GTFS // (in calendar.txt or calendar_dates.txt) is operating within the next 30 days. The trip to be duplicated is // identified via TripUpdate.TripDescriptor.trip_id. This enumeration does not modify the existing trip referenced by // TripUpdate.TripDescriptor.trip_id - if a producer wants to cancel the original trip, it must publish a separate // TripUpdate with the value of CANCELED. Trips defined in GTFS frequencies.txt with exact_times that is empty or // equal to 0 cannot be duplicated. The VehiclePosition.TripDescriptor.trip_id for the new trip must contain // the matching value from TripUpdate.TripProperties.trip_id and VehiclePosition.TripDescriptor.ScheduleRelationship // must also be set to DUPLICATED. // Existing producers and consumers that were using the ADDED enumeration to represent duplicated trips must follow // the migration guide (https://github.com/google/transit/tree/master/gtfs-realtime/spec/en/examples/migration-duplicated.md) // to transition to the DUPLICATED enumeration. // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. DUPLICATED = 6 ; } optional ScheduleRelationship schedule_relationship = 4 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // Identification information for the vehicle performing the trip. message VehicleDescriptor { // Internal system identification of the vehicle. Should be unique per // vehicle, and can be used for tracking the vehicle as it proceeds through // the system. optional string id = 1 ; // User visible label, i.e., something that must be shown to the passenger to // help identify the correct vehicle. optional string label = 2 ; // The license plate of the vehicle. optional string license_plate = 3 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // A selector for an entity in a GTFS feed. message EntitySelector { // The values of the fields should correspond to the appropriate fields in the // GTFS feed. // At least one specifier must be given. If several are given, then the // matching has to apply to all the given specifiers. optional string agency_id = 1 ; optional string route_id = 2 ; // corresponds to route_type in GTFS. optional int32 route_type = 3 ; optional TripDescriptor trip = 4 ; optional string stop_id = 5 ; // Corresponds to trip direction_id in GTFS trips.txt. If provided the // route_id must also be provided. optional uint32 direction_id = 6 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // An internationalized message containing per-language versions of a snippet of // text or a URL. // One of the strings from a message will be picked up. The resolution proceeds // as follows: // 1. If the UI language matches the language code of a translation, // the first matching translation is picked. // 2. If a default UI language (e.g., English) matches the language code of a // translation, the first matching translation is picked. // 3. If some translation has an unspecified language code, that translation is // picked. message TranslatedString { message Translation { // A UTF-8 string containing the message. required string text = 1 ; // BCP-47 language code. Can be omitted if the language is unknown or if // no i18n is done at all for the feed. At most one translation is // allowed to have an unspecified language tag. optional string language = 2 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // At least one translation must be provided. repeated Translation translation = 1 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // An internationalized image containing per-language versions of a URL linking to an image // along with meta information // Only one of the images from a message will be retained by consumers. The resolution proceeds // as follows: // 1. If the UI language matches the language code of a translation, // the first matching translation is picked. // 2. If a default UI language (e.g., English) matches the language code of a // translation, the first matching translation is picked. // 3. If some translation has an unspecified language code, that translation is // picked. // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. message TranslatedImage { message LocalizedImage { // String containing an URL linking to an image // The image linked must be less than 2MB. // If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one. // The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following https://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values. required string url = 1 ; // IANA media type as to specify the type of image to be displayed. // The type must start with \"image/\" required string media_type = 2 ; // BCP-47 language code. Can be omitted if the language is unknown or if // no i18n is done at all for the feed. At most one translation is // allowed to have an unspecified language tag. optional string language = 3 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // At least one localized image must be provided. repeated LocalizedImage localized_image = 1 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // Describes the physical path that a vehicle takes when it's not part of the (CSV) GTFS, // such as for a detour. Shapes belong to Trips, and consist of a sequence of shape points. // Tracing the points in order provides the path of the vehicle. Shapes do not need to intercept // the location of Stops exactly, but all Stops on a trip should lie within a small distance of // the shape for that trip, i.e. close to straight line segments connecting the shape points // NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future. message Shape { // Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS. // This field is required as per reference.md, but needs to be specified here optional because \"Required is Forever\" // See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional string shape_id = 1 ; // Encoded polyline representation of the shape. This polyline must contain at least two points. // For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm // This field is required as per reference.md, but needs to be specified here optional because \"Required is Forever\" // See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional string encoded_polyline = 2 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; }","title":"Protobuf"},{"location":"realtime/proto/#gtfs-realtime-protobuf","text":"Download the gtfs-realtime.proto file and use it to compile your GTFS-realtime feed. The contents of the file are shown inline below. For more information about using protobufs, see the Protocol Buffers Developer Guide . // Copyright 2015 The GTFS Specifications Authors. // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // https://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. // Protocol definition file for GTFS Realtime. // // GTFS Realtime lets transit agencies provide consumers with realtime // information about disruptions to their service (stations closed, lines not // operating, important delays etc), location of their vehicles and expected // arrival times. // // This protocol is published at: // https://github.com/google/transit/tree/master/gtfs-realtime syntax = \"proto2\" ; option java_package = \"com.google.transit.realtime\" ; package transit_realtime ; // The contents of a feed message. // A feed is a continuous stream of feed messages. Each message in the stream is // obtained as a response to an appropriate HTTP GET request. // A realtime feed is always defined with relation to an existing GTFS feed. // All the entity ids are resolved with respect to the GTFS feed. // Note that \"required\" and \"optional\" as stated in this file refer to Protocol // Buffer cardinality, not semantic cardinality. See reference.md at // https://github.com/google/transit/tree/master/gtfs-realtime for field // semantic cardinality. message FeedMessage { // Metadata about this feed and feed message. required FeedHeader header = 1 ; // Contents of the feed. repeated FeedEntity entity = 2 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // Metadata about a feed, included in feed messages. message FeedHeader { // Version of the feed specification. // The current version is 2.0. Valid versions are \"2.0\", \"1.0\". required string gtfs_realtime_version = 1 ; // Determines whether the current fetch is incremental. Currently, // DIFFERENTIAL mode is unsupported and behavior is unspecified for feeds // that use this mode. There are discussions on the GTFS Realtime mailing // list around fully specifying the behavior of DIFFERENTIAL mode and the // documentation will be updated when those discussions are finalized. enum Incrementality { FULL_DATASET = 0 ; DIFFERENTIAL = 1 ; } optional Incrementality incrementality = 2 [ default = FULL_DATASET ]; // This timestamp identifies the moment when the content of this feed has been // created (in server time). In POSIX time (i.e., number of seconds since // January 1st 1970 00:00:00 UTC). optional uint64 timestamp = 3 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // A definition (or update) of an entity in the transit feed. message FeedEntity { // The ids are used only to provide incrementality support. The id should be // unique within a FeedMessage. Consequent FeedMessages may contain // FeedEntities with the same id. In case of a DIFFERENTIAL update the new // FeedEntity with some id will replace the old FeedEntity with the same id // (or delete it - see is_deleted below). // The actual GTFS entities (e.g. stations, routes, trips) referenced by the // feed must be specified by explicit selectors (see EntitySelector below for // more info). required string id = 1 ; // Whether this entity is to be deleted. Relevant only for incremental // fetches. optional bool is_deleted = 2 [ default = false ]; // Data about the entity itself. Exactly one of the following fields must be // present (unless the entity is being deleted). optional TripUpdate trip_update = 3 ; optional VehiclePosition vehicle = 4 ; optional Alert alert = 5 ; // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional Shape shape = 6 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // // Entities used in the feed. // // Realtime update of the progress of a vehicle along a trip. // Depending on the value of ScheduleRelationship, a TripUpdate can specify: // - A trip that proceeds along the schedule. // - A trip that proceeds along a route but has no fixed schedule. // - A trip that have been added or removed with regard to schedule. // // The updates can be for future, predicted arrival/departure events, or for // past events that already occurred. // Normally, updates should get more precise and more certain (see // uncertainty below) as the events gets closer to current time. // Even if that is not possible, the information for past events should be // precise and certain. In particular, if an update points to time in the past // but its update's uncertainty is not 0, the client should conclude that the // update is a (wrong) prediction and that the trip has not completed yet. // // Note that the update can describe a trip that is already completed. // To this end, it is enough to provide an update for the last stop of the trip. // If the time of that is in the past, the client will conclude from that that // the whole trip is in the past (it is possible, although inconsequential, to // also provide updates for preceding stops). // This option is most relevant for a trip that has completed ahead of schedule, // but according to the schedule, the trip is still proceeding at the current // time. Removing the updates for this trip could make the client assume // that the trip is still proceeding. // Note that the feed provider is allowed, but not required, to purge past // updates - this is one case where this would be practically useful. message TripUpdate { // The Trip that this message applies to. There can be at most one // TripUpdate entity for each actual trip instance. // If there is none, that means there is no prediction information available. // It does *not* mean that the trip is progressing according to schedule. required TripDescriptor trip = 1 ; // Additional information on the vehicle that is serving this trip. optional VehicleDescriptor vehicle = 3 ; // Timing information for a single predicted event (either arrival or // departure). // Timing consists of delay and/or estimated time, and uncertainty. // - delay should be used when the prediction is given relative to some // existing schedule in GTFS. // - time should be given whether there is a predicted schedule or not. If // both time and delay are specified, time will take precedence // (although normally, time, if given for a scheduled trip, should be // equal to scheduled time in GTFS + delay). // // Uncertainty applies equally to both time and delay. // The uncertainty roughly specifies the expected error in true delay (but // note, we don't yet define its precise statistical meaning). It's possible // for the uncertainty to be 0, for example for trains that are driven under // computer timing control. message StopTimeEvent { // Delay (in seconds) can be positive (meaning that the vehicle is late) or // negative (meaning that the vehicle is ahead of schedule). Delay of 0 // means that the vehicle is exactly on time. optional int32 delay = 1 ; // Event as absolute time. // In Unix time (i.e., number of seconds since January 1st 1970 00:00:00 // UTC). optional int64 time = 2 ; // If uncertainty is omitted, it is interpreted as unknown. // If the prediction is unknown or too uncertain, the delay (or time) field // should be empty. In such case, the uncertainty field is ignored. // To specify a completely certain prediction, set its uncertainty to 0. optional int32 uncertainty = 3 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features // and modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // Realtime update for arrival and/or departure events for a given stop on a // trip. Updates can be supplied for both past and future events. // The producer is allowed, although not required, to drop past events. message StopTimeUpdate { // The update is linked to a specific stop either through stop_sequence or // stop_id, so one of the fields below must necessarily be set. // See the documentation in TripDescriptor for more information. // Must be the same as in stop_times.txt in the corresponding GTFS feed. optional uint32 stop_sequence = 1 ; // Must be the same as in stops.txt in the corresponding GTFS feed. optional string stop_id = 4 ; optional StopTimeEvent arrival = 2 ; optional StopTimeEvent departure = 3 ; // Expected occupancy after departure from the given stop. // Should be provided only for future stops. // In order to provide departure_occupancy_status without either arrival or // departure StopTimeEvents, ScheduleRelationship should be set to NO_DATA. optional VehiclePosition.OccupancyStatus departure_occupancy_status = 7 ; // The relation between the StopTimeEvents and the static schedule. enum ScheduleRelationship { // The vehicle is proceeding in accordance with its static schedule of // stops, although not necessarily according to the times of the schedule. // At least one of arrival and departure must be provided. If the schedule // for this stop contains both arrival and departure times then so must // this update. Frequency-based trips (GTFS frequencies.txt with exact_times = 0) // should not have a SCHEDULED value and should use UNSCHEDULED instead. SCHEDULED = 0 ; // The stop is skipped, i.e., the vehicle will not stop at this stop. // Arrival and departure are optional. SKIPPED = 1 ; // No StopTimeEvents are given for this stop. // The main intention for this value is to give time predictions only for // part of a trip, i.e., if the last update for a trip has a NO_DATA // specifier, then StopTimeEvents for the rest of the stops in the trip // are considered to be unspecified as well. // Neither arrival nor departure should be supplied. NO_DATA = 2 ; // The vehicle is operating a trip defined in GTFS frequencies.txt with exact_times = 0. // This value should not be used for trips that are not defined in GTFS frequencies.txt, // or trips in GTFS frequencies.txt with exact_times = 1. Trips containing StopTimeUpdates // with ScheduleRelationship=UNSCHEDULED must also set TripDescriptor.ScheduleRelationship=UNSCHEDULED. // NOTE: This field is still experimental, and subject to change. It may be // formally adopted in the future. UNSCHEDULED = 3 ; } optional ScheduleRelationship schedule_relationship = 5 [ default = SCHEDULED ]; // Provides the updated values for the stop time. // NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future. message StopTimeProperties { // Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt. // The new assigned_stop_id should not result in a significantly different trip experience for the end user than // the stop_id defined in GTFS stop_times.txt. In other words, the end user should not view this new stop_id as an // \"unusual change\" if the new stop was presented within an app without any additional context. // For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the // same station as the stop originally defined in GTFS stop_times.txt. // To assign a stop without providing any real-time arrival or departure predictions, populate this field and set // StopTimeUpdate.schedule_relationship = NO_DATA. // If this field is populated, it is preferred to omit `StopTimeUpdate.stop_id` and use only `StopTimeUpdate.stop_sequence`. If // `StopTimeProperties.assigned_stop_id` and `StopTimeUpdate.stop_id` are populated, `StopTimeUpdate.stop_id` must match `assigned_stop_id`. // Platform assignments should be reflected in other GTFS-realtime fields as well // (e.g., `VehiclePosition.stop_id`). // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional string assigned_stop_id = 1 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features // and modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // Realtime updates for certain properties defined within GTFS stop_times.txt // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional StopTimeProperties stop_time_properties = 6 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features // and modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // Updates to StopTimes for the trip (both future, i.e., predictions, and in // some cases, past ones, i.e., those that already happened). // The updates must be sorted by stop_sequence, and apply for all the // following stops of the trip up to the next specified one. // // Example 1: // For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure // delay of 0 for stop_sequence of the current stop means that the trip is // exactly on time. // // Example 2: // For the same trip instance, 3 StopTimeUpdates are provided: // - delay of 5 min for stop_sequence 3 // - delay of 1 min for stop_sequence 8 // - delay of unspecified duration for stop_sequence 10 // This will be interpreted as: // - stop_sequences 3,4,5,6,7 have delay of 5 min. // - stop_sequences 8,9 have delay of 1 min. // - stop_sequences 10,... have unknown delay. repeated StopTimeUpdate stop_time_update = 2 ; // The most recent moment at which the vehicle's real-time progress was measured // to estimate StopTimes in the future. When StopTimes in the past are provided, // arrival/departure times may be earlier than this value. In POSIX // time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC). optional uint64 timestamp = 4 ; // The current schedule deviation for the trip. Delay should only be // specified when the prediction is given relative to some existing schedule // in GTFS. // // Delay (in seconds) can be positive (meaning that the vehicle is late) or // negative (meaning that the vehicle is ahead of schedule). Delay of 0 // means that the vehicle is exactly on time. // // Delay information in StopTimeUpdates take precedent of trip-level delay // information, such that trip-level delay is only propagated until the next // stop along the trip with a StopTimeUpdate delay value specified. // // Feed providers are strongly encouraged to provide a TripUpdate.timestamp // value indicating when the delay value was last updated, in order to // evaluate the freshness of the data. // // NOTE: This field is still experimental, and subject to change. It may be // formally adopted in the future. optional int32 delay = 5 ; // Defines updated properties of the trip, such as a new shape_id when there is a detour. Or defines the // trip_id, start_date, and start_time of a DUPLICATED trip. // NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future. message TripProperties { // Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt // but will start at a different service date and/or time (defined using the TripProperties.start_date and // TripProperties.start_time fields). See definition of trips.trip_id in (CSV) GTFS. Its value must be different // than the ones used in the (CSV) GTFS. Required if schedule_relationship=DUPLICATED, otherwise this field must not // be populated and will be ignored by consumers. // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional string trip_id = 1 ; // Service date on which the DUPLICATED trip will be run, in YYYYMMDD format. Required if // schedule_relationship=DUPLICATED, otherwise this field must not be populated and will be ignored by consumers. // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional string start_date = 2 ; // Defines the departure start time of the trip when it\u2019s duplicated. See definition of stop_times.departure_time // in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset // between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a // departure_time of 10:00:00 and stop B with departure_time of 10:01:00, and this field is populated with the value // of 10:30:00, stop B on the duplicated trip will have a scheduled departure_time of 10:31:00. Real-time prediction // delay values are applied to this calculated schedule time to determine the predicted time. For example, if a // departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30. Real-time // prediction time values do not have any offset applied to them and indicate the predicted time as provided. // For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time // is 10:31:30. This field is required if schedule_relationship is DUPLICATED, otherwise this field must not be // populated and will be ignored by consumers. // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional string start_time = 3 ; // Specifies the shape of the vehicle travel path when the trip shape differs from the shape specified in // (CSV) GTFS or to specify it in real-time when it's not provided by (CSV) GTFS, such as a vehicle that takes differing // paths based on rider demand. See definition of trips.shape_id in (CSV) GTFS. If a shape is neither defined in (CSV) GTFS // nor in real-time, the shape is considered unknown. This field can refer to a shape defined in the (CSV) GTFS in shapes.txt // or a Shape in the (protobuf) real-time feed. The order of stops (stop sequences) for this trip must remain the same as // (CSV) GTFS. Stops that are a part of the original trip but will no longer be made, such as when a detour occurs, should // be marked as schedule_relationship=SKIPPED. // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional string shape_id = 4 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features // and modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } optional TripProperties trip_properties = 6 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // Realtime positioning information for a given vehicle. message VehiclePosition { // The Trip that this vehicle is serving. // Can be empty or partial if the vehicle can not be identified with a given // trip instance. optional TripDescriptor trip = 1 ; // Additional information on the vehicle that is serving this trip. optional VehicleDescriptor vehicle = 8 ; // Current position of this vehicle. optional Position position = 2 ; // The stop sequence index of the current stop. The meaning of // current_stop_sequence (i.e., the stop that it refers to) is determined by // current_status. // If current_status is missing IN_TRANSIT_TO is assumed. optional uint32 current_stop_sequence = 3 ; // Identifies the current stop. The value must be the same as in stops.txt in // the corresponding GTFS feed. optional string stop_id = 7 ; enum VehicleStopStatus { // The vehicle is just about to arrive at the stop (on a stop // display, the vehicle symbol typically flashes). INCOMING_AT = 0 ; // The vehicle is standing at the stop. STOPPED_AT = 1 ; // The vehicle has departed and is in transit to the next stop. IN_TRANSIT_TO = 2 ; } // The exact status of the vehicle with respect to the current stop. // Ignored if current_stop_sequence is missing. optional VehicleStopStatus current_status = 4 [ default = IN_TRANSIT_TO ]; // Moment at which the vehicle's position was measured. In POSIX time // (i.e., number of seconds since January 1st 1970 00:00:00 UTC). optional uint64 timestamp = 5 ; // Congestion level that is affecting this vehicle. enum CongestionLevel { UNKNOWN_CONGESTION_LEVEL = 0 ; RUNNING_SMOOTHLY = 1 ; STOP_AND_GO = 2 ; CONGESTION = 3 ; SEVERE_CONGESTION = 4 ; // People leaving their cars. } optional CongestionLevel congestion_level = 6 ; // The state of passenger occupancy for the vehicle or carriage. // Individual producers may not publish all OccupancyStatus values. Therefore, consumers // must not assume that the OccupancyStatus values follow a linear scale. // Consumers should represent OccupancyStatus values as the state indicated // and intended by the producer. Likewise, producers must use OccupancyStatus values that // correspond to actual vehicle occupancy states. // For describing passenger occupancy levels on a linear scale, see `occupancy_percentage`. // This field is still experimental, and subject to change. It may be formally adopted in the future. enum OccupancyStatus { // The vehicle or carriage is considered empty by most measures, and has few or no // passengers onboard, but is still accepting passengers. EMPTY = 0 ; // The vehicle or carriage has a large number of seats available. // The amount of free seats out of the total seats available to be // considered large enough to fall into this category is determined at the // discretion of the producer. MANY_SEATS_AVAILABLE = 1 ; // The vehicle or carriage has a relatively small number of seats available. // The amount of free seats out of the total seats available to be // considered small enough to fall into this category is determined at the // discretion of the feed producer. FEW_SEATS_AVAILABLE = 2 ; // The vehicle or carriage can currently accommodate only standing passengers. STANDING_ROOM_ONLY = 3 ; // The vehicle or carriage can currently accommodate only standing passengers // and has limited space for them. CRUSHED_STANDING_ROOM_ONLY = 4 ; // The vehicle or carriage is considered full by most measures, but may still be // allowing passengers to board. FULL = 5 ; // The vehicle or carriage is not accepting passengers, but usually accepts passengers for boarding. NOT_ACCEPTING_PASSENGERS = 6 ; // The vehicle or carriage doesn't have any occupancy data available at that time. NO_DATA_AVAILABLE = 7 ; // The vehicle or carriage is not boardable and never accepts passengers. // Useful for special vehicles or carriages (engine, maintenance carriage, etc\u2026). NOT_BOARDABLE = 8 ; } // If multi_carriage_status is populated with per-carriage OccupancyStatus, // then this field should describe the entire vehicle with all carriages accepting passengers considered. optional OccupancyStatus occupancy_status = 9 ; // A percentage value indicating the degree of passenger occupancy in the vehicle. // The values are represented as an integer without decimals. 0 means 0% and 100 means 100%. // The value 100 should represent the total maximum occupancy the vehicle was designed for, // including both seated and standing capacity, and current operating regulations allow. // The value may exceed 100 if there are more passengers than the maximum designed capacity. // The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle. // If multi_carriage_status is populated with per-carriage occupancy_percentage, // then this field should describe the entire vehicle with all carriages accepting passengers considered. // This field is still experimental, and subject to change. It may be formally adopted in the future. optional uint32 occupancy_percentage = 10 ; // Carriage specific details, used for vehicles composed of several carriages // This message/field is still experimental, and subject to change. It may be formally adopted in the future. message CarriageDetails { // Identification of the carriage. Should be unique per vehicle. optional string id = 1 ; // User visible label that may be shown to the passenger to help identify // the carriage. Example: \"7712\", \"Car ABC-32\", etc... // This message/field is still experimental, and subject to change. It may be formally adopted in the future. optional string label = 2 ; // Occupancy status for this given carriage, in this vehicle // This message/field is still experimental, and subject to change. It may be formally adopted in the future. optional OccupancyStatus occupancy_status = 3 [ default = NO_DATA_AVAILABLE ]; // Occupancy percentage for this given carriage, in this vehicle. // Follows the same rules as \"VehiclePosition.occupancy_percentage\" // -1 in case data is not available for this given carriage (as protobuf defaults to 0 otherwise) // This message/field is still experimental, and subject to change. It may be formally adopted in the future. optional int32 occupancy_percentage = 4 [ default = - 1 ]; // Identifies the order of this carriage with respect to the other // carriages in the vehicle's list of CarriageDetails. // The first carriage in the direction of travel must have a value of 1. // The second value corresponds to the second carriage in the direction // of travel and must have a value of 2, and so forth. // For example, the first carriage in the direction of travel has a value of 1. // If the second carriage in the direction of travel has a value of 3, // consumers will discard data for all carriages (i.e., the multi_carriage_details field). // Carriages without data must be represented with a valid carriage_sequence number and the fields // without data should be omitted (alternately, those fields could also be included and set to the \"no data\" values). // This message/field is still experimental, and subject to change. It may be formally adopted in the future. optional uint32 carriage_sequence = 5 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // Details of the multiple carriages of this given vehicle. // The first occurrence represents the first carriage of the vehicle, // given the current direction of travel. // The number of occurrences of the multi_carriage_details // field represents the number of carriages of the vehicle. // It also includes non boardable carriages, // like engines, maintenance carriages, etc\u2026 as they provide valuable // information to passengers about where to stand on a platform. // This message/field is still experimental, and subject to change. It may be formally adopted in the future. repeated CarriageDetails multi_carriage_details = 11 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // An alert, indicating some sort of incident in the public transit network. message Alert { // Time when the alert should be shown to the user. If missing, the // alert will be shown as long as it appears in the feed. // If multiple ranges are given, the alert will be shown during all of them. repeated TimeRange active_period = 1 ; // Entities whose users we should notify of this alert. repeated EntitySelector informed_entity = 5 ; // Cause of this alert. enum Cause { UNKNOWN_CAUSE = 1 ; OTHER_CAUSE = 2 ; // Not machine-representable. TECHNICAL_PROBLEM = 3 ; STRIKE = 4 ; // Public transit agency employees stopped working. DEMONSTRATION = 5 ; // People are blocking the streets. ACCIDENT = 6 ; HOLIDAY = 7 ; WEATHER = 8 ; MAINTENANCE = 9 ; CONSTRUCTION = 10 ; POLICE_ACTIVITY = 11 ; MEDICAL_EMERGENCY = 12 ; } optional Cause cause = 6 [ default = UNKNOWN_CAUSE ]; // What is the effect of this problem on the affected entity. enum Effect { NO_SERVICE = 1 ; REDUCED_SERVICE = 2 ; // We don't care about INsignificant delays: they are hard to detect, have // little impact on the user, and would clutter the results as they are too // frequent. SIGNIFICANT_DELAYS = 3 ; DETOUR = 4 ; ADDITIONAL_SERVICE = 5 ; MODIFIED_SERVICE = 6 ; OTHER_EFFECT = 7 ; UNKNOWN_EFFECT = 8 ; STOP_MOVED = 9 ; NO_EFFECT = 10 ; ACCESSIBILITY_ISSUE = 11 ; } optional Effect effect = 7 [ default = UNKNOWN_EFFECT ]; // The URL which provides additional information about the alert. optional TranslatedString url = 8 ; // Alert header. Contains a short summary of the alert text as plain-text. optional TranslatedString header_text = 10 ; // Full description for the alert as plain-text. The information in the // description should add to the information of the header. optional TranslatedString description_text = 11 ; // Text for alert header to be used in text-to-speech implementations. This field is the text-to-speech version of header_text. optional TranslatedString tts_header_text = 12 ; // Text for full description for the alert to be used in text-to-speech implementations. This field is the text-to-speech version of description_text. optional TranslatedString tts_description_text = 13 ; // Severity of this alert. enum SeverityLevel { UNKNOWN_SEVERITY = 1 ; INFO = 2 ; WARNING = 3 ; SEVERE = 4 ; } optional SeverityLevel severity_level = 14 [ default = UNKNOWN_SEVERITY ]; // TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image must enhance the understanding of the alert. Any essential information communicated within the image must also be contained in the alert text. // The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional TranslatedImage image = 15 ; // Text describing the appearance of the linked image in the `image` field (e.g., in case the image can't be displayed // or the user can't see the image for accessibility reasons). See the HTML spec for alt image text - https://html.spec.whatwg.org/#alt. // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional TranslatedString image_alternative_text = 16 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features // and modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // // Low level data structures used above. // // A time interval. The interval is considered active at time 't' if 't' is // greater than or equal to the start time and less than the end time. message TimeRange { // Start time, in POSIX time (i.e., number of seconds since January 1st 1970 // 00:00:00 UTC). // If missing, the interval starts at minus infinity. optional uint64 start = 1 ; // End time, in POSIX time (i.e., number of seconds since January 1st 1970 // 00:00:00 UTC). // If missing, the interval ends at plus infinity. optional uint64 end = 2 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // A position. message Position { // Degrees North, in the WGS-84 coordinate system. required float latitude = 1 ; // Degrees East, in the WGS-84 coordinate system. required float longitude = 2 ; // Bearing, in degrees, clockwise from North, i.e., 0 is North and 90 is East. // This can be the compass bearing, or the direction towards the next stop // or intermediate location. // This should not be direction deduced from the sequence of previous // positions, which can be computed from previous data. optional float bearing = 3 ; // Odometer value, in meters. optional double odometer = 4 ; // Momentary speed measured by the vehicle, in meters per second. optional float speed = 5 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // A descriptor that identifies an instance of a GTFS trip, or all instances of // a trip along a route. // - To specify a single trip instance, the trip_id (and if necessary, // start_time) is set. If route_id is also set, then it should be same as one // that the given trip corresponds to. // - To specify all the trips along a given route, only the route_id should be // set. Note that if the trip_id is not known, then stop sequence ids in // TripUpdate are not sufficient, and stop_ids must be provided as well. In // addition, absolute arrival/departure times must be provided. message TripDescriptor { // The trip_id from the GTFS feed that this selector refers to. // For non frequency-based trips, this field is enough to uniquely identify // the trip. For frequency-based trip, start_time and start_date might also be // necessary. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from // static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id // identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id. optional string trip_id = 1 ; // The route_id from the GTFS that this selector refers to. optional string route_id = 5 ; // The direction_id from the GTFS feed trips.txt file, indicating the // direction of travel for trips this selector refers to. optional uint32 direction_id = 6 ; // The initially scheduled start time of this trip instance. // When the trip_id corresponds to a non-frequency-based trip, this field // should either be omitted or be equal to the value in the GTFS feed. When // the trip_id correponds to a frequency-based trip, the start_time must be // specified for trip updates and vehicle positions. If the trip corresponds // to exact_times=1 GTFS record, then start_time must be some multiple // (including zero) of headway_secs later than frequencies.txt start_time for // the corresponding time period. If the trip corresponds to exact_times=0, // then its start_time may be arbitrary, and is initially expected to be the // first departure of the trip. Once established, the start_time of this // frequency-based trip should be considered immutable, even if the first // departure time changes -- that time change may instead be reflected in a // StopTimeUpdate. // Format and semantics of the field is same as that of // GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35. optional string start_time = 2 ; // The scheduled start date of this trip instance. // Must be provided to disambiguate trips that are so late as to collide with // a scheduled trip on a next day. For example, for a train that departs 8:00 // and 20:00 every day, and is 12 hours late, there would be two distinct // trips on the same time. // This field can be provided but is not mandatory for schedules in which such // collisions are impossible - for example, a service running on hourly // schedule where a vehicle that is one hour late is not considered to be // related to schedule anymore. // In YYYYMMDD format. optional string start_date = 3 ; // The relation between this trip and the static schedule. If a trip is done // in accordance with temporary schedule, not reflected in GTFS, then it // shouldn't be marked as SCHEDULED, but likely as ADDED. enum ScheduleRelationship { // Trip that is running in accordance with its GTFS schedule, or is close // enough to the scheduled trip to be associated with it. SCHEDULED = 0 ; // An extra trip that was added in addition to a running schedule, for // example, to replace a broken vehicle or to respond to sudden passenger // load. // NOTE: Currently, behavior is unspecified for feeds that use this mode. There are discussions on the GTFS GitHub // [(1)](https://github.com/google/transit/issues/106) [(2)](https://github.com/google/transit/pull/221) // [(3)](https://github.com/google/transit/pull/219) around fully specifying or deprecating ADDED trips and the // documentation will be updated when those discussions are finalized. ADDED = 1 ; // A trip that is running with no schedule associated to it (GTFS frequencies.txt exact_times=0). // Trips with ScheduleRelationship=UNSCHEDULED must also set all StopTimeUpdates.ScheduleRelationship=UNSCHEDULED. UNSCHEDULED = 2 ; // A trip that existed in the schedule but was removed. CANCELED = 3 ; // Should not be used - for backwards-compatibility only. REPLACEMENT = 5 [ deprecated = true ]; // An extra trip that was added in addition to a running schedule, for example, to replace a broken vehicle or to // respond to sudden passenger load. Used with TripUpdate.TripProperties.trip_id, TripUpdate.TripProperties.start_date, // and TripUpdate.TripProperties.start_time to copy an existing trip from static GTFS but start at a different service // date and/or time. Duplicating a trip is allowed if the service related to the original trip in (CSV) GTFS // (in calendar.txt or calendar_dates.txt) is operating within the next 30 days. The trip to be duplicated is // identified via TripUpdate.TripDescriptor.trip_id. This enumeration does not modify the existing trip referenced by // TripUpdate.TripDescriptor.trip_id - if a producer wants to cancel the original trip, it must publish a separate // TripUpdate with the value of CANCELED. Trips defined in GTFS frequencies.txt with exact_times that is empty or // equal to 0 cannot be duplicated. The VehiclePosition.TripDescriptor.trip_id for the new trip must contain // the matching value from TripUpdate.TripProperties.trip_id and VehiclePosition.TripDescriptor.ScheduleRelationship // must also be set to DUPLICATED. // Existing producers and consumers that were using the ADDED enumeration to represent duplicated trips must follow // the migration guide (https://github.com/google/transit/tree/master/gtfs-realtime/spec/en/examples/migration-duplicated.md) // to transition to the DUPLICATED enumeration. // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. DUPLICATED = 6 ; } optional ScheduleRelationship schedule_relationship = 4 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // Identification information for the vehicle performing the trip. message VehicleDescriptor { // Internal system identification of the vehicle. Should be unique per // vehicle, and can be used for tracking the vehicle as it proceeds through // the system. optional string id = 1 ; // User visible label, i.e., something that must be shown to the passenger to // help identify the correct vehicle. optional string label = 2 ; // The license plate of the vehicle. optional string license_plate = 3 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // A selector for an entity in a GTFS feed. message EntitySelector { // The values of the fields should correspond to the appropriate fields in the // GTFS feed. // At least one specifier must be given. If several are given, then the // matching has to apply to all the given specifiers. optional string agency_id = 1 ; optional string route_id = 2 ; // corresponds to route_type in GTFS. optional int32 route_type = 3 ; optional TripDescriptor trip = 4 ; optional string stop_id = 5 ; // Corresponds to trip direction_id in GTFS trips.txt. If provided the // route_id must also be provided. optional uint32 direction_id = 6 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // An internationalized message containing per-language versions of a snippet of // text or a URL. // One of the strings from a message will be picked up. The resolution proceeds // as follows: // 1. If the UI language matches the language code of a translation, // the first matching translation is picked. // 2. If a default UI language (e.g., English) matches the language code of a // translation, the first matching translation is picked. // 3. If some translation has an unspecified language code, that translation is // picked. message TranslatedString { message Translation { // A UTF-8 string containing the message. required string text = 1 ; // BCP-47 language code. Can be omitted if the language is unknown or if // no i18n is done at all for the feed. At most one translation is // allowed to have an unspecified language tag. optional string language = 2 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // At least one translation must be provided. repeated Translation translation = 1 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // An internationalized image containing per-language versions of a URL linking to an image // along with meta information // Only one of the images from a message will be retained by consumers. The resolution proceeds // as follows: // 1. If the UI language matches the language code of a translation, // the first matching translation is picked. // 2. If a default UI language (e.g., English) matches the language code of a // translation, the first matching translation is picked. // 3. If some translation has an unspecified language code, that translation is // picked. // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. message TranslatedImage { message LocalizedImage { // String containing an URL linking to an image // The image linked must be less than 2MB. // If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one. // The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following https://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values. required string url = 1 ; // IANA media type as to specify the type of image to be displayed. // The type must start with \"image/\" required string media_type = 2 ; // BCP-47 language code. Can be omitted if the language is unknown or if // no i18n is done at all for the feed. At most one translation is // allowed to have an unspecified language tag. optional string language = 3 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // At least one localized image must be provided. repeated LocalizedImage localized_image = 1 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; } // Describes the physical path that a vehicle takes when it's not part of the (CSV) GTFS, // such as for a detour. Shapes belong to Trips, and consist of a sequence of shape points. // Tracing the points in order provides the path of the vehicle. Shapes do not need to intercept // the location of Stops exactly, but all Stops on a trip should lie within a small distance of // the shape for that trip, i.e. close to straight line segments connecting the shape points // NOTE: This message is still experimental, and subject to change. It may be formally adopted in the future. message Shape { // Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS. // This field is required as per reference.md, but needs to be specified here optional because \"Required is Forever\" // See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional string shape_id = 1 ; // Encoded polyline representation of the shape. This polyline must contain at least two points. // For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm // This field is required as per reference.md, but needs to be specified here optional because \"Required is Forever\" // See https://developers.google.com/protocol-buffers/docs/proto#specifying_field_rules // NOTE: This field is still experimental, and subject to change. It may be formally adopted in the future. optional string encoded_polyline = 2 ; // The extensions namespace allows 3rd-party developers to extend the // GTFS Realtime Specification in order to add and evaluate new features and // modifications to the spec. extensions 1000 to 1999 ; // The following extension IDs are reserved for private use by any organization. extensions 9000 to 9999 ; }","title":"GTFS Realtime Protobuf"},{"location":"realtime/reference/","text":"GTFS Realtime Reference \u00b6 A GTFS Realtime feed lets transit agencies provide consumers with realtime information about disruptions to their service (stations closed, lines not operating, important delays, etc.) location of their vehicles, and expected arrival times. Version 2.0 of the feed specification is discussed and documented on this site. Valid versions are \"2.0\", \"1.0\". Term Definitions \u00b6 Required \u00b6 In GTFS-realtime v2.0 and higher, the Required column describes what fields must be provided by a producer in order for the transit data to be valid and make sense to a consuming application. The following values are used in the Required field: Required : This field must be provided by a GTFS-realtime feed producer. Conditionally required : This field is required under certain conditions, which are outlined in the field Description . Outside of these conditions, the field is optional. Optional : This field is optional and is not required to be implemented by producers. However, if the data is available in the underlying automatic vehicle location systems (e.g., VehiclePosition timestamp ) it is recommended that producers provide these optional fields when possible. Note that semantic requirements were not defined in GTFS-realtime version 1.0, and therefore feeds with gtfs_realtime_version of 1 may not meet these requirements (see the proposal for semantic requirements for details). Cardinality \u00b6 Cardinality represents the number of elements that may be provided for a particular field, with the following values: One - A single one element may be provided for this field. This maps to the Protocol Buffer required and optional cardinalities . Many - Many elements (0, 1, or more) may be provided for this field. This maps to the Protocol Buffer repeated cardinality . Always reference the Required and Description fields to see when a field is required, conditionally required, or optional. Please reference gtfs-realtime.proto for Protocol Buffer cardinality. Protocol Buffer data types \u00b6 The following protocol buffer data types are used to describe feed elements: message : Complex type enum : List of fixed values Experimental fields \u00b6 Fields labeled as experimental are subject to change and not yet formally adopted into the specification. An experimental field may be formally adopted in the future. Element Index \u00b6 FeedMessage FeedHeader Incrementality FeedEntity TripUpdate TripDescriptor ScheduleRelationship VehicleDescriptor StopTimeUpdate StopTimeEvent ScheduleRelationship StopTimeProperties TripProperties VehiclePosition TripDescriptor ScheduleRelationship VehicleDescriptor Position VehicleStopStatus CongestionLevel OccupancyStatus CarriageDetails Alert TimeRange EntitySelector TripDescriptor ScheduleRelationship Cause Effect TranslatedString Translation SeverityLevel Elements \u00b6 message FeedMessage \u00b6 The contents of a feed message. Each message in the stream is obtained as a response to an appropriate HTTP GET request. A realtime feed is always defined with relation to an existing GTFS feed. All the entity ids are resolved with respect to the GTFS feed. Fields Field Name Type Required Cardinality Description header FeedHeader Required One Metadata about this feed and feed message. entity FeedEntity Conditionally required Many Contents of the feed. If there is real-time information available for the transit system, this field must be provided. If this field is empty, consumers should assume there is no real-time information available for the system. message FeedHeader \u00b6 Metadata about a feed, included in feed messages. Fields Field Name Type Required Cardinality Description gtfs_realtime_version string Required One Version of the feed specification. The current version is 2.0. incrementality Incrementality Required One timestamp uint64 Required One This timestamp identifies the moment when the content of this feed has been created (in server time). In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC). To avoid time skew between systems producing and consuming realtime information it is strongly advised to derive timestamp from a time server. It is completely acceptable to use Stratum 3 or even lower strata servers since time differences up to a couple of seconds are tolerable. enum Incrementality \u00b6 Determines whether the current fetch is incremental. FULL_DATASET : this feed update will overwrite all preceding realtime information for the feed. Thus this update is expected to provide a full snapshot of all known realtime information. DIFFERENTIAL : currently, this mode is unsupported and behavior is unspecified for feeds that use this mode. There are discussions on the GTFS Realtime mailing list around fully specifying the behavior of DIFFERENTIAL mode and the documentation will be updated when those discussions are finalized. Values Value FULL_DATASET DIFFERENTIAL message FeedEntity \u00b6 A definition (or update) of an entity in the transit feed. If the entity is not being deleted, exactly one of 'trip_update', 'vehicle', 'alert' and 'shape' fields should be populated. Fields Field Name Type Required Cardinality Description id string Required One Feed-unique identifier for this entity. The ids are used only to provide incrementality support. The actual entities referenced by the feed must be specified by explicit selectors (see EntitySelector below for more info). is_deleted bool Optional One Whether this entity is to be deleted. Should be provided only for feeds with Incrementality of DIFFERENTIAL - this field should NOT be provided for feeds with Incrementality of FULL_DATASET. trip_update TripUpdate Conditionally required One Data about the realtime departure delays of a trip. At least one of the fields trip_update, vehicle, alert, or shape must be provided - all these fields cannot be empty. vehicle VehiclePosition Conditionally required One Data about the realtime position of a vehicle. At least one of the fields trip_update, vehicle, alert, or shape must be provided - all these fields cannot be empty. alert Alert Conditionally required One Data about the realtime alert. At least one of the fields trip_update, vehicle, alert, or shape must be provided - all these fields cannot be empty. shape Shape Conditionally required One Data about the realtime added shapes, such as for a detour. At least one of the fields trip_update, vehicle, alert, or shape must be provided - all these fields cannot be empty. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. message TripUpdate \u00b6 Realtime update on the progress of a vehicle along a trip. Please also refer to the general discussion of the trip updates entities . Depending on the value of ScheduleRelationship, a TripUpdate can specify: A trip that proceeds along the schedule. A trip that proceeds along a route but has no fixed schedule. A trip that has been added or removed with regard to schedule. A new trip that is a copy of an existing trip in static GTFS. It will run at the service date and time specified in TripProperties. The updates can be for future, predicted arrival/departure events, or for past events that already occurred. In most cases information about past events is a measured value thus its uncertainty value is recommended to be 0. Although there could be cases when this does not hold so it is allowed to have uncertainty value different from 0 for past events. If an update's uncertainty is not 0, either the update is an approximate prediction for a trip that has not completed or the measurement is not precise or the update was a prediction for the past that has not been verified after the event occurred. If a vehicle is serving multiple trips within the same block (for more information about trips and blocks, please refer to GTFS trips.txt ): * the feed should include a TripUpdate for the trip currently being served by the vehicle. Producers are encouraged to include TripUpdates for one or more trips after the current trip in this vehicle's block if the producer is confident in the quality of the predictions for these future trip(s). Including multiple TripUpdates for the same vehicle avoids prediction \"pop-in\" for riders as the vehicle transitions from one trip to another and also gives riders advance notice of delays that impact downstream trips (e.g., when the known delay exceeds planned layover times between trips). * the respective TripUpdate entities are not required to be added to the feed in the same order that they are scheduled in the block. For example, if there are trips with trip_ids 1, 2, and 3 that all belong to one block, and the vehicle travels trip 1, then trip 2, and then trip 3, the trip_update entities may appear in any order - for example, adding trip 2, then trip 1, and then trip 3 is allowed. Note that the update can describe a trip that has already completed.To this end, it is enough to provide an update for the last stop of the trip. If the time of arrival at the last stop is in the past, the client will conclude that the whole trip is in the past (it is possible, although inconsequential, to also provide updates for preceding stops). This option is most relevant for a trip that has completed ahead of schedule, but according to the schedule, the trip is still proceeding at the current time. Removing the updates for this trip could make the client assume that the trip is still proceeding. Note that the feed provider is allowed, but not required, to purge past updates - this is one case where this would be practically useful. Fields Field Name Type Required Cardinality Description trip TripDescriptor Required One The Trip that this message applies to. There can be at most one TripUpdate entity for each actual trip instance. If there is none, that means there is no prediction information available. It does not mean that the trip is progressing according to schedule. vehicle VehicleDescriptor Optional One Additional information on the vehicle that is serving this trip. stop_time_update StopTimeUpdate Conditionally required Many Updates to StopTimes for the trip (both future, i.e., predictions, and in some cases, past ones, i.e., those that already happened). The updates must be sorted by stop_sequence, and apply for all the following stops of the trip up to the next specified stop_time_update. At least one stop_time_update must be provided for the trip unless the trip.schedule_relationship is CANCELED or DUPLICATED - if the trip is canceled, no stop_time_updates need to be provided. If the trip is duplicated, stop_time_updates may be provided to indicate real-time information for the new trip. timestamp uint64 Optional One The most recent moment at which the vehicle's real-time progress was measured to estimate StopTimes in the future. When StopTimes in the past are provided, arrival/departure times may be earlier than this value. In POSIX time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC). delay int32 Optional One The current schedule deviation for the trip. Delay should only be specified when the prediction is given relative to some existing schedule in GTFS. Delay (in seconds) can be positive (meaning that the vehicle is late) or negative (meaning that the vehicle is ahead of schedule). Delay of 0 means that the vehicle is exactly on time. Delay information in StopTimeUpdates take precedent of trip-level delay information, such that trip-level delay is only propagated until the next stop along the trip with a StopTimeUpdate delay value specified. Feed providers are strongly encouraged to provide a TripUpdate.timestamp value indicating when the delay value was last updated, in order to evaluate the freshness of the data. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. trip_properties TripProperties Optional One Provides the updated properties for the trip. Caution: this message is still experimental , and subject to change. It may be formally adopted in the future. message StopTimeEvent \u00b6 Timing information for a single predicted event (either arrival or departure). Timing consists of delay and/or estimated time, and uncertainty. delay should be used when the prediction is given relative to some existing schedule in GTFS. time should be given whether there is a predicted schedule or not. If both time and delay are specified, time will take precedence (although normally, time, if given for a scheduled trip, should be equal to scheduled time in GTFS + delay). Uncertainty applies equally to both time and delay. The uncertainty roughly specifies the expected error in true delay (but note, we don't yet define its precise statistical meaning). It's possible for the uncertainty to be 0, for example for trains that are driven under computer timing control. Fields Field Name Type Required Cardinality Description delay int32 Conditionally required One Delay (in seconds) can be positive (meaning that the vehicle is late) or negative (meaning that the vehicle is ahead of schedule). Delay of 0 means that the vehicle is exactly on time. Either delay or time must be provided within a StopTimeEvent - both fields cannot be empty. time int64 Conditionally required One Event as absolute time. In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC). Either delay or time must be provided within a StopTimeEvent - both fields cannot be empty. uncertainty int32 Optional One If uncertainty is omitted, it is interpreted as unknown. To specify a completely certain prediction, set its uncertainty to 0. message StopTimeUpdate \u00b6 Realtime update for arrival and/or departure events for a given stop on a trip. Please also refer to the general discussion of stop time updates in the TripDescriptor and trip updates entities documentation. Updates can be supplied for both past and future events. The producer is allowed, although not required, to drop past events. The update is linked to a specific stop either through stop_sequence or stop_id, so one of these fields must necessarily be set. If the same stop_id is visited more than once in a trip, then stop_sequence should be provided in all StopTimeUpdates for that stop_id on that trip. Fields Field Name Type Required Cardinality Description stop_sequence uint32 Conditionally required One Must be the same as in stop_times.txt in the corresponding GTFS feed. Either stop_sequence or stop_id must be provided within a StopTimeUpdate - both fields cannot be empty. stop_sequence is required for trips that visit the same stop_id more than once (e.g., a loop) to disambiguate which stop the prediction is for. If StopTimeProperties.assigned_stop_id is populated, then stop_sequence must be populated. stop_id string Conditionally required One Must be the same as in stops.txt in the corresponding GTFS feed. Either stop_sequence or stop_id must be provided within a StopTimeUpdate - both fields cannot be empty. If StopTimeProperties.assigned_stop_id is populated, it is preferred to omit stop_id and use only stop_sequence . If StopTimeProperties.assigned_stop_id and stop_id are populated, stop_id must match assigned_stop_id . arrival StopTimeEvent Conditionally required One If schedule_relationship is empty or SCHEDULED, either arrival or departure must be provided within a StopTimeUpdate - both fields cannot be empty. arrival and departure may both be empty when schedule_relationship is SKIPPED. If schedule_relationship is NO_DATA, arrival and departure must be empty. departure StopTimeEvent Conditionally required One If schedule_relationship is empty or SCHEDULED, either arrival or departure must be provided within a StopTimeUpdate - both fields cannot be empty. arrival and departure may both be empty when schedule_relationship is SKIPPED. If schedule_relationship is NO_DATA, arrival and departure must be empty. departure_occupancy_status OccupancyStatus Optional One The predicted state of passenger occupancy for the vehicle immediately after departure from the given stop. If provided, stop_sequence must be provided. To provide departure_occupancy_status without providing any real-time arrival or departure predictions, populate this field and set StopTimeUpdate.schedule_relationship = NO_DATA. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. schedule_relationship ScheduleRelationship Optional One The default relationship is SCHEDULED. stop_time_properties StopTimeProperties Optional One Realtime updates for certain properties defined within GTFS stop_times.txt Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. enum ScheduleRelationship \u00b6 The relation between this StopTime and the static schedule. Values Value Comment SCHEDULED The vehicle is proceeding in accordance with its static schedule of stops, although not necessarily according to the times of the schedule. This is the default behavior. At least one of arrival and departure must be provided. Frequency-based trips (GTFS frequencies.txt with exact_times = 0) should not have a SCHEDULED value and should use UNSCHEDULED instead. SKIPPED The stop is skipped, i.e., the vehicle will not stop at this stop. Arrival and departure are optional. When set SKIPPED is not propagated to subsequent stops in the same trip (i.e., the vehicle will stop at subsequent stops in the trip unless those stops also have a stop_time_update with schedule_relationship: SKIPPED ). Delay from a previous stop in the trip does propagate over the SKIPPED stop. In other words, if a stop_time_update with an arrival or departure prediction is not set for a stop after the SKIPPED stop, the prediction upstream of the SKIPPED stop will be propagated to the stop after the SKIPPED stop and subsequent stops in the trip until a stop_time_update for a subsequent stop is provided. NO_DATA No data is given for this stop. It indicates that there is no realtime timing information available. When set NO_DATA is propagated through subsequent stops so this is the recommended way of specifying from which stop you do not have realtime timing information. When NO_DATA is set neither arrival nor departure should be supplied. UNSCHEDULED The vehicle is operating a frequency-based trip (GTFS frequencies.txt with exact_times = 0). This value should not be used for trips that are not defined in GTFS frequencies.txt, or trips in GTFS frequencies.txt with exact_times = 1. Trips containing stop_time_updates with schedule_relationship: UNSCHEDULED must also set the TripDescriptor schedule_relationship: UNSCHEDULED Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. message StopTimeProperties \u00b6 Realtime update for certain properties defined within GTFS stop_times.txt. Caution: this message is still experimental , and subject to change. It may be formally adopted in the future. Fields Field Name Type Required Cardinality Description assigned_stop_id string Optional One Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt . The new assigned_stop_id should not result in a significantly different trip experience for the end user than the stop_id defined in GTFS stop_times.txt . In other words, the end user should not view this new stop_id as an \"unusual change\" if the new stop was presented within an app without any additional context. For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the same station as the stop originally defined in GTFS stop_times.txt . To assign a stop without providing any real-time arrival or departure predictions, populate this field and set StopTimeUpdate.schedule_relationship = NO_DATA . If this field is populated, StopTimeUpdate.stop_sequence must be populated and StopTimeUpdate.stop_id should not be populated. Stop assignments should be reflected in other GTFS-realtime fields as well (e.g., VehiclePosition.stop_id ). Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. message TripProperties \u00b6 Defines updated properties of the trip Caution: this message is still experimental , and subject to change. It may be formally adopted in the future. . Fields Field Name Type Required Cardinality Description trip_id string Conditionally required One Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt but will start at a different service date and/or time (defined using TripProperties.start_date and TripProperties.start_time ). See definition of trips.trip_id in (CSV) GTFS. Its value must be different than the ones used in the (CSV) GTFS. This field is required if schedule_relationship is DUPLICATED , otherwise this field must not be populated and will be ignored by consumers. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. start_date string Conditionally required One Service date on which the duplicated trip will be run. Must be provided in YYYYMMDD format. This field is required if schedule_relationship is DUPLICATED , otherwise this field must not be populated and will be ignored by consumers. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. start_time string Conditionally required One Defines the departure start time of the trip when it\u2019s duplicated. See definition of stop_times.departure_time in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a departure_time of 10:00:00 and stop B with departure_time of 10:01:00 , and this field is populated with the value of 10:30:00 , stop B on the duplicated trip will have a scheduled departure_time of 10:31:00 . Real-time prediction delay values are applied to this calculated schedule time to determine the predicted time. For example, if a departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30 . Real-time prediction time values do not have any offset applied to them and indicate the predicted time as provided. For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time is 10:31:30 .This field is required if schedule_relationship is DUPLICATED , otherwise this field must not be populated and will be ignored by consumers. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. shape_id string Optional One Specifies the shape of the vehicle travel path for this trip when it differs from the original. Refers to a shape defined in the (CSV) GTFS or a new shape entity in a real-time feed. See definition of trips.shape_id in (CSV) GTFS. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. message VehiclePosition \u00b6 Realtime positioning information for a given vehicle. Fields Field Name Type Required Cardinality Description trip TripDescriptor Optional One The Trip that this vehicle is serving. Can be empty or partial if the vehicle can not be identified with a given trip instance. vehicle VehicleDescriptor Optional One Additional information on the vehicle that is serving this trip. Each entry should have a unique vehicle id. position Position Optional One Current position of this vehicle. current_stop_sequence uint32 Optional One The stop sequence index of the current stop. The meaning of current_stop_sequence (i.e., the stop that it refers to) is determined by current_status. If current_status is missing IN_TRANSIT_TO is assumed. stop_id string Optional One Identifies the current stop. The value must be the same as in stops.txt in the corresponding GTFS feed. If StopTimeProperties.assigned_stop_id is used to assign a stop_id , this field should also reflect the change in stop_id . current_status VehicleStopStatus Optional One The exact status of the vehicle with respect to the current stop. Ignored if current_stop_sequence is missing. timestamp uint64 Optional One Moment at which the vehicle's position was measured. In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC). congestion_level CongestionLevel Optional One occupancy_status OccupancyStatus Optional One The state of passenger occupancy for the vehicle or carriage. If multi_carriage_details is populated with per-carriage OccupancyStatus, then this field should describe the entire vehicle with all carriages accepting passengers considered. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. occupancy_percentage uint32 Optional One A percentage value indicating the degree of passenger occupancy in the vehicle. The value 100 should represent the total maximum occupancy the vehicle was designed for, including both seating and standing capacity, and current operating regulations allow. The value may exceed 100 if there are more passengers than the maximum designed capacity. The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle. If multi_carriage_details is populated with per-carriage occupancy_percentage, then this field should describe the entire vehicle with all carriages accepting passengers considered. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. multi_carriage_details CarriageDetails Optional Many Details of the multiple carriages of this given vehicle. The first occurrence represents the first carriage of the vehicle, given the current direction of travel . The number of occurrences of the multi_carriage_details field represents the number of carriages of the vehicle. It also includes non boardable carriages, like engines, maintenance carriages, etc\u2026 as they provide valuable information to passengers about where to stand on a platform. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. enum VehicleStopStatus \u00b6 Values Value Comment INCOMING_AT The vehicle is just about to arrive at the stop (on a stop display, the vehicle symbol typically flashes). STOPPED_AT The vehicle is standing at the stop. IN_TRANSIT_TO The vehicle has departed the previous stop and is in transit. enum CongestionLevel \u00b6 Congestion level that is affecting this vehicle. Values Value UNKNOWN_CONGESTION_LEVEL RUNNING_SMOOTHLY STOP_AND_GO CONGESTION SEVERE_CONGESTION enum OccupancyStatus \u00b6 The state of passenger occupancy for the vehicle or carriage. Individual producers may not publish all OccupancyStatus values. Therefore, consumers must not assume that the OccupancyStatus values follow a linear scale. Consumers should represent OccupancyStatus values as the state indicated and intended by the producer. Likewise, producers must use OccupancyStatus values that correspond to actual vehicle occupancy states. For describing passenger occupancy levels on a linear scale, see occupancy_percentage . Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. Values Value Comment EMPTY The vehicle is considered empty by most measures, and has few or no passengers onboard, but is still accepting passengers. MANY_SEATS_AVAILABLE The vehicle or carriage has a large number of seats available. The amount of free seats out of the total seats available to be considered large enough to fall into this category is determined at the discretion of the producer. FEW_SEATS_AVAILABLE The vehicle or carriage has a small number of seats available. The amount of free seats out of the total seats available to be considered small enough to fall into this category is determined at the discretion of the producer. STANDING_ROOM_ONLY The vehicle or carriage can currently accommodate only standing passengers. CRUSHED_STANDING_ROOM_ONLY The vehicle or carriage can currently accommodate only standing passengers and has limited space for them. FULL The vehicle is considered full by most measures, but may still be allowing passengers to board. NOT_ACCEPTING_PASSENGERS The vehicle or carriage is not accepting passengers. The vehicle or carriage usually accepts passengers for boarding. NO_DATA_AVAILABLE The vehicle or carriage doesn't have any occupancy data available at that time. NOT_BOARDABLE The vehicle or carriage is not boardable and never accepts passengers. Useful for special vehicles or carriages (engine, maintenance carriage, etc\u2026). message CarriageDetails \u00b6 Carriage specific details, used for vehicles composed of several carriages. Caution: this message is still experimental , and subject to change. It may be formally adopted in the future. Fields Field Name Type Required Cardinality Description id string Optional One Identification of the carriage. Should be unique per vehicle. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. label string Optional One User visible label that may be shown to the passenger to help identify the carriage. Example: \"7712\", \"Car ABC-32\", etc... Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. occupancy_status OccupancyStatus Optional One Occupancy status for this given carriage, in this vehicle. Default is set to NO_DATA_AVAILABLE . Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. occupancy_percentage int32 Optional One Occupancy percentage for this given carriage, in this vehicle. Follows the same rules as \"VehiclePosition.occupancy_percentage\". Use -1 in case data is not available for this given carriage. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. carriage_sequence uint32 Required One Identifies the order of this carriage with respect to the other carriages in the vehicle's list of CarriageStatus. The first carriage in the direction of travel must have a value of 1. The second value corresponds to the second carriage in the direction of travel and must have a value of 2, and so forth. For example, the first carriage in the direction of travel has a value of 1. If the second carriage in the direction of travel has a value of 3, consumers will discard data for all carriages (i.e., the multi_carriage_details field). Carriages without data must be represented with a valid carriage_sequence number and the fields without data should be omitted (alternately, those fields could also be included and set to the \"no data\" values). Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. message Alert \u00b6 An alert, indicating some sort of incident in the public transit network. Fields Field Name Type Required Cardinality Description active_period TimeRange Optional Many Time when the alert should be shown to the user. If missing, the alert will be shown as long as it appears in the feed. If multiple ranges are given, the alert will be shown during all of them. informed_entity EntitySelector Required Many Entities whose users we should notify of this alert. At least one informed_entity must be provided. cause Cause Optional One effect Effect Optional One url TranslatedString Optional One The URL which provides additional information about the alert. header_text TranslatedString Required One Header for the alert. This plain-text string will be highlighted, for example in boldface. description_text TranslatedString Required One Description for the alert. This plain-text string will be formatted as the body of the alert (or shown on an explicit \"expand\" request by the user). The information in the description should add to the information of the header. tts_header_text TranslatedString Optional One Text containing the alert's header to be used for text-to-speech implementations. This field is the text-to-speech version of header_text. It should contain the same information as header_text but formatted such that it can read as text-to-speech (for example, abbreviations removed, numbers spelled out, etc.) tts_description_text TranslatedString Optional One Text containing a description for the alert to be used for text-to-speech implementations. This field is the text-to-speech version of description_text. It should contain the same information as description_text but formatted such that it can be read as text-to-speech (for example, abbreviations removed, numbers spelled out, etc.) severity_level SeverityLevel Optional One Severity of the alert. image TranslatedImage Optional One TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image should enhance the understanding of the alert and must not be the only location of essential information. The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. image_alternative_text TranslatedString Optional One Text describing the appearance of the linked image in the image field (e.g., in case the image can't be displayed or the user can't see the image for accessibility reasons). See the HTML spec for alt image text . Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. enum Cause \u00b6 Cause of this alert. Values Value UNKNOWN_CAUSE OTHER_CAUSE TECHNICAL_PROBLEM STRIKE DEMONSTRATION ACCIDENT HOLIDAY WEATHER MAINTENANCE CONSTRUCTION POLICE_ACTIVITY MEDICAL_EMERGENCY enum Effect \u00b6 The effect of this problem on the affected entity. Values Value NO_SERVICE REDUCED_SERVICE SIGNIFICANT_DELAYS DETOUR ADDITIONAL_SERVICE MODIFIED_SERVICE OTHER_EFFECT UNKNOWN_EFFECT STOP_MOVED NO_EFFECT ACCESSIBILITY_ISSUE enum SeverityLevel \u00b6 The severity of the alert. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. Values Value UNKNOWN_SEVERITY INFO WARNING SEVERE message TimeRange \u00b6 A time interval. The interval is considered active at time t if t is greater than or equal to the start time and less than the end time. Fields Field Name Type Required Cardinality Description start uint64 Conditionally required One Start time, in POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC). If missing, the interval starts at minus infinity. If a TimeRange is provided, either start or end must be provided - both fields cannot be empty. end uint64 Conditionally required One End time, in POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC). If missing, the interval ends at plus infinity. If a TimeRange is provided, either start or end must be provided - both fields cannot be empty. message Position \u00b6 A geographic position of a vehicle. Fields Field Name Type Required Cardinality Description latitude float Required One Degrees North, in the WGS-84 coordinate system. longitude float Required One Degrees East, in the WGS-84 coordinate system. bearing float Optional One Bearing, in degrees, clockwise from True North, i.e., 0 is North and 90 is East. This can be the compass bearing, or the direction towards the next stop or intermediate location. This should not be deduced from the sequence of previous positions, which clients can compute from previous data. odometer double Optional One Odometer value, in meters. speed float Optional One Momentary speed measured by the vehicle, in meters per second. message TripDescriptor \u00b6 A descriptor that identifies a single instance of a GTFS trip. To specify a single trip instance, in many cases a trip_id by itself is sufficient. However, the following cases require additional information to resolve to a single trip instance: * For trips defined in frequencies.txt, start_date and start_time are required in addition to trip_id * If the trip lasts for more than 24 hours, or is delayed such that it would collide with a scheduled trip on the following day, then start_date is required in addition to trip_id * If the trip_id field can't be provided, then route_id , direction_id , start_date , and start_time must all be provided In all cases, if route_id is provided in addition to trip_id , then the route_id must be the same route_id as assigned to the given trip in GTFS trips.txt. The trip_id field cannot, by itself or in combination with other TripDescriptor fields, be used to identify multiple trip instances. For example, a TripDescriptor should never specify trip_id by itself for GTFS frequencies.txt exact_times=0 trips because start_time is also required to resolve to a single trip instance starting at a specific time of the day. If the TripDescriptor does not resolve to a single trip instance (i.e., it resolves to zero or multiple trip instances), it is considered an error and the entity containing the erroneous TripDescriptor may be discarded by consumers. Note that if the trip_id is not known, then station sequence ids in TripUpdate are not sufficient, and stop_ids must be provided as well. In addition, absolute arrival/departure times must be provided. TripDescriptor.route_id cannot be used within an Alert EntitySelector to specify a route-wide alert that affects all trips for a route - use EntitySelector.route_id instead. Fields Field Name Type Required Cardinality Description trip_id string Conditionally required One The trip_id from the GTFS feed that this selector refers to. For non frequency-based trips (trips not defined in GTFS frequencies.txt), this field is enough to uniquely identify the trip. For frequency-based trips defined in GTFS frequencies.txt, trip_id, start_time, and start_date are all required. For scheduled-based trips (trips not defined in GTFS frequencies.txt), trip_id can only be omitted if the trip can be uniquely identified by a combination of route_id, direction_id, start_time, and start_date, and all those fields are provided. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id. route_id string Conditionally required One The route_id from the GTFS that this selector refers to. If trip_id is omitted, route_id, direction_id, start_time, and schedule_relationship=SCHEDULED must all be set to identify a trip instance. TripDescriptor.route_id should not be used within an Alert EntitySelector to specify a route-wide alert that affects all trips for a route - use EntitySelector.route_id instead. direction_id uint32 Conditionally required One The direction_id from the GTFS feed trips.txt file, indicating the direction of travel for trips this selector refers to. If trip_id is omitted, direction_id must be provided. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. start_time string Conditionally required One The initially scheduled start time of this trip instance. When the trip_id corresponds to a non-frequency-based trip, this field should either be omitted or be equal to the value in the GTFS feed. When the trip_id correponds to a frequency-based trip defined in GTFS frequencies.txt, start_time is required and must be specified for trip updates and vehicle positions. If the trip corresponds to exact_times=1 GTFS record, then start_time must be some multiple (including zero) of headway_secs later than frequencies.txt start_time for the corresponding time period. If the trip corresponds to exact_times=0, then its start_time may be arbitrary, and is initially expected to be the first departure of the trip. Once established, the start_time of this frequency-based exact_times=0 trip should be considered immutable, even if the first departure time changes -- that time change may instead be reflected in a StopTimeUpdate. If trip_id is omitted, start_time must be provided. Format and semantics of the field is same as that of GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35. start_date string Conditionally required One The start date of this trip instance in YYYYMMDD format. For scheduled trips (trips not defined in GTFS frequencies.txt), this field must be provided to disambiguate trips that are so late as to collide with a scheduled trip on a next day. For example, for a train that departs 8:00 and 20:00 every day, and is 12 hours late, there would be two distinct trips on the same time. This field can be provided but is not mandatory for schedules in which such collisions are impossible - for example, a service running on hourly schedule where a vehicle that is one hour late is not considered to be related to schedule anymore. This field is required for frequency-based trips defined in GTFS frequencies.txt. If trip_id is omitted, start_date must be provided. schedule_relationship ScheduleRelationship Optional One The relation between this trip and the static schedule. If TripDescriptor is provided in an Alert EntitySelector , the schedule_relationship field is ignored by consumers when identifying the matching trip instance. enum ScheduleRelationship \u00b6 The relation between this trip and the static schedule. If a trip is done in accordance with temporary schedule, not reflected in GTFS, then it shouldn't be marked as SCHEDULED, but marked as ADDED. Values Value Comment SCHEDULED Trip that is running in accordance with its GTFS schedule, or is close enough to the scheduled trip to be associated with it. ADDED An extra trip that was added in addition to a running schedule, for example, to replace a broken vehicle or to respond to sudden passenger load. NOTE: Currently, behavior is unspecified for feeds that use this mode. There are discussions on the GTFS GitHub (1) (2) (3) around fully specifying or deprecating ADDED trips and the documentation will be updated when those discussions are finalized. UNSCHEDULED A trip that is running with no schedule associated to it - this value is used to identify trips defined in GTFS frequencies.txt with exact_times = 0. It should not be used to describe trips not defined in GTFS frequencies.txt, or trips in GTFS frequencies.txt with exact_times = 1. Trips with schedule_relationship: UNSCHEDULED must also set all StopTimeUpdates schedule_relationship: UNSCHEDULED CANCELED A trip that existed in the schedule but was removed. DUPLICATED A new trip that is the same as an existing scheduled trip except for service start date and time. Used with TripUpdate.TripProperties.trip_id , TripUpdate.TripProperties.start_date , and TripUpdate.TripProperties.start_time to copy an existing trip from static GTFS but start at a different service date and/or time. Duplicating a trip is allowed if the service related to the original trip in (CSV) GTFS (in calendar.txt or calendar_dates.txt ) is operating within the next 30 days. The trip to be duplicated is identified via TripUpdate.TripDescriptor.trip_id . This enumeration does not modify the existing trip referenced by TripUpdate.TripDescriptor.trip_id - if a producer wants to cancel the original trip, it must publish a separate TripUpdate with the value of CANCELED. Trips defined in GTFS frequencies.txt with exact_times that is empty or equal to 0 cannot be duplicated. The VehiclePosition.TripDescriptor.trip_id for the new trip must contain the matching value from TripUpdate.TripProperties.trip_id and VehiclePosition.TripDescriptor.ScheduleRelationship must also be set to DUPLICATED . Existing producers and consumers that were using the ADDED enumeration to represent duplicated trips must follow the migration guide to transition to the DUPLICATED enumeration. message VehicleDescriptor \u00b6 Identification information for the vehicle performing the trip. Fields Field Name Type Required Cardinality Description id string Optional One Internal system identification of the vehicle. Should be unique per vehicle, and is used for tracking the vehicle as it proceeds through the system. This id should not be made visible to the end-user; for that purpose use the label field label string Optional One User visible label, i.e., something that must be shown to the passenger to help identify the correct vehicle. license_plate string Optional One The license plate of the vehicle. message EntitySelector \u00b6 A selector for an entity in a GTFS feed. The values of the fields should correspond to the appropriate fields in the GTFS feed. At least one specifier must be given. If several are given, they should be interpreted as being joined by the logical AND operator. Additionally, the combination of specifiers must match the corresponding information in the GTFS feed. In other words, in order for an alert to apply to an entity in GTFS it must match all of the provided EntitySelector fields. For example, an EntitySelector that includes the fields route_id: \"5\" and route_type: \"3\" applies only to the route_id: \"5\" bus - it does not apply to any other routes of route_type: \"3\" . If a producer wants an alert to apply to route_id: \"5\" as well as route_type: \"3\" , it should provide two separate EntitySelectors, one referencing route_id: \"5\" and another referencing route_type: \"3\" . At least one specifier must be given - all fields in an EntitySelector cannot be empty. Fields Field Name Type Required Cardinality Description agency_id string Conditionally required One The agency_id from the GTFS feed that this selector refers to. route_id string Conditionally required One The route_id from the GTFS that this selector refers to. If direction_id is provided, route_id must also be provided. route_type int32 Conditionally required One The route_type from the GTFS that this selector refers to. direction_id uint32 Conditionally required One The direction_id from the GTFS feed trips.txt file, used to select all trips in one direction for a route, specified by route_id. If direction_id is provided, route_id must also be provided. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. trip TripDescriptor Conditionally required One The trip instance from the GTFS that this selector refers to. This TripDescriptor must resolve to a single trip instance in the GTFS data (e.g., a producer cannot provide only a trip_id for exact_times=0 trips). If the ScheduleRelationship field is populated within this TripDescriptor it will be ignored by consumers when attempting to identify the GTFS trip. stop_id string Conditionally required One The stop_id from the GTFS feed that this selector refers to. message TranslatedString \u00b6 An internationalized message containing per-language versions of a snippet of text or a URL. One of the strings from a message will be picked up. The resolution proceeds as follows: If the UI language matches the language code of a translation, the first matching translation is picked. If a default UI language (e.g., English) matches the language code of a translation, the first matching translation is picked. If some translation has an unspecified language code, that translation is picked. Fields Field Name Type Required Cardinality Description translation Translation Required Many At least one translation must be provided. message Translation \u00b6 A localized string mapped to a language. Field Name Type Required Cardinality Description text string Required One A UTF-8 string containing the message. language string Conditionally required One BCP-47 language code. Can be omitted if the language is unknown or if no internationalization is done at all for the feed. At most one translation is allowed to have an unspecified language tag - if there is more than one translation, the language must be provided. message TranslatedImage \u00b6 An internationalized message containing per-language versions of an image. One of the images from a message will be picked up. The resolution proceeds as follows: If the UI language matches the language code of a translation, the first matching translation is picked. If a default UI language (e.g., English) matches the language code of a translation, the first matching translation is picked. If some translation has an unspecified language code, that translation is picked. Caution: this message is still experimental , and subject to change. It may be formally adopted in the future. Fields Field Name Type Required Cardinality Description localized_image LocalizedImage Required Many At least one localized image must be provided. message LocalizedImage \u00b6 A localized image URL mapped to a language. Field Name Type Required Cardinality Description url string Required One String containing an URL linking to an image. The image linked must less than 2MB. If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one. The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following https://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values. media_type string Required One IANA media type as to specify the type of image to be displayed. The type must start with \"image/\" language string Conditionally required One BCP-47 language code. Can be omitted if the language is unknown or if no internationalization is done at all for the feed. At most one translation is allowed to have an unspecified language tag - if there is more than one translation, the language must be provided. message Shape \u00b6 Describes the physical path that a vehicle takes when the shape is not part of the (CSV) GTFS, such as for an ad-hoc detour. Shapes belong to Trips and consist of an encoded polyline for more efficient transmission. Shapes do not need to intercept the location of Stops exactly, but all Stops on a trip should lie within a small distance of the shape for that trip, i.e. close to straight line segments connecting the shape points Caution: this message is still experimental , and subject to change. It may be formally adopted in the future. . Fields Field Name Type Required Cardinality Description shape_id string Required One Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. encoded_polyline string Required One Encoded polyline representation of the shape. This polyline must contain at least two points. For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm Caution: this field is still experimental , and subject to change. It may be formally adopted in the future.","title":"Reference"},{"location":"realtime/reference/#gtfs-realtime-reference","text":"A GTFS Realtime feed lets transit agencies provide consumers with realtime information about disruptions to their service (stations closed, lines not operating, important delays, etc.) location of their vehicles, and expected arrival times. Version 2.0 of the feed specification is discussed and documented on this site. Valid versions are \"2.0\", \"1.0\".","title":"GTFS Realtime Reference"},{"location":"realtime/reference/#term-definitions","text":"","title":"Term Definitions"},{"location":"realtime/reference/#required","text":"In GTFS-realtime v2.0 and higher, the Required column describes what fields must be provided by a producer in order for the transit data to be valid and make sense to a consuming application. The following values are used in the Required field: Required : This field must be provided by a GTFS-realtime feed producer. Conditionally required : This field is required under certain conditions, which are outlined in the field Description . Outside of these conditions, the field is optional. Optional : This field is optional and is not required to be implemented by producers. However, if the data is available in the underlying automatic vehicle location systems (e.g., VehiclePosition timestamp ) it is recommended that producers provide these optional fields when possible. Note that semantic requirements were not defined in GTFS-realtime version 1.0, and therefore feeds with gtfs_realtime_version of 1 may not meet these requirements (see the proposal for semantic requirements for details).","title":"Required"},{"location":"realtime/reference/#cardinality","text":"Cardinality represents the number of elements that may be provided for a particular field, with the following values: One - A single one element may be provided for this field. This maps to the Protocol Buffer required and optional cardinalities . Many - Many elements (0, 1, or more) may be provided for this field. This maps to the Protocol Buffer repeated cardinality . Always reference the Required and Description fields to see when a field is required, conditionally required, or optional. Please reference gtfs-realtime.proto for Protocol Buffer cardinality.","title":"Cardinality"},{"location":"realtime/reference/#protocol-buffer-data-types","text":"The following protocol buffer data types are used to describe feed elements: message : Complex type enum : List of fixed values","title":"Protocol Buffer data types"},{"location":"realtime/reference/#experimental-fields","text":"Fields labeled as experimental are subject to change and not yet formally adopted into the specification. An experimental field may be formally adopted in the future.","title":"Experimental fields"},{"location":"realtime/reference/#element-index","text":"FeedMessage FeedHeader Incrementality FeedEntity TripUpdate TripDescriptor ScheduleRelationship VehicleDescriptor StopTimeUpdate StopTimeEvent ScheduleRelationship StopTimeProperties TripProperties VehiclePosition TripDescriptor ScheduleRelationship VehicleDescriptor Position VehicleStopStatus CongestionLevel OccupancyStatus CarriageDetails Alert TimeRange EntitySelector TripDescriptor ScheduleRelationship Cause Effect TranslatedString Translation SeverityLevel","title":"Element Index"},{"location":"realtime/reference/#elements","text":"","title":"Elements"},{"location":"realtime/reference/#message-feedmessage","text":"The contents of a feed message. Each message in the stream is obtained as a response to an appropriate HTTP GET request. A realtime feed is always defined with relation to an existing GTFS feed. All the entity ids are resolved with respect to the GTFS feed. Fields Field Name Type Required Cardinality Description header FeedHeader Required One Metadata about this feed and feed message. entity FeedEntity Conditionally required Many Contents of the feed. If there is real-time information available for the transit system, this field must be provided. If this field is empty, consumers should assume there is no real-time information available for the system.","title":"message FeedMessage"},{"location":"realtime/reference/#message-feedheader","text":"Metadata about a feed, included in feed messages. Fields Field Name Type Required Cardinality Description gtfs_realtime_version string Required One Version of the feed specification. The current version is 2.0. incrementality Incrementality Required One timestamp uint64 Required One This timestamp identifies the moment when the content of this feed has been created (in server time). In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC). To avoid time skew between systems producing and consuming realtime information it is strongly advised to derive timestamp from a time server. It is completely acceptable to use Stratum 3 or even lower strata servers since time differences up to a couple of seconds are tolerable.","title":"message FeedHeader"},{"location":"realtime/reference/#enum-incrementality","text":"Determines whether the current fetch is incremental. FULL_DATASET : this feed update will overwrite all preceding realtime information for the feed. Thus this update is expected to provide a full snapshot of all known realtime information. DIFFERENTIAL : currently, this mode is unsupported and behavior is unspecified for feeds that use this mode. There are discussions on the GTFS Realtime mailing list around fully specifying the behavior of DIFFERENTIAL mode and the documentation will be updated when those discussions are finalized. Values Value FULL_DATASET DIFFERENTIAL","title":"enum Incrementality"},{"location":"realtime/reference/#message-feedentity","text":"A definition (or update) of an entity in the transit feed. If the entity is not being deleted, exactly one of 'trip_update', 'vehicle', 'alert' and 'shape' fields should be populated. Fields Field Name Type Required Cardinality Description id string Required One Feed-unique identifier for this entity. The ids are used only to provide incrementality support. The actual entities referenced by the feed must be specified by explicit selectors (see EntitySelector below for more info). is_deleted bool Optional One Whether this entity is to be deleted. Should be provided only for feeds with Incrementality of DIFFERENTIAL - this field should NOT be provided for feeds with Incrementality of FULL_DATASET. trip_update TripUpdate Conditionally required One Data about the realtime departure delays of a trip. At least one of the fields trip_update, vehicle, alert, or shape must be provided - all these fields cannot be empty. vehicle VehiclePosition Conditionally required One Data about the realtime position of a vehicle. At least one of the fields trip_update, vehicle, alert, or shape must be provided - all these fields cannot be empty. alert Alert Conditionally required One Data about the realtime alert. At least one of the fields trip_update, vehicle, alert, or shape must be provided - all these fields cannot be empty. shape Shape Conditionally required One Data about the realtime added shapes, such as for a detour. At least one of the fields trip_update, vehicle, alert, or shape must be provided - all these fields cannot be empty. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future.","title":"message FeedEntity"},{"location":"realtime/reference/#message-tripupdate","text":"Realtime update on the progress of a vehicle along a trip. Please also refer to the general discussion of the trip updates entities . Depending on the value of ScheduleRelationship, a TripUpdate can specify: A trip that proceeds along the schedule. A trip that proceeds along a route but has no fixed schedule. A trip that has been added or removed with regard to schedule. A new trip that is a copy of an existing trip in static GTFS. It will run at the service date and time specified in TripProperties. The updates can be for future, predicted arrival/departure events, or for past events that already occurred. In most cases information about past events is a measured value thus its uncertainty value is recommended to be 0. Although there could be cases when this does not hold so it is allowed to have uncertainty value different from 0 for past events. If an update's uncertainty is not 0, either the update is an approximate prediction for a trip that has not completed or the measurement is not precise or the update was a prediction for the past that has not been verified after the event occurred. If a vehicle is serving multiple trips within the same block (for more information about trips and blocks, please refer to GTFS trips.txt ): * the feed should include a TripUpdate for the trip currently being served by the vehicle. Producers are encouraged to include TripUpdates for one or more trips after the current trip in this vehicle's block if the producer is confident in the quality of the predictions for these future trip(s). Including multiple TripUpdates for the same vehicle avoids prediction \"pop-in\" for riders as the vehicle transitions from one trip to another and also gives riders advance notice of delays that impact downstream trips (e.g., when the known delay exceeds planned layover times between trips). * the respective TripUpdate entities are not required to be added to the feed in the same order that they are scheduled in the block. For example, if there are trips with trip_ids 1, 2, and 3 that all belong to one block, and the vehicle travels trip 1, then trip 2, and then trip 3, the trip_update entities may appear in any order - for example, adding trip 2, then trip 1, and then trip 3 is allowed. Note that the update can describe a trip that has already completed.To this end, it is enough to provide an update for the last stop of the trip. If the time of arrival at the last stop is in the past, the client will conclude that the whole trip is in the past (it is possible, although inconsequential, to also provide updates for preceding stops). This option is most relevant for a trip that has completed ahead of schedule, but according to the schedule, the trip is still proceeding at the current time. Removing the updates for this trip could make the client assume that the trip is still proceeding. Note that the feed provider is allowed, but not required, to purge past updates - this is one case where this would be practically useful. Fields Field Name Type Required Cardinality Description trip TripDescriptor Required One The Trip that this message applies to. There can be at most one TripUpdate entity for each actual trip instance. If there is none, that means there is no prediction information available. It does not mean that the trip is progressing according to schedule. vehicle VehicleDescriptor Optional One Additional information on the vehicle that is serving this trip. stop_time_update StopTimeUpdate Conditionally required Many Updates to StopTimes for the trip (both future, i.e., predictions, and in some cases, past ones, i.e., those that already happened). The updates must be sorted by stop_sequence, and apply for all the following stops of the trip up to the next specified stop_time_update. At least one stop_time_update must be provided for the trip unless the trip.schedule_relationship is CANCELED or DUPLICATED - if the trip is canceled, no stop_time_updates need to be provided. If the trip is duplicated, stop_time_updates may be provided to indicate real-time information for the new trip. timestamp uint64 Optional One The most recent moment at which the vehicle's real-time progress was measured to estimate StopTimes in the future. When StopTimes in the past are provided, arrival/departure times may be earlier than this value. In POSIX time (i.e., the number of seconds since January 1st 1970 00:00:00 UTC). delay int32 Optional One The current schedule deviation for the trip. Delay should only be specified when the prediction is given relative to some existing schedule in GTFS. Delay (in seconds) can be positive (meaning that the vehicle is late) or negative (meaning that the vehicle is ahead of schedule). Delay of 0 means that the vehicle is exactly on time. Delay information in StopTimeUpdates take precedent of trip-level delay information, such that trip-level delay is only propagated until the next stop along the trip with a StopTimeUpdate delay value specified. Feed providers are strongly encouraged to provide a TripUpdate.timestamp value indicating when the delay value was last updated, in order to evaluate the freshness of the data. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. trip_properties TripProperties Optional One Provides the updated properties for the trip. Caution: this message is still experimental , and subject to change. It may be formally adopted in the future.","title":"message TripUpdate"},{"location":"realtime/reference/#message-stoptimeevent","text":"Timing information for a single predicted event (either arrival or departure). Timing consists of delay and/or estimated time, and uncertainty. delay should be used when the prediction is given relative to some existing schedule in GTFS. time should be given whether there is a predicted schedule or not. If both time and delay are specified, time will take precedence (although normally, time, if given for a scheduled trip, should be equal to scheduled time in GTFS + delay). Uncertainty applies equally to both time and delay. The uncertainty roughly specifies the expected error in true delay (but note, we don't yet define its precise statistical meaning). It's possible for the uncertainty to be 0, for example for trains that are driven under computer timing control. Fields Field Name Type Required Cardinality Description delay int32 Conditionally required One Delay (in seconds) can be positive (meaning that the vehicle is late) or negative (meaning that the vehicle is ahead of schedule). Delay of 0 means that the vehicle is exactly on time. Either delay or time must be provided within a StopTimeEvent - both fields cannot be empty. time int64 Conditionally required One Event as absolute time. In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC). Either delay or time must be provided within a StopTimeEvent - both fields cannot be empty. uncertainty int32 Optional One If uncertainty is omitted, it is interpreted as unknown. To specify a completely certain prediction, set its uncertainty to 0.","title":"message StopTimeEvent"},{"location":"realtime/reference/#message-stoptimeupdate","text":"Realtime update for arrival and/or departure events for a given stop on a trip. Please also refer to the general discussion of stop time updates in the TripDescriptor and trip updates entities documentation. Updates can be supplied for both past and future events. The producer is allowed, although not required, to drop past events. The update is linked to a specific stop either through stop_sequence or stop_id, so one of these fields must necessarily be set. If the same stop_id is visited more than once in a trip, then stop_sequence should be provided in all StopTimeUpdates for that stop_id on that trip. Fields Field Name Type Required Cardinality Description stop_sequence uint32 Conditionally required One Must be the same as in stop_times.txt in the corresponding GTFS feed. Either stop_sequence or stop_id must be provided within a StopTimeUpdate - both fields cannot be empty. stop_sequence is required for trips that visit the same stop_id more than once (e.g., a loop) to disambiguate which stop the prediction is for. If StopTimeProperties.assigned_stop_id is populated, then stop_sequence must be populated. stop_id string Conditionally required One Must be the same as in stops.txt in the corresponding GTFS feed. Either stop_sequence or stop_id must be provided within a StopTimeUpdate - both fields cannot be empty. If StopTimeProperties.assigned_stop_id is populated, it is preferred to omit stop_id and use only stop_sequence . If StopTimeProperties.assigned_stop_id and stop_id are populated, stop_id must match assigned_stop_id . arrival StopTimeEvent Conditionally required One If schedule_relationship is empty or SCHEDULED, either arrival or departure must be provided within a StopTimeUpdate - both fields cannot be empty. arrival and departure may both be empty when schedule_relationship is SKIPPED. If schedule_relationship is NO_DATA, arrival and departure must be empty. departure StopTimeEvent Conditionally required One If schedule_relationship is empty or SCHEDULED, either arrival or departure must be provided within a StopTimeUpdate - both fields cannot be empty. arrival and departure may both be empty when schedule_relationship is SKIPPED. If schedule_relationship is NO_DATA, arrival and departure must be empty. departure_occupancy_status OccupancyStatus Optional One The predicted state of passenger occupancy for the vehicle immediately after departure from the given stop. If provided, stop_sequence must be provided. To provide departure_occupancy_status without providing any real-time arrival or departure predictions, populate this field and set StopTimeUpdate.schedule_relationship = NO_DATA. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. schedule_relationship ScheduleRelationship Optional One The default relationship is SCHEDULED. stop_time_properties StopTimeProperties Optional One Realtime updates for certain properties defined within GTFS stop_times.txt Caution: this field is still experimental , and subject to change. It may be formally adopted in the future.","title":"message StopTimeUpdate"},{"location":"realtime/reference/#enum-schedulerelationship","text":"The relation between this StopTime and the static schedule. Values Value Comment SCHEDULED The vehicle is proceeding in accordance with its static schedule of stops, although not necessarily according to the times of the schedule. This is the default behavior. At least one of arrival and departure must be provided. Frequency-based trips (GTFS frequencies.txt with exact_times = 0) should not have a SCHEDULED value and should use UNSCHEDULED instead. SKIPPED The stop is skipped, i.e., the vehicle will not stop at this stop. Arrival and departure are optional. When set SKIPPED is not propagated to subsequent stops in the same trip (i.e., the vehicle will stop at subsequent stops in the trip unless those stops also have a stop_time_update with schedule_relationship: SKIPPED ). Delay from a previous stop in the trip does propagate over the SKIPPED stop. In other words, if a stop_time_update with an arrival or departure prediction is not set for a stop after the SKIPPED stop, the prediction upstream of the SKIPPED stop will be propagated to the stop after the SKIPPED stop and subsequent stops in the trip until a stop_time_update for a subsequent stop is provided. NO_DATA No data is given for this stop. It indicates that there is no realtime timing information available. When set NO_DATA is propagated through subsequent stops so this is the recommended way of specifying from which stop you do not have realtime timing information. When NO_DATA is set neither arrival nor departure should be supplied. UNSCHEDULED The vehicle is operating a frequency-based trip (GTFS frequencies.txt with exact_times = 0). This value should not be used for trips that are not defined in GTFS frequencies.txt, or trips in GTFS frequencies.txt with exact_times = 1. Trips containing stop_time_updates with schedule_relationship: UNSCHEDULED must also set the TripDescriptor schedule_relationship: UNSCHEDULED Caution: this field is still experimental , and subject to change. It may be formally adopted in the future.","title":"enum ScheduleRelationship"},{"location":"realtime/reference/#message-stoptimeproperties","text":"Realtime update for certain properties defined within GTFS stop_times.txt. Caution: this message is still experimental , and subject to change. It may be formally adopted in the future. Fields Field Name Type Required Cardinality Description assigned_stop_id string Optional One Supports real-time stop assignments. Refers to a stop_id defined in the GTFS stops.txt . The new assigned_stop_id should not result in a significantly different trip experience for the end user than the stop_id defined in GTFS stop_times.txt . In other words, the end user should not view this new stop_id as an \"unusual change\" if the new stop was presented within an app without any additional context. For example, this field is intended to be used for platform assignments by using a stop_id that belongs to the same station as the stop originally defined in GTFS stop_times.txt . To assign a stop without providing any real-time arrival or departure predictions, populate this field and set StopTimeUpdate.schedule_relationship = NO_DATA . If this field is populated, StopTimeUpdate.stop_sequence must be populated and StopTimeUpdate.stop_id should not be populated. Stop assignments should be reflected in other GTFS-realtime fields as well (e.g., VehiclePosition.stop_id ). Caution: this field is still experimental , and subject to change. It may be formally adopted in the future.","title":"message StopTimeProperties"},{"location":"realtime/reference/#message-tripproperties","text":"Defines updated properties of the trip Caution: this message is still experimental , and subject to change. It may be formally adopted in the future. . Fields Field Name Type Required Cardinality Description trip_id string Conditionally required One Defines the identifier of a new trip that is a duplicate of an existing trip defined in (CSV) GTFS trips.txt but will start at a different service date and/or time (defined using TripProperties.start_date and TripProperties.start_time ). See definition of trips.trip_id in (CSV) GTFS. Its value must be different than the ones used in the (CSV) GTFS. This field is required if schedule_relationship is DUPLICATED , otherwise this field must not be populated and will be ignored by consumers. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. start_date string Conditionally required One Service date on which the duplicated trip will be run. Must be provided in YYYYMMDD format. This field is required if schedule_relationship is DUPLICATED , otherwise this field must not be populated and will be ignored by consumers. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. start_time string Conditionally required One Defines the departure start time of the trip when it\u2019s duplicated. See definition of stop_times.departure_time in (CSV) GTFS. Scheduled arrival and departure times for the duplicated trip are calculated based on the offset between the original trip departure_time and this field. For example, if a GTFS trip has stop A with a departure_time of 10:00:00 and stop B with departure_time of 10:01:00 , and this field is populated with the value of 10:30:00 , stop B on the duplicated trip will have a scheduled departure_time of 10:31:00 . Real-time prediction delay values are applied to this calculated schedule time to determine the predicted time. For example, if a departure delay of 30 is provided for stop B, then the predicted departure time is 10:31:30 . Real-time prediction time values do not have any offset applied to them and indicate the predicted time as provided. For example, if a departure time representing 10:31:30 is provided for stop B, then the predicted departure time is 10:31:30 .This field is required if schedule_relationship is DUPLICATED , otherwise this field must not be populated and will be ignored by consumers. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. shape_id string Optional One Specifies the shape of the vehicle travel path for this trip when it differs from the original. Refers to a shape defined in the (CSV) GTFS or a new shape entity in a real-time feed. See definition of trips.shape_id in (CSV) GTFS. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future.","title":"message TripProperties"},{"location":"realtime/reference/#message-vehicleposition","text":"Realtime positioning information for a given vehicle. Fields Field Name Type Required Cardinality Description trip TripDescriptor Optional One The Trip that this vehicle is serving. Can be empty or partial if the vehicle can not be identified with a given trip instance. vehicle VehicleDescriptor Optional One Additional information on the vehicle that is serving this trip. Each entry should have a unique vehicle id. position Position Optional One Current position of this vehicle. current_stop_sequence uint32 Optional One The stop sequence index of the current stop. The meaning of current_stop_sequence (i.e., the stop that it refers to) is determined by current_status. If current_status is missing IN_TRANSIT_TO is assumed. stop_id string Optional One Identifies the current stop. The value must be the same as in stops.txt in the corresponding GTFS feed. If StopTimeProperties.assigned_stop_id is used to assign a stop_id , this field should also reflect the change in stop_id . current_status VehicleStopStatus Optional One The exact status of the vehicle with respect to the current stop. Ignored if current_stop_sequence is missing. timestamp uint64 Optional One Moment at which the vehicle's position was measured. In POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC). congestion_level CongestionLevel Optional One occupancy_status OccupancyStatus Optional One The state of passenger occupancy for the vehicle or carriage. If multi_carriage_details is populated with per-carriage OccupancyStatus, then this field should describe the entire vehicle with all carriages accepting passengers considered. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. occupancy_percentage uint32 Optional One A percentage value indicating the degree of passenger occupancy in the vehicle. The value 100 should represent the total maximum occupancy the vehicle was designed for, including both seating and standing capacity, and current operating regulations allow. The value may exceed 100 if there are more passengers than the maximum designed capacity. The precision of occupancy_percentage should be low enough that individual passengers cannot be tracked boarding or alighting the vehicle. If multi_carriage_details is populated with per-carriage occupancy_percentage, then this field should describe the entire vehicle with all carriages accepting passengers considered. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. multi_carriage_details CarriageDetails Optional Many Details of the multiple carriages of this given vehicle. The first occurrence represents the first carriage of the vehicle, given the current direction of travel . The number of occurrences of the multi_carriage_details field represents the number of carriages of the vehicle. It also includes non boardable carriages, like engines, maintenance carriages, etc\u2026 as they provide valuable information to passengers about where to stand on a platform. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future.","title":"message VehiclePosition"},{"location":"realtime/reference/#enum-vehiclestopstatus","text":"Values Value Comment INCOMING_AT The vehicle is just about to arrive at the stop (on a stop display, the vehicle symbol typically flashes). STOPPED_AT The vehicle is standing at the stop. IN_TRANSIT_TO The vehicle has departed the previous stop and is in transit.","title":"enum VehicleStopStatus"},{"location":"realtime/reference/#enum-congestionlevel","text":"Congestion level that is affecting this vehicle. Values Value UNKNOWN_CONGESTION_LEVEL RUNNING_SMOOTHLY STOP_AND_GO CONGESTION SEVERE_CONGESTION","title":"enum CongestionLevel"},{"location":"realtime/reference/#enum-occupancystatus","text":"The state of passenger occupancy for the vehicle or carriage. Individual producers may not publish all OccupancyStatus values. Therefore, consumers must not assume that the OccupancyStatus values follow a linear scale. Consumers should represent OccupancyStatus values as the state indicated and intended by the producer. Likewise, producers must use OccupancyStatus values that correspond to actual vehicle occupancy states. For describing passenger occupancy levels on a linear scale, see occupancy_percentage . Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. Values Value Comment EMPTY The vehicle is considered empty by most measures, and has few or no passengers onboard, but is still accepting passengers. MANY_SEATS_AVAILABLE The vehicle or carriage has a large number of seats available. The amount of free seats out of the total seats available to be considered large enough to fall into this category is determined at the discretion of the producer. FEW_SEATS_AVAILABLE The vehicle or carriage has a small number of seats available. The amount of free seats out of the total seats available to be considered small enough to fall into this category is determined at the discretion of the producer. STANDING_ROOM_ONLY The vehicle or carriage can currently accommodate only standing passengers. CRUSHED_STANDING_ROOM_ONLY The vehicle or carriage can currently accommodate only standing passengers and has limited space for them. FULL The vehicle is considered full by most measures, but may still be allowing passengers to board. NOT_ACCEPTING_PASSENGERS The vehicle or carriage is not accepting passengers. The vehicle or carriage usually accepts passengers for boarding. NO_DATA_AVAILABLE The vehicle or carriage doesn't have any occupancy data available at that time. NOT_BOARDABLE The vehicle or carriage is not boardable and never accepts passengers. Useful for special vehicles or carriages (engine, maintenance carriage, etc\u2026).","title":"enum OccupancyStatus"},{"location":"realtime/reference/#message-carriagedetails","text":"Carriage specific details, used for vehicles composed of several carriages. Caution: this message is still experimental , and subject to change. It may be formally adopted in the future. Fields Field Name Type Required Cardinality Description id string Optional One Identification of the carriage. Should be unique per vehicle. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. label string Optional One User visible label that may be shown to the passenger to help identify the carriage. Example: \"7712\", \"Car ABC-32\", etc... Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. occupancy_status OccupancyStatus Optional One Occupancy status for this given carriage, in this vehicle. Default is set to NO_DATA_AVAILABLE . Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. occupancy_percentage int32 Optional One Occupancy percentage for this given carriage, in this vehicle. Follows the same rules as \"VehiclePosition.occupancy_percentage\". Use -1 in case data is not available for this given carriage. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. carriage_sequence uint32 Required One Identifies the order of this carriage with respect to the other carriages in the vehicle's list of CarriageStatus. The first carriage in the direction of travel must have a value of 1. The second value corresponds to the second carriage in the direction of travel and must have a value of 2, and so forth. For example, the first carriage in the direction of travel has a value of 1. If the second carriage in the direction of travel has a value of 3, consumers will discard data for all carriages (i.e., the multi_carriage_details field). Carriages without data must be represented with a valid carriage_sequence number and the fields without data should be omitted (alternately, those fields could also be included and set to the \"no data\" values). Caution: this field is still experimental , and subject to change. It may be formally adopted in the future.","title":"message CarriageDetails"},{"location":"realtime/reference/#message-alert","text":"An alert, indicating some sort of incident in the public transit network. Fields Field Name Type Required Cardinality Description active_period TimeRange Optional Many Time when the alert should be shown to the user. If missing, the alert will be shown as long as it appears in the feed. If multiple ranges are given, the alert will be shown during all of them. informed_entity EntitySelector Required Many Entities whose users we should notify of this alert. At least one informed_entity must be provided. cause Cause Optional One effect Effect Optional One url TranslatedString Optional One The URL which provides additional information about the alert. header_text TranslatedString Required One Header for the alert. This plain-text string will be highlighted, for example in boldface. description_text TranslatedString Required One Description for the alert. This plain-text string will be formatted as the body of the alert (or shown on an explicit \"expand\" request by the user). The information in the description should add to the information of the header. tts_header_text TranslatedString Optional One Text containing the alert's header to be used for text-to-speech implementations. This field is the text-to-speech version of header_text. It should contain the same information as header_text but formatted such that it can read as text-to-speech (for example, abbreviations removed, numbers spelled out, etc.) tts_description_text TranslatedString Optional One Text containing a description for the alert to be used for text-to-speech implementations. This field is the text-to-speech version of description_text. It should contain the same information as description_text but formatted such that it can be read as text-to-speech (for example, abbreviations removed, numbers spelled out, etc.) severity_level SeverityLevel Optional One Severity of the alert. image TranslatedImage Optional One TranslatedImage to be displayed along the alert text. Used to explain visually the alert effect of a detour, station closure, etc. The image should enhance the understanding of the alert and must not be the only location of essential information. The following types of images are discouraged : image containing mainly text, marketing or branded images that add no additional information. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. image_alternative_text TranslatedString Optional One Text describing the appearance of the linked image in the image field (e.g., in case the image can't be displayed or the user can't see the image for accessibility reasons). See the HTML spec for alt image text . Caution: this field is still experimental , and subject to change. It may be formally adopted in the future.","title":"message Alert"},{"location":"realtime/reference/#enum-cause","text":"Cause of this alert. Values Value UNKNOWN_CAUSE OTHER_CAUSE TECHNICAL_PROBLEM STRIKE DEMONSTRATION ACCIDENT HOLIDAY WEATHER MAINTENANCE CONSTRUCTION POLICE_ACTIVITY MEDICAL_EMERGENCY","title":"enum Cause"},{"location":"realtime/reference/#enum-effect","text":"The effect of this problem on the affected entity. Values Value NO_SERVICE REDUCED_SERVICE SIGNIFICANT_DELAYS DETOUR ADDITIONAL_SERVICE MODIFIED_SERVICE OTHER_EFFECT UNKNOWN_EFFECT STOP_MOVED NO_EFFECT ACCESSIBILITY_ISSUE","title":"enum Effect"},{"location":"realtime/reference/#enum-severitylevel","text":"The severity of the alert. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. Values Value UNKNOWN_SEVERITY INFO WARNING SEVERE","title":"enum SeverityLevel"},{"location":"realtime/reference/#message-timerange","text":"A time interval. The interval is considered active at time t if t is greater than or equal to the start time and less than the end time. Fields Field Name Type Required Cardinality Description start uint64 Conditionally required One Start time, in POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC). If missing, the interval starts at minus infinity. If a TimeRange is provided, either start or end must be provided - both fields cannot be empty. end uint64 Conditionally required One End time, in POSIX time (i.e., number of seconds since January 1st 1970 00:00:00 UTC). If missing, the interval ends at plus infinity. If a TimeRange is provided, either start or end must be provided - both fields cannot be empty.","title":"message TimeRange"},{"location":"realtime/reference/#message-position","text":"A geographic position of a vehicle. Fields Field Name Type Required Cardinality Description latitude float Required One Degrees North, in the WGS-84 coordinate system. longitude float Required One Degrees East, in the WGS-84 coordinate system. bearing float Optional One Bearing, in degrees, clockwise from True North, i.e., 0 is North and 90 is East. This can be the compass bearing, or the direction towards the next stop or intermediate location. This should not be deduced from the sequence of previous positions, which clients can compute from previous data. odometer double Optional One Odometer value, in meters. speed float Optional One Momentary speed measured by the vehicle, in meters per second.","title":"message Position"},{"location":"realtime/reference/#message-tripdescriptor","text":"A descriptor that identifies a single instance of a GTFS trip. To specify a single trip instance, in many cases a trip_id by itself is sufficient. However, the following cases require additional information to resolve to a single trip instance: * For trips defined in frequencies.txt, start_date and start_time are required in addition to trip_id * If the trip lasts for more than 24 hours, or is delayed such that it would collide with a scheduled trip on the following day, then start_date is required in addition to trip_id * If the trip_id field can't be provided, then route_id , direction_id , start_date , and start_time must all be provided In all cases, if route_id is provided in addition to trip_id , then the route_id must be the same route_id as assigned to the given trip in GTFS trips.txt. The trip_id field cannot, by itself or in combination with other TripDescriptor fields, be used to identify multiple trip instances. For example, a TripDescriptor should never specify trip_id by itself for GTFS frequencies.txt exact_times=0 trips because start_time is also required to resolve to a single trip instance starting at a specific time of the day. If the TripDescriptor does not resolve to a single trip instance (i.e., it resolves to zero or multiple trip instances), it is considered an error and the entity containing the erroneous TripDescriptor may be discarded by consumers. Note that if the trip_id is not known, then station sequence ids in TripUpdate are not sufficient, and stop_ids must be provided as well. In addition, absolute arrival/departure times must be provided. TripDescriptor.route_id cannot be used within an Alert EntitySelector to specify a route-wide alert that affects all trips for a route - use EntitySelector.route_id instead. Fields Field Name Type Required Cardinality Description trip_id string Conditionally required One The trip_id from the GTFS feed that this selector refers to. For non frequency-based trips (trips not defined in GTFS frequencies.txt), this field is enough to uniquely identify the trip. For frequency-based trips defined in GTFS frequencies.txt, trip_id, start_time, and start_date are all required. For scheduled-based trips (trips not defined in GTFS frequencies.txt), trip_id can only be omitted if the trip can be uniquely identified by a combination of route_id, direction_id, start_time, and start_date, and all those fields are provided. When schedule_relationship is DUPLICATED within a TripUpdate, the trip_id identifies the trip from static GTFS to be duplicated. When schedule_relationship is DUPLICATED within a VehiclePosition, the trip_id identifies the new duplicate trip and must contain the value for the corresponding TripUpdate.TripProperties.trip_id. route_id string Conditionally required One The route_id from the GTFS that this selector refers to. If trip_id is omitted, route_id, direction_id, start_time, and schedule_relationship=SCHEDULED must all be set to identify a trip instance. TripDescriptor.route_id should not be used within an Alert EntitySelector to specify a route-wide alert that affects all trips for a route - use EntitySelector.route_id instead. direction_id uint32 Conditionally required One The direction_id from the GTFS feed trips.txt file, indicating the direction of travel for trips this selector refers to. If trip_id is omitted, direction_id must be provided. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. start_time string Conditionally required One The initially scheduled start time of this trip instance. When the trip_id corresponds to a non-frequency-based trip, this field should either be omitted or be equal to the value in the GTFS feed. When the trip_id correponds to a frequency-based trip defined in GTFS frequencies.txt, start_time is required and must be specified for trip updates and vehicle positions. If the trip corresponds to exact_times=1 GTFS record, then start_time must be some multiple (including zero) of headway_secs later than frequencies.txt start_time for the corresponding time period. If the trip corresponds to exact_times=0, then its start_time may be arbitrary, and is initially expected to be the first departure of the trip. Once established, the start_time of this frequency-based exact_times=0 trip should be considered immutable, even if the first departure time changes -- that time change may instead be reflected in a StopTimeUpdate. If trip_id is omitted, start_time must be provided. Format and semantics of the field is same as that of GTFS/frequencies.txt/start_time, e.g., 11:15:35 or 25:15:35. start_date string Conditionally required One The start date of this trip instance in YYYYMMDD format. For scheduled trips (trips not defined in GTFS frequencies.txt), this field must be provided to disambiguate trips that are so late as to collide with a scheduled trip on a next day. For example, for a train that departs 8:00 and 20:00 every day, and is 12 hours late, there would be two distinct trips on the same time. This field can be provided but is not mandatory for schedules in which such collisions are impossible - for example, a service running on hourly schedule where a vehicle that is one hour late is not considered to be related to schedule anymore. This field is required for frequency-based trips defined in GTFS frequencies.txt. If trip_id is omitted, start_date must be provided. schedule_relationship ScheduleRelationship Optional One The relation between this trip and the static schedule. If TripDescriptor is provided in an Alert EntitySelector , the schedule_relationship field is ignored by consumers when identifying the matching trip instance.","title":"message TripDescriptor"},{"location":"realtime/reference/#enum-schedulerelationship_1","text":"The relation between this trip and the static schedule. If a trip is done in accordance with temporary schedule, not reflected in GTFS, then it shouldn't be marked as SCHEDULED, but marked as ADDED. Values Value Comment SCHEDULED Trip that is running in accordance with its GTFS schedule, or is close enough to the scheduled trip to be associated with it. ADDED An extra trip that was added in addition to a running schedule, for example, to replace a broken vehicle or to respond to sudden passenger load. NOTE: Currently, behavior is unspecified for feeds that use this mode. There are discussions on the GTFS GitHub (1) (2) (3) around fully specifying or deprecating ADDED trips and the documentation will be updated when those discussions are finalized. UNSCHEDULED A trip that is running with no schedule associated to it - this value is used to identify trips defined in GTFS frequencies.txt with exact_times = 0. It should not be used to describe trips not defined in GTFS frequencies.txt, or trips in GTFS frequencies.txt with exact_times = 1. Trips with schedule_relationship: UNSCHEDULED must also set all StopTimeUpdates schedule_relationship: UNSCHEDULED CANCELED A trip that existed in the schedule but was removed. DUPLICATED A new trip that is the same as an existing scheduled trip except for service start date and time. Used with TripUpdate.TripProperties.trip_id , TripUpdate.TripProperties.start_date , and TripUpdate.TripProperties.start_time to copy an existing trip from static GTFS but start at a different service date and/or time. Duplicating a trip is allowed if the service related to the original trip in (CSV) GTFS (in calendar.txt or calendar_dates.txt ) is operating within the next 30 days. The trip to be duplicated is identified via TripUpdate.TripDescriptor.trip_id . This enumeration does not modify the existing trip referenced by TripUpdate.TripDescriptor.trip_id - if a producer wants to cancel the original trip, it must publish a separate TripUpdate with the value of CANCELED. Trips defined in GTFS frequencies.txt with exact_times that is empty or equal to 0 cannot be duplicated. The VehiclePosition.TripDescriptor.trip_id for the new trip must contain the matching value from TripUpdate.TripProperties.trip_id and VehiclePosition.TripDescriptor.ScheduleRelationship must also be set to DUPLICATED . Existing producers and consumers that were using the ADDED enumeration to represent duplicated trips must follow the migration guide to transition to the DUPLICATED enumeration.","title":"enum ScheduleRelationship"},{"location":"realtime/reference/#message-vehicledescriptor","text":"Identification information for the vehicle performing the trip. Fields Field Name Type Required Cardinality Description id string Optional One Internal system identification of the vehicle. Should be unique per vehicle, and is used for tracking the vehicle as it proceeds through the system. This id should not be made visible to the end-user; for that purpose use the label field label string Optional One User visible label, i.e., something that must be shown to the passenger to help identify the correct vehicle. license_plate string Optional One The license plate of the vehicle.","title":"message VehicleDescriptor"},{"location":"realtime/reference/#message-entityselector","text":"A selector for an entity in a GTFS feed. The values of the fields should correspond to the appropriate fields in the GTFS feed. At least one specifier must be given. If several are given, they should be interpreted as being joined by the logical AND operator. Additionally, the combination of specifiers must match the corresponding information in the GTFS feed. In other words, in order for an alert to apply to an entity in GTFS it must match all of the provided EntitySelector fields. For example, an EntitySelector that includes the fields route_id: \"5\" and route_type: \"3\" applies only to the route_id: \"5\" bus - it does not apply to any other routes of route_type: \"3\" . If a producer wants an alert to apply to route_id: \"5\" as well as route_type: \"3\" , it should provide two separate EntitySelectors, one referencing route_id: \"5\" and another referencing route_type: \"3\" . At least one specifier must be given - all fields in an EntitySelector cannot be empty. Fields Field Name Type Required Cardinality Description agency_id string Conditionally required One The agency_id from the GTFS feed that this selector refers to. route_id string Conditionally required One The route_id from the GTFS that this selector refers to. If direction_id is provided, route_id must also be provided. route_type int32 Conditionally required One The route_type from the GTFS that this selector refers to. direction_id uint32 Conditionally required One The direction_id from the GTFS feed trips.txt file, used to select all trips in one direction for a route, specified by route_id. If direction_id is provided, route_id must also be provided. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. trip TripDescriptor Conditionally required One The trip instance from the GTFS that this selector refers to. This TripDescriptor must resolve to a single trip instance in the GTFS data (e.g., a producer cannot provide only a trip_id for exact_times=0 trips). If the ScheduleRelationship field is populated within this TripDescriptor it will be ignored by consumers when attempting to identify the GTFS trip. stop_id string Conditionally required One The stop_id from the GTFS feed that this selector refers to.","title":"message EntitySelector"},{"location":"realtime/reference/#message-translatedstring","text":"An internationalized message containing per-language versions of a snippet of text or a URL. One of the strings from a message will be picked up. The resolution proceeds as follows: If the UI language matches the language code of a translation, the first matching translation is picked. If a default UI language (e.g., English) matches the language code of a translation, the first matching translation is picked. If some translation has an unspecified language code, that translation is picked. Fields Field Name Type Required Cardinality Description translation Translation Required Many At least one translation must be provided.","title":"message TranslatedString"},{"location":"realtime/reference/#message-translation","text":"A localized string mapped to a language. Field Name Type Required Cardinality Description text string Required One A UTF-8 string containing the message. language string Conditionally required One BCP-47 language code. Can be omitted if the language is unknown or if no internationalization is done at all for the feed. At most one translation is allowed to have an unspecified language tag - if there is more than one translation, the language must be provided.","title":"message Translation"},{"location":"realtime/reference/#message-translatedimage","text":"An internationalized message containing per-language versions of an image. One of the images from a message will be picked up. The resolution proceeds as follows: If the UI language matches the language code of a translation, the first matching translation is picked. If a default UI language (e.g., English) matches the language code of a translation, the first matching translation is picked. If some translation has an unspecified language code, that translation is picked. Caution: this message is still experimental , and subject to change. It may be formally adopted in the future. Fields Field Name Type Required Cardinality Description localized_image LocalizedImage Required Many At least one localized image must be provided.","title":"message TranslatedImage"},{"location":"realtime/reference/#message-localizedimage","text":"A localized image URL mapped to a language. Field Name Type Required Cardinality Description url string Required One String containing an URL linking to an image. The image linked must less than 2MB. If an image changes in a significant enough way that an update is required on the consumer side, the producer must update the URL to a new one. The URL should be a fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following https://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values. media_type string Required One IANA media type as to specify the type of image to be displayed. The type must start with \"image/\" language string Conditionally required One BCP-47 language code. Can be omitted if the language is unknown or if no internationalization is done at all for the feed. At most one translation is allowed to have an unspecified language tag - if there is more than one translation, the language must be provided.","title":"message LocalizedImage"},{"location":"realtime/reference/#message-shape","text":"Describes the physical path that a vehicle takes when the shape is not part of the (CSV) GTFS, such as for an ad-hoc detour. Shapes belong to Trips and consist of an encoded polyline for more efficient transmission. Shapes do not need to intercept the location of Stops exactly, but all Stops on a trip should lie within a small distance of the shape for that trip, i.e. close to straight line segments connecting the shape points Caution: this message is still experimental , and subject to change. It may be formally adopted in the future. . Fields Field Name Type Required Cardinality Description shape_id string Required One Identifier of the shape. Must be different than any shape_id defined in the (CSV) GTFS. Caution: this field is still experimental , and subject to change. It may be formally adopted in the future. encoded_polyline string Required One Encoded polyline representation of the shape. This polyline must contain at least two points. For more information about encoded polylines, see https://developers.google.com/maps/documentation/utilities/polylinealgorithm Caution: this field is still experimental , and subject to change. It may be formally adopted in the future.","title":"message Shape"},{"location":"realtime/revision-history/","text":"Revision History \u00b6 March 12, 2020 Updated the TripDescriptor description on the GTFS Realtime reference page. February 26, 2015 Added experimental field direction_id to TripDescriptor ( discussion ). January 30, 2015 Added Protocol Buffer extension namespace to all remaining GTFS-realtime messages that didn't already have one (such as FeedMessage and FeedEntity ). January 28, 2015 Added experimental field delay to TripUpdate ( discussion ). January 16, 2015 Update description of TripDescriptor.start_time . January 8, 2015 Defined experimental enum OccupancyStatus . Added experimental field occupancy_status to VehiclePosition ( discussion ). May 22, 2014 Updated description of ScheduleRelationship enum in StopTimeUpdate message ( discussion ). Removed REPLACEMENT from ScheduleRelationship enum values in TripDescriptor message ( discussion ). Oct 12, 2012 Added timestamp field to TripUpdate message. May 30, 2012 Added specific details about Extensions to the specification. November 30, 2011 Added Protocol Buffer extension namespace to key GTFS-realtime messages to facilitate writing extensions to the spec. October 25, 2011 Updated documentation to clarify that alert , header_text and description_text are both plain-text values. August 20, 2011 Updated documentation to clarify semantics of the TimeRange message. August 22, 2011 Initial version.","title":"Revision History"},{"location":"realtime/revision-history/#revision-history","text":"March 12, 2020 Updated the TripDescriptor description on the GTFS Realtime reference page. February 26, 2015 Added experimental field direction_id to TripDescriptor ( discussion ). January 30, 2015 Added Protocol Buffer extension namespace to all remaining GTFS-realtime messages that didn't already have one (such as FeedMessage and FeedEntity ). January 28, 2015 Added experimental field delay to TripUpdate ( discussion ). January 16, 2015 Update description of TripDescriptor.start_time . January 8, 2015 Defined experimental enum OccupancyStatus . Added experimental field occupancy_status to VehiclePosition ( discussion ). May 22, 2014 Updated description of ScheduleRelationship enum in StopTimeUpdate message ( discussion ). Removed REPLACEMENT from ScheduleRelationship enum values in TripDescriptor message ( discussion ). Oct 12, 2012 Added timestamp field to TripUpdate message. May 30, 2012 Added specific details about Extensions to the specification. November 30, 2011 Added Protocol Buffer extension namespace to key GTFS-realtime messages to facilitate writing extensions to the spec. October 25, 2011 Updated documentation to clarify that alert , header_text and description_text are both plain-text values. August 20, 2011 Updated documentation to clarify semantics of the TimeRange message. August 22, 2011 Initial version.","title":"Revision History"},{"location":"realtime/service-alerts/","text":"Service Alerts \u00b6 Service alerts allow you to provide updates whenever there is disruption on the network. Delays and cancellations of individual trips should usually be communicated using Trip updates . You have the option to provide the following: URL - link to your site explaining more about the alert Header text - a summary of the alert Description - a full description of the alert, which will always be shown alongside the header (so should not repeat this information). Time Range \u00b6 The alert will be displayed where appropriate within the given time range. This range should cover the entire time that the alert is useful for the passenger to see. If no time is given, we will display the alert for as long as it is in the feed. If multiple ranges are given, we will display during all of them. Entity Selector \u00b6 Entity selector allows you specify exactly which parts of the network this alert affects, so that we can display only the most appropriate alerts to the user. You may include multiple entity selectors for alerts which affect multiple entities. Entities are selected using their GTFS identifiers, and you can select any of the following: Agency - affects the whole network Route - affects the whole route Route type - affects any route of this type. e.g. all subways. Trip - affects a particular trip Stop - affects a particular stop You may include more than one of the fields listed above in one informed_entity . When multiple fields are included in one informed_entity , they should be interpreted as being joined by the AND logical operator. In other words, the alert should only be applied in a context that meets all of the fields provided in an informed_entity . For example, if route_id: \"1\" and stop_id: \"5\" are both included in one informed_entity , then the alert should apply only to route 1 at stop 5. It should NOT be applied to any other stop on route 1, and it should NOT be applied to any other route at stop 5. If you would like to represent an alert that affects more than one entity (e.g. an alert for both route 1 and stop 5) , you should add multiple informed_entity to your alert , with each of them applying to the affected entity (e.g. one informed_entity that includes route 1 and another informed_entity that includes stop 5). Cause \u00b6 What is the cause of this alert? You may specify one of the following: Unknown cause Other cause (not represented by any of these options) Technical problem Strike Demonstration Accident Holiday Weather Maintenance Construction Police activity Medical emergency Effect \u00b6 What effect does this problem have on the specified entity? You may specify one of the following: No service Reduced service Significant delays (insignificant delays should only be provided through Trip updates ). Detour Additional service Modified service: Operations are different from what the rider would normally expect. An example is an alert that reminds riders of an upcoming holiday schedule that is different from normal service on that day of the week. Stop moved Other effect (not represented by any of these options) Unknown effect No effect: The alert provides information to riders but does not affect operations. Examples include advertising public meetings and soliciting feedback via surveys. Accessibility issue: The alert provides information about accessibility issues that affects step-free access. Examples include an out of service elevator or movable ramps.","title":"Service Alerts"},{"location":"realtime/service-alerts/#service-alerts","text":"Service alerts allow you to provide updates whenever there is disruption on the network. Delays and cancellations of individual trips should usually be communicated using Trip updates . You have the option to provide the following: URL - link to your site explaining more about the alert Header text - a summary of the alert Description - a full description of the alert, which will always be shown alongside the header (so should not repeat this information).","title":"Service Alerts"},{"location":"realtime/service-alerts/#time-range","text":"The alert will be displayed where appropriate within the given time range. This range should cover the entire time that the alert is useful for the passenger to see. If no time is given, we will display the alert for as long as it is in the feed. If multiple ranges are given, we will display during all of them.","title":"Time Range"},{"location":"realtime/service-alerts/#entity-selector","text":"Entity selector allows you specify exactly which parts of the network this alert affects, so that we can display only the most appropriate alerts to the user. You may include multiple entity selectors for alerts which affect multiple entities. Entities are selected using their GTFS identifiers, and you can select any of the following: Agency - affects the whole network Route - affects the whole route Route type - affects any route of this type. e.g. all subways. Trip - affects a particular trip Stop - affects a particular stop You may include more than one of the fields listed above in one informed_entity . When multiple fields are included in one informed_entity , they should be interpreted as being joined by the AND logical operator. In other words, the alert should only be applied in a context that meets all of the fields provided in an informed_entity . For example, if route_id: \"1\" and stop_id: \"5\" are both included in one informed_entity , then the alert should apply only to route 1 at stop 5. It should NOT be applied to any other stop on route 1, and it should NOT be applied to any other route at stop 5. If you would like to represent an alert that affects more than one entity (e.g. an alert for both route 1 and stop 5) , you should add multiple informed_entity to your alert , with each of them applying to the affected entity (e.g. one informed_entity that includes route 1 and another informed_entity that includes stop 5).","title":"Entity Selector"},{"location":"realtime/service-alerts/#cause","text":"What is the cause of this alert? You may specify one of the following: Unknown cause Other cause (not represented by any of these options) Technical problem Strike Demonstration Accident Holiday Weather Maintenance Construction Police activity Medical emergency","title":"Cause"},{"location":"realtime/service-alerts/#effect","text":"What effect does this problem have on the specified entity? You may specify one of the following: No service Reduced service Significant delays (insignificant delays should only be provided through Trip updates ). Detour Additional service Modified service: Operations are different from what the rider would normally expect. An example is an alert that reminds riders of an upcoming holiday schedule that is different from normal service on that day of the week. Stop moved Other effect (not represented by any of these options) Unknown effect No effect: The alert provides information to riders but does not affect operations. Examples include advertising public meetings and soliciting feedback via surveys. Accessibility issue: The alert provides information about accessibility issues that affects step-free access. Examples include an out of service elevator or movable ramps.","title":"Effect"},{"location":"realtime/trip-updates/","text":"Trip Updates \u00b6 Trip updates represent fluctuations in the timetable. We would expect to receive trip updates for all trips you have scheduled that are realtime-capable. These updates would give a predicted arrival or departure time for stops along the route. Trip updates can also provide for more complex scenarios where trips are canceled or added to the schedule, or even re-routed. Reminder: In GTFS , a trip is a sequence of two of more stops occurring at a specific time. There should be at most one trip update for each scheduled trip. In case there is no trip update for a scheduled trip, it will be concluded that no realtime data is available for the trip. The data consumer should not assume that the trip is running on time. If a vehicle is serving multiple trips within the same block (for more information about trips and blocks, please refer to GTFS trips.txt ): * the feed should include a TripUpdate for the trip currently being served by the vehicle. Producers are encouraged to include TripUpdates for one or more trips after the current trip in this vehicle's block if the producer is confident in the quality of the predictions for these future trip(s). Including multiple TripUpdates for the same vehicle avoids prediction \"pop-in\" for riders as the vehicle transitions from one trip to another and also gives riders advance notice of delays that impact downstream trips (e.g., when the known delay exceeds planned layover times between trips). * the respective TripUpdate entities are not required to be added to the feed in the same order that they are scheduled in the block. For example, if there are trips with trip_ids 1, 2, and 3 that all belong to one block, and the vehicle travels trip 1, then trip 2, and then trip 3, the trip_update entities may appear in any order - for example, adding trip 2, then trip 1, and then trip 3 is allowed. Stop Time Updates \u00b6 A trip update consists of one or more updates to vehicle stop times, which are referred to as StopTimeUpdates . These can be supplied for past and future stop times. You are allowed, but not required, to drop past stop times. Producers should not drop a past StopTimeUpdate if it refers to a stop with a scheduled arrival time in the future for the given trip (i.e. the vehicle has passed the stop ahead of schedule), as otherwise it will be concluded that there is no update for this stop. For example, if the following data appears in the GTFS-rt feed: Stop 4 \u2013 Predicted at 10:18am (scheduled at 10:20am \u2013 2 min early) Stop 5 \u2013 Predicted at 10:30am (scheduled at 10:30am \u2013 on time) ...the prediction for Stop 4 cannot be dropped from the feed until 10:21am, even if the bus actually passes the stop at 10:18am. If the StopTimeUpdate for Stop 4 was dropped from the feed at 10:18am or 10:19am, and the scheduled arrival time is 10:20am, then the consumer should assume that no real-time information exists for Stop 4 at that time, and schedule data from GTFS should be used. Each StopTimeUpdate is linked to a stop. Ordinarily this can be done using either a GTFS stop_sequence or a GTFS stop_id. However, in the case you are providing an update for a trip without a GTFS trip_id, you must specify stop_id as stop_sequence has no value. The stop_id must still reference a stop_id in GTFS. If the same stop_id is visited more than once in a trip, then stop_sequence should be provided in all StopTimeUpdates for that stop_id on that trip. The update can provide a exact timing for arrival and/or departure at a stop in StopTimeUpdates using StopTimeEvent . This should contain either an absolute time or a delay (i.e. an offset from the scheduled time in seconds). Delay can only be used in case the trip update refers to a scheduled GTFS trip, as opposed to a frequency-based trip. In this case, time should be equal to scheduled time + delay. You may also specify uncertainty of the prediction along with StopTimeEvent , which is discussed in more detail in section Uncertainty further down the page. For each StopTimeUpdate , the default schedule relationship is scheduled . (Note that this is different from the schedule relationship for the trip). You may change this to skipped if the stop will not be stopped at, or no data if you only have realtime data for some of the trip. Updates should be sorted by stop_sequence (or stop_ids in the order they occur in the trip). If one or more stops are missing along the trip the delay from the update (or, if only time is provided in the update, a delay computed by comparing the time against the GTFS schedule time) is propagated to all subsequent stops. This means that updating a stop time for a certain stop will change all subsequent stops in the absence of any other information. Note that updates with a schedule relationship of SKIPPED will not stop delay propagation, but updates with schedule relationships of SCHEDULED (also the default value if schedule relationship is not provided) or NO_DATA will. Example 1 For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure delay of 0 ( StopTimeEvents ) for stop_sequence of the current stop means that the trip is exactly on time. Example 2 For the same trip instance, three StopTimeUpdates are provided: delay of 300 seconds for stop_sequence 3 delay of 60 seconds for stop_sequence 8 ScheduleRelationship of NO_DATA for stop_sequence 10 This will be interpreted as: stop_sequences 1,2 have unknown delay. stop_sequences 3,4,5,6,7 have delay of 300 seconds. stop_sequences 8,9 have delay of 60 seconds. stop_sequences 10,..,20 have unknown delay. Trip Descriptor \u00b6 The information provided by the trip descriptor depends on the schedule relationship of trip you are updating. There are a number of options for you to set: Value Comment Scheduled This trip is running according to a GTFS schedule, or is close enough to still be associated with it. Added This trip was not scheduled and has been added. For example, to cope with demand, or replace a broken down vehicle. Unscheduled This trip is running and is never associated with a schedule. For example, if there is no schedule and the buses run on a shuttle service. Canceled This trip was scheduled, but is now removed. Duplicated This new trip is a copy of an existing trip in static GTFS except for the service start date and time. The new trip will run at the service date and time specified in TripProperties. In most cases, you should provide the trip_id of the scheduled trip in GTFS that this update relates to. Systems with repeated trip_ids \u00b6 For systems using repeated trip_ids, for example trips modeled using frequencies.txt, that is frequency-based trips, the trip_id is not in itself a unique identifier of a single journey, as it lacks a specific time component. In order to uniquely identify such trips within a TripDescriptor, a triple of identifiers must be provided: trip_id start_time start_date start_time should be first published, and any subsequent feed updates should use that same start_time when referring to the same journey. StopTimeUpdates should be used to indicate adjustments; start_time does not have to be precisely the departure time from the first station, although it should be pretty close to that time. For example, let\u2019s say we decide at 10:00, May, 25th 2015, that a trip with trip_id=T will start at start_time=10:10:00, and provide this information via realtime feed at 10:01. By 10:05 we suddenly know that the trip will start not at 10:10 but at 10:13. In our new realtime feed we can still identify this trip as (T, 2015-05-25, 10:10:00) but provide a StopTimeUpdate with departure from first stop at 10:13:00. Alternative trip matching \u00b6 Trips which are not frequency based may also be uniquely identified by a TripDescriptor including the combination of: route_id direction_id start_time start_date where start_time is the scheduled start time as defined in the static schedule, as long as the combination of ids provided resolves to a unique trip. Uncertainty \u00b6 Uncertainty applies to both the time and the delay value of a StopTimeUpdate . The uncertainty roughly specifies the expected error in true delay as an integer in seconds (but note, the precise statistical meaning is not defined yet). It's possible for the uncertainty to be 0, for example for trains that are driven under computer timing control. As an example a long-distance bus that has an estimated delay of 15 minutes arriving to its next stop within a 4 minute window of error (that is +2 / -2 minutes) will have an Uncertainty value of 240.","title":"Trip Updates"},{"location":"realtime/trip-updates/#trip-updates","text":"Trip updates represent fluctuations in the timetable. We would expect to receive trip updates for all trips you have scheduled that are realtime-capable. These updates would give a predicted arrival or departure time for stops along the route. Trip updates can also provide for more complex scenarios where trips are canceled or added to the schedule, or even re-routed. Reminder: In GTFS , a trip is a sequence of two of more stops occurring at a specific time. There should be at most one trip update for each scheduled trip. In case there is no trip update for a scheduled trip, it will be concluded that no realtime data is available for the trip. The data consumer should not assume that the trip is running on time. If a vehicle is serving multiple trips within the same block (for more information about trips and blocks, please refer to GTFS trips.txt ): * the feed should include a TripUpdate for the trip currently being served by the vehicle. Producers are encouraged to include TripUpdates for one or more trips after the current trip in this vehicle's block if the producer is confident in the quality of the predictions for these future trip(s). Including multiple TripUpdates for the same vehicle avoids prediction \"pop-in\" for riders as the vehicle transitions from one trip to another and also gives riders advance notice of delays that impact downstream trips (e.g., when the known delay exceeds planned layover times between trips). * the respective TripUpdate entities are not required to be added to the feed in the same order that they are scheduled in the block. For example, if there are trips with trip_ids 1, 2, and 3 that all belong to one block, and the vehicle travels trip 1, then trip 2, and then trip 3, the trip_update entities may appear in any order - for example, adding trip 2, then trip 1, and then trip 3 is allowed.","title":"Trip Updates"},{"location":"realtime/trip-updates/#stop-time-updates","text":"A trip update consists of one or more updates to vehicle stop times, which are referred to as StopTimeUpdates . These can be supplied for past and future stop times. You are allowed, but not required, to drop past stop times. Producers should not drop a past StopTimeUpdate if it refers to a stop with a scheduled arrival time in the future for the given trip (i.e. the vehicle has passed the stop ahead of schedule), as otherwise it will be concluded that there is no update for this stop. For example, if the following data appears in the GTFS-rt feed: Stop 4 \u2013 Predicted at 10:18am (scheduled at 10:20am \u2013 2 min early) Stop 5 \u2013 Predicted at 10:30am (scheduled at 10:30am \u2013 on time) ...the prediction for Stop 4 cannot be dropped from the feed until 10:21am, even if the bus actually passes the stop at 10:18am. If the StopTimeUpdate for Stop 4 was dropped from the feed at 10:18am or 10:19am, and the scheduled arrival time is 10:20am, then the consumer should assume that no real-time information exists for Stop 4 at that time, and schedule data from GTFS should be used. Each StopTimeUpdate is linked to a stop. Ordinarily this can be done using either a GTFS stop_sequence or a GTFS stop_id. However, in the case you are providing an update for a trip without a GTFS trip_id, you must specify stop_id as stop_sequence has no value. The stop_id must still reference a stop_id in GTFS. If the same stop_id is visited more than once in a trip, then stop_sequence should be provided in all StopTimeUpdates for that stop_id on that trip. The update can provide a exact timing for arrival and/or departure at a stop in StopTimeUpdates using StopTimeEvent . This should contain either an absolute time or a delay (i.e. an offset from the scheduled time in seconds). Delay can only be used in case the trip update refers to a scheduled GTFS trip, as opposed to a frequency-based trip. In this case, time should be equal to scheduled time + delay. You may also specify uncertainty of the prediction along with StopTimeEvent , which is discussed in more detail in section Uncertainty further down the page. For each StopTimeUpdate , the default schedule relationship is scheduled . (Note that this is different from the schedule relationship for the trip). You may change this to skipped if the stop will not be stopped at, or no data if you only have realtime data for some of the trip. Updates should be sorted by stop_sequence (or stop_ids in the order they occur in the trip). If one or more stops are missing along the trip the delay from the update (or, if only time is provided in the update, a delay computed by comparing the time against the GTFS schedule time) is propagated to all subsequent stops. This means that updating a stop time for a certain stop will change all subsequent stops in the absence of any other information. Note that updates with a schedule relationship of SKIPPED will not stop delay propagation, but updates with schedule relationships of SCHEDULED (also the default value if schedule relationship is not provided) or NO_DATA will. Example 1 For a trip with 20 stops, a StopTimeUpdate with arrival delay and departure delay of 0 ( StopTimeEvents ) for stop_sequence of the current stop means that the trip is exactly on time. Example 2 For the same trip instance, three StopTimeUpdates are provided: delay of 300 seconds for stop_sequence 3 delay of 60 seconds for stop_sequence 8 ScheduleRelationship of NO_DATA for stop_sequence 10 This will be interpreted as: stop_sequences 1,2 have unknown delay. stop_sequences 3,4,5,6,7 have delay of 300 seconds. stop_sequences 8,9 have delay of 60 seconds. stop_sequences 10,..,20 have unknown delay.","title":"Stop Time Updates"},{"location":"realtime/trip-updates/#trip-descriptor","text":"The information provided by the trip descriptor depends on the schedule relationship of trip you are updating. There are a number of options for you to set: Value Comment Scheduled This trip is running according to a GTFS schedule, or is close enough to still be associated with it. Added This trip was not scheduled and has been added. For example, to cope with demand, or replace a broken down vehicle. Unscheduled This trip is running and is never associated with a schedule. For example, if there is no schedule and the buses run on a shuttle service. Canceled This trip was scheduled, but is now removed. Duplicated This new trip is a copy of an existing trip in static GTFS except for the service start date and time. The new trip will run at the service date and time specified in TripProperties. In most cases, you should provide the trip_id of the scheduled trip in GTFS that this update relates to.","title":"Trip Descriptor"},{"location":"realtime/trip-updates/#systems-with-repeated-trip_ids","text":"For systems using repeated trip_ids, for example trips modeled using frequencies.txt, that is frequency-based trips, the trip_id is not in itself a unique identifier of a single journey, as it lacks a specific time component. In order to uniquely identify such trips within a TripDescriptor, a triple of identifiers must be provided: trip_id start_time start_date start_time should be first published, and any subsequent feed updates should use that same start_time when referring to the same journey. StopTimeUpdates should be used to indicate adjustments; start_time does not have to be precisely the departure time from the first station, although it should be pretty close to that time. For example, let\u2019s say we decide at 10:00, May, 25th 2015, that a trip with trip_id=T will start at start_time=10:10:00, and provide this information via realtime feed at 10:01. By 10:05 we suddenly know that the trip will start not at 10:10 but at 10:13. In our new realtime feed we can still identify this trip as (T, 2015-05-25, 10:10:00) but provide a StopTimeUpdate with departure from first stop at 10:13:00.","title":"Systems with repeated trip_ids"},{"location":"realtime/trip-updates/#alternative-trip-matching","text":"Trips which are not frequency based may also be uniquely identified by a TripDescriptor including the combination of: route_id direction_id start_time start_date where start_time is the scheduled start time as defined in the static schedule, as long as the combination of ids provided resolves to a unique trip.","title":"Alternative trip matching"},{"location":"realtime/trip-updates/#uncertainty","text":"Uncertainty applies to both the time and the delay value of a StopTimeUpdate . The uncertainty roughly specifies the expected error in true delay as an integer in seconds (but note, the precise statistical meaning is not defined yet). It's possible for the uncertainty to be 0, for example for trains that are driven under computer timing control. As an example a long-distance bus that has an estimated delay of 15 minutes arriving to its next stop within a 4 minute window of error (that is +2 / -2 minutes) will have an Uncertainty value of 240.","title":"Uncertainty"},{"location":"realtime/vehicle-positions/","text":"Vehicle Positions \u00b6 Vehicle position is used to provide automatically generated information on the location of a vehicle, such as from a GPS device on board. A single vehicle position should be provided for every vehicle that is capable of providing it. The trip that the vehicle is currently serving should be given through a trip descriptor . You can also provide a vehicle descriptor , which specifies a precise physical vehicle that you are providing updates about. Documentation is provided below. A timestamp denoting the time when the position reading was taken can be provided. Note that this is different from the timestamp in the feed header, which is the time that this message was generated by the server. Current passage can also be provided (either as a stop_sequence or stop_id ). This is a reference to the stop that the vehicle is either on its way to, or already stopped at. Position \u00b6 Position contains the location data within Vehicle Position. Latitude and longitude are required, the other fields are optional. These types of data are: Latitude - degrees North, in the WGS-84 coordinate system Longitude - degrees East, in the WGS-84 coordinate system Bearing - direction that the vehicle is facing Odometer - the distance that the vehicle has travelled Speed - momentary speed measured by the vehicle, in meters per second Congestion Level \u00b6 Vehicle position also allows the agency to specify the congestion level that the vehicle is currently experiencing. Congestion can be classed under the following categories: Unknown congestion level Running smoothly Stop and go Congestion Severe congestion It is up to the agency to classify what you class as each type of congestion. Our guidance is that severe congestion is only used in situations where the traffic is so congested that people are leaving their cars. Occupancy status \u00b6 Vehicle position also allows the agency to specify the degree of passenger occupancy for the vehicle. Occupancy status can be classed under the following categories: Empty Many seats available Few seats available Standing room only Crushed standing room only Full Not accepting passengers This field is still experimental , and subject to change. It may be formally adopted in the future. VehicleStopStatus \u00b6 Vehicle stop status gives more meaning to the status of a vehicle in relation with a stop that it is currently approaching or is at. It can be set to any of these values. Incoming at - the vehicle is about to arrive at the referenced stop Stopped at - the vehicle is stopped at the referenced stop In transit to - the referenced stop is the next stop for the vehicle - default Vehicle Descriptor \u00b6 Vehicle descriptor describes a precise physical vehicle and can contain any of the following attributes: ID - internal system of identification for the vehicle. Should be unique to the vehicle Label - a user visible label - for example the name of a train License plate - the actual license plate of the vehicle","title":"Vehicle Positions"},{"location":"realtime/vehicle-positions/#vehicle-positions","text":"Vehicle position is used to provide automatically generated information on the location of a vehicle, such as from a GPS device on board. A single vehicle position should be provided for every vehicle that is capable of providing it. The trip that the vehicle is currently serving should be given through a trip descriptor . You can also provide a vehicle descriptor , which specifies a precise physical vehicle that you are providing updates about. Documentation is provided below. A timestamp denoting the time when the position reading was taken can be provided. Note that this is different from the timestamp in the feed header, which is the time that this message was generated by the server. Current passage can also be provided (either as a stop_sequence or stop_id ). This is a reference to the stop that the vehicle is either on its way to, or already stopped at.","title":"Vehicle Positions"},{"location":"realtime/vehicle-positions/#position","text":"Position contains the location data within Vehicle Position. Latitude and longitude are required, the other fields are optional. These types of data are: Latitude - degrees North, in the WGS-84 coordinate system Longitude - degrees East, in the WGS-84 coordinate system Bearing - direction that the vehicle is facing Odometer - the distance that the vehicle has travelled Speed - momentary speed measured by the vehicle, in meters per second","title":"Position"},{"location":"realtime/vehicle-positions/#congestion-level","text":"Vehicle position also allows the agency to specify the congestion level that the vehicle is currently experiencing. Congestion can be classed under the following categories: Unknown congestion level Running smoothly Stop and go Congestion Severe congestion It is up to the agency to classify what you class as each type of congestion. Our guidance is that severe congestion is only used in situations where the traffic is so congested that people are leaving their cars.","title":"Congestion Level"},{"location":"realtime/vehicle-positions/#occupancy-status","text":"Vehicle position also allows the agency to specify the degree of passenger occupancy for the vehicle. Occupancy status can be classed under the following categories: Empty Many seats available Few seats available Standing room only Crushed standing room only Full Not accepting passengers This field is still experimental , and subject to change. It may be formally adopted in the future.","title":"Occupancy status"},{"location":"realtime/vehicle-positions/#vehiclestopstatus","text":"Vehicle stop status gives more meaning to the status of a vehicle in relation with a stop that it is currently approaching or is at. It can be set to any of these values. Incoming at - the vehicle is about to arrive at the referenced stop Stopped at - the vehicle is stopped at the referenced stop In transit to - the referenced stop is the next stop for the vehicle - default","title":"VehicleStopStatus"},{"location":"realtime/vehicle-positions/#vehicle-descriptor","text":"Vehicle descriptor describes a precise physical vehicle and can contain any of the following attributes: ID - internal system of identification for the vehicle. Should be unique to the vehicle Label - a user visible label - for example the name of a train License plate - the actual license plate of the vehicle","title":"Vehicle Descriptor"},{"location":"realtime/changes/","text":"GTFS Realtime Changes \u00b6 The GTFS Realtime Specification is not set in stone. Instead, it is an open specification developed and maintained by the community of transit agencies, developers, and other stakeholders who use GTFS Realtime. It is expected that this community of producers and consumers of GTFS Realtime data will have proposals for extending the spec to enable new capabilities. To help manage that process, the following procedures and guidelines have been established. The official specification, reference and documentation are written in English. If a translation to a different language differs from the English original, the latter takes precedence. All communication is performed in English. Specification Amendment Process Guiding Principles Revision History Realtime Extensions","title":"GTFS Realtime Changes"},{"location":"realtime/changes/#gtfs-realtime-changes","text":"The GTFS Realtime Specification is not set in stone. Instead, it is an open specification developed and maintained by the community of transit agencies, developers, and other stakeholders who use GTFS Realtime. It is expected that this community of producers and consumers of GTFS Realtime data will have proposals for extending the spec to enable new capabilities. To help manage that process, the following procedures and guidelines have been established. The official specification, reference and documentation are written in English. If a translation to a different language differs from the English original, the latter takes precedence. All communication is performed in English. Specification Amendment Process Guiding Principles Revision History Realtime Extensions","title":"GTFS Realtime Changes"},{"location":"realtime/examples/","text":"GTFS Realtime Examples \u00b6 Feed Examples Code Examples","title":"GTFS Realtime Examples"},{"location":"realtime/examples/#gtfs-realtime-examples","text":"Feed Examples Code Examples","title":"GTFS Realtime Examples"},{"location":"realtime/feed-entities/","text":"Feed Entities \u00b6 GTFS Realtime supports three distinct types of realtime data, that can be combined witin a single realtime feed. Summaries are given below, with full documentation given in the relevant section. Trip Updates \u00b6 \"Bus X is delayed by 5 minutes\" \u00b6 Trip updates represent fluctuations in the timetable. We would expect to receive trip updates for all trips you have scheduled that are realtime-capable. These updates would give a predicted arrival or departure for stops along the route. Trip updates can also provide for more complex scenarios where trips are canceled, added to the schedule, or even re-routed. More about Trip Updates... Service Alerts \u00b6 \"Station Y is closed due to construction\" \u00b6 Service alerts represent higher level problems with a particular entity and are generally in the form of a textual description of the disruption. They could represent problems with: Stations Lines The whole network etc. A service alert will usually consist of some text which will describe the problem, and we also allow for URLs for more information as well as more structured information to help us understand who this service alert affects. More about Service Alerts... Vehicle Positions \u00b6 \"This bus is at position X at time Y\" \u00b6 Vehicle position represents a few basic pieces of information about a particular vehicle on the network. Most important are the latitude and longitude the vehicle is at, but we can also use data on current speed and odometer readings from the vehicle. More about Vehicle Position updates... Historical remark on feed types \u00b6 Early versions of GTFS Realtime Specification required each feed to only contain single type of entities. An example tool to convert from merged to the feed-per-type schema is located at https://github.com/bliksemlabs/gtfsrt-examples/blob/master/split_by_entitytype.py","title":"Feed Entities"},{"location":"realtime/feed-entities/#feed-entities","text":"GTFS Realtime supports three distinct types of realtime data, that can be combined witin a single realtime feed. Summaries are given below, with full documentation given in the relevant section.","title":"Feed Entities"},{"location":"realtime/feed-entities/#trip-updates","text":"","title":"Trip Updates"},{"location":"realtime/feed-entities/#bus-x-is-delayed-by-5-minutes","text":"Trip updates represent fluctuations in the timetable. We would expect to receive trip updates for all trips you have scheduled that are realtime-capable. These updates would give a predicted arrival or departure for stops along the route. Trip updates can also provide for more complex scenarios where trips are canceled, added to the schedule, or even re-routed. More about Trip Updates...","title":"\"Bus X is delayed by 5 minutes\""},{"location":"realtime/feed-entities/#service-alerts","text":"","title":"Service Alerts"},{"location":"realtime/feed-entities/#station-y-is-closed-due-to-construction","text":"Service alerts represent higher level problems with a particular entity and are generally in the form of a textual description of the disruption. They could represent problems with: Stations Lines The whole network etc. A service alert will usually consist of some text which will describe the problem, and we also allow for URLs for more information as well as more structured information to help us understand who this service alert affects. More about Service Alerts...","title":"\"Station Y is closed due to construction\""},{"location":"realtime/feed-entities/#vehicle-positions","text":"","title":"Vehicle Positions"},{"location":"realtime/feed-entities/#this-bus-is-at-position-x-at-time-y","text":"Vehicle position represents a few basic pieces of information about a particular vehicle on the network. Most important are the latitude and longitude the vehicle is at, but we can also use data on current speed and odometer readings from the vehicle. More about Vehicle Position updates...","title":"\"This bus is at position X at time Y\""},{"location":"realtime/feed-entities/#historical-remark-on-feed-types","text":"Early versions of GTFS Realtime Specification required each feed to only contain single type of entities. An example tool to convert from merged to the feed-per-type schema is located at https://github.com/bliksemlabs/gtfsrt-examples/blob/master/split_by_entitytype.py","title":"Historical remark on feed types"},{"location":"resources/","text":"Resources \u00b6 Community list of transit APIs, apps, datasets, research, and software \u00b6 Have something to add or change? Open a pull request or issue at CUTR-at-USF/awesome-transit . Table of Contents \u00b6 Getting started Community Data Software for Creating APIs Agency Tools Hardware Apps Web Apps (open source) Web Apps (closed source) Native Apps (open source) Native Apps (closed source) SDKs Visualizations GTFS GTFS Libraries GTFS Converters GTFS Data Collection and Maintenance Tools GTFS Analysis Tools GTFS Timetable Publishing Tools GTFS Validators GTFS Realtime GTFS Realtime Libraries & Demo Apps GTFS Realtime Validators GTFS Realtime (and Other Real-time API) Archival Tools GTFS Realtime Convertors GTFS Realtime Utilities SIRI Other Multimodal Data Formats Other Resources About \u00b6 Originally created by Luqmaan Dawoodjee , now maintained by the Center for Urban Transportation Research at the University of South Florida . This list is intended as a community resource for informational use only - listing of a project/product does not imply endorsement. License \u00b6 To the extent possible under law, Luqmaan Dawoodjee and the Center for Urban Transportation Research at the University of South Florida have waived all copyright and related or neighboring rights to this work.","title":"Resources"},{"location":"resources/#resources","text":"","title":"Resources"},{"location":"resources/#community-list-of-transit-apis-apps-datasets-research-and-software","text":"Have something to add or change? Open a pull request or issue at CUTR-at-USF/awesome-transit .","title":"Community list of transit APIs, apps, datasets, research, and software"},{"location":"resources/#table-of-contents","text":"Getting started Community Data Software for Creating APIs Agency Tools Hardware Apps Web Apps (open source) Web Apps (closed source) Native Apps (open source) Native Apps (closed source) SDKs Visualizations GTFS GTFS Libraries GTFS Converters GTFS Data Collection and Maintenance Tools GTFS Analysis Tools GTFS Timetable Publishing Tools GTFS Validators GTFS Realtime GTFS Realtime Libraries & Demo Apps GTFS Realtime Validators GTFS Realtime (and Other Real-time API) Archival Tools GTFS Realtime Convertors GTFS Realtime Utilities SIRI Other Multimodal Data Formats Other Resources","title":"Table of Contents"},{"location":"resources/#about","text":"Originally created by Luqmaan Dawoodjee , now maintained by the Center for Urban Transportation Research at the University of South Florida . This list is intended as a community resource for informational use only - listing of a project/product does not imply endorsement.","title":"About"},{"location":"resources/#license","text":"To the extent possible under law, Luqmaan Dawoodjee and the Center for Urban Transportation Research at the University of South Florida have waived all copyright and related or neighboring rights to this work.","title":"License"},{"location":"resources/agency-tools/","text":"Agency Tools \u00b6 Tools for transit agencies. See also GTFS Data Collection and Maintenance Tools for tools specific to GTFS. Remix - A webapp that lets transit agencies easily plan routes. AC Transit RestroomFinder - Pinpoints the nearest authorized restroom for bus operator and field staff, using GPS and on-screen map. AC Transit Training and Education Department (TED) application - This application supports the District's training operations for transportation and maintenance employees, primarily in the positions of Bus Operators and Heavy Duty Coach Mechanics (Apprentice and Journey), although the system supports new courses and apprenticeship programs. AC Transit Customer Relations application (CusRel) - Public transit ticketing system for customer issues and feedback with: inter-departmental routing with notifications, department/person assigments, simple workflow, ticket searching, pre-canned reports, daily reminders and more. TransAM - An open-source asset management platform for public transportation agencies. Open-source on Github . RidePilot - An open-source Computer Aided Scheduling and Dispatch (CASD) software system to meet the needs of small scale human service transportation agencies (for more info see Cambridge Systematics's marketing site ). TNExT - Transit Network Explorer Tool (TNExT) is a web-based software tool developed for the visualization, analysis, and reporting of regional and statewide transit networks in the state of Oregon. Route Trends ( webapp , GitHub ) - An R Shiny app to ingest ridership time series, and return seasonal, trend, and residual components according to STL methodology and forecasts including uncertainty based on those components. Sponsored by Metro Transit (Minneapolis-St. Paul). TBEST - TBEST (Transit Boardings Estimation and Simulation Tool) is an effort to develop a multi-faceted GIS-based modeling, planning and analysis tool which integrates socio-economic, land use, and transit network data into a platform for scenario-based transit ridership estimation and analysis. Funded by the Florida Department of Transportation. Free to use but not open-source.","title":"Agency Tools"},{"location":"resources/agency-tools/#agency-tools","text":"Tools for transit agencies. See also GTFS Data Collection and Maintenance Tools for tools specific to GTFS. Remix - A webapp that lets transit agencies easily plan routes. AC Transit RestroomFinder - Pinpoints the nearest authorized restroom for bus operator and field staff, using GPS and on-screen map. AC Transit Training and Education Department (TED) application - This application supports the District's training operations for transportation and maintenance employees, primarily in the positions of Bus Operators and Heavy Duty Coach Mechanics (Apprentice and Journey), although the system supports new courses and apprenticeship programs. AC Transit Customer Relations application (CusRel) - Public transit ticketing system for customer issues and feedback with: inter-departmental routing with notifications, department/person assigments, simple workflow, ticket searching, pre-canned reports, daily reminders and more. TransAM - An open-source asset management platform for public transportation agencies. Open-source on Github . RidePilot - An open-source Computer Aided Scheduling and Dispatch (CASD) software system to meet the needs of small scale human service transportation agencies (for more info see Cambridge Systematics's marketing site ). TNExT - Transit Network Explorer Tool (TNExT) is a web-based software tool developed for the visualization, analysis, and reporting of regional and statewide transit networks in the state of Oregon. Route Trends ( webapp , GitHub ) - An R Shiny app to ingest ridership time series, and return seasonal, trend, and residual components according to STL methodology and forecasts including uncertainty based on those components. Sponsored by Metro Transit (Minneapolis-St. Paul). TBEST - TBEST (Transit Boardings Estimation and Simulation Tool) is an effort to develop a multi-faceted GIS-based modeling, planning and analysis tool which integrates socio-economic, land use, and transit network data into a platform for scenario-based transit ridership estimation and analysis. Funded by the Florida Department of Transportation. Free to use but not open-source.","title":"Agency Tools"},{"location":"resources/apps/","text":"Apps \u00b6 Apps people use when taking transit. Web Apps (open source) \u00b6 Instabus - Realtime map of Austin's (CapMetro) public transit. Has no server/backend dependency at all and runs completely on GitHub pages. OpenTripPlanner Client GWT - A Google Web Toolkit-based web interface for OpenTripPlanner OpenTripPlanner.js - A Javascript-based client for OpenTripPlanner (no longer under development) OTP-UI React Component Library - React Javascript component library, which can be used to build trip planner webapps. See the Storybook for a demo. GTFS-realtime Alerts Producer Web Application - A Java-based web application for producing GTFS-realtime Service Alerts. HRT BUS Web app - HRT Bus API publishes real time bus data from Hampton Roads Transit through an application programming interface for developers to make apps from it. Transit-Map - Web app that animates vehicles (markers) on a map using the public transport timetables to interpolate their positions along the routes (polylines). Transitive.js - Creates a customizable web map layer of transit routes using Leaflet or D3. Google I/O Transport Tracker - Shows shuttle arrival times for Google I/O conference, based on the open-source transport-tracker project . Note: To implement this yourself, you need a Google Maps APIs Premium Plan license . 1-Click - A virtual \u201ctrip aggregator\u201d that assembles information on a wide variety of available modes: public transit, private, rail, rideshare, carpool, volunteer, paratransit, and walking and biking. Open-source on GitHub . Bustime - Public transport real-time monitoring with WebSocket updates. Open-source on GitHub . Transit Tracker - Realtime vehicle position for Greater Montreal & Toronto, Canada GTFS Builder - A free web-based application to help you create GTFS files. Maintained by the National Rural Transit Assistance Program (RTAP). Dede - An independent and universal passenger information system (PIS) mapping realtime movement. A message feed with Vehicle Position entities in the GTFS-Realtime format or the Dede app can be used as data source. MBTA tile-server - Scripts to create a Docker container that encapsulates all the elements necessary to develop map tiles for use on MBTA.com Tiramisu Transit - An adaptive mobile transit app that shows real-time bus arrival information developed and deployed by Carnegie Mellon University. No longer maintained. Web Apps (closed source) \u00b6 TransitScreen - Custom realtime displays of all local transportation choices Citylines.co - A collaborative platform for mapping transit systems, with an emphasis on their historical evolution. Bikeshare Map - Status of all worldwide bikeshare stations Bongo - Real-time Transit Tracking for Iowa City, Coralville and the University of Iowa. Combines three disparate transit systems into one UI. Brand New Subway - An interactive transportation planning game that lets players alter the NYC subway system to their heart's content. CityMapper Webapp - Really polished webapp with trip planner and route status for over 30 of cities. YourStop - Mobile friendly web app which consumes GTFS feeds and displays both live and scheduled trips for stops. Launched with MBTA, YRT/Viva and Maryland MTA. DC MetroHero - Realtime vehicle position and arrivals and departure information for the Washington, D.C. region's WMATA Metrorail and Metrobus systems. WebApp, Android, and iOS apps avaliable. Native Apps (open source) \u00b6 OneBusAway Apps - Android (source code) , Fire Phone (source code) , iOS (source code) , Windows Phone (source code) , Windows 8 (source code) , Google Glass GDK (source code) , Alexa skill (source code) OpenTripPlanner Android - An Android app for OpenTripPlanner OpenTripPlanner iOS - An iOS app for OpenTripPlanner opentripplanner-client-library - A Kotlin Multiplatform library for making API requests and parsing responses from an OpenTripPlanner v2 server for trip plans, bike rental info, and server metadata for Android, iOS, and web. Transportr An Android app that uses public-transport-enabler in order to connect to many different transport networks worldwide. Offi Directions - An Android app that provides trip planning, schedules, live departure times, and disruption information for transport authorities in Europe and beyond. Trufi App - A cross-platform Flutter app that uses OpenTripPlanner Dede App - An app making any Android powered phone become an Automatic Vehicle Locating (AVL) device for the Dede passenger information system (PIS). MACS Transit Android App - A bus tracker app for Android devices for the MACS Transit system in Fairbanks, Alaska. Uses RouteMatch APIs. Tiramisu Transit - An adaptive mobile transit app that shows real-time bus arrival information developed and deployed by Carnegie Mellon University. Written using Ionic framework. No longer maintained. Native Apps (closed source) \u00b6 ally Transit CityMapper Moovit TransLoc Rider - Real-time transit maps for over 100 transit systems. Transit Display - Multimodal and real-time transit display software. Ualabee - Community driven trip planner with focus on user interaction, users can report anomalies, upload pictures, edit transit data and chat with other passengers.","title":"Apps"},{"location":"resources/apps/#apps","text":"Apps people use when taking transit.","title":"Apps"},{"location":"resources/apps/#web-apps-open-source","text":"Instabus - Realtime map of Austin's (CapMetro) public transit. Has no server/backend dependency at all and runs completely on GitHub pages. OpenTripPlanner Client GWT - A Google Web Toolkit-based web interface for OpenTripPlanner OpenTripPlanner.js - A Javascript-based client for OpenTripPlanner (no longer under development) OTP-UI React Component Library - React Javascript component library, which can be used to build trip planner webapps. See the Storybook for a demo. GTFS-realtime Alerts Producer Web Application - A Java-based web application for producing GTFS-realtime Service Alerts. HRT BUS Web app - HRT Bus API publishes real time bus data from Hampton Roads Transit through an application programming interface for developers to make apps from it. Transit-Map - Web app that animates vehicles (markers) on a map using the public transport timetables to interpolate their positions along the routes (polylines). Transitive.js - Creates a customizable web map layer of transit routes using Leaflet or D3. Google I/O Transport Tracker - Shows shuttle arrival times for Google I/O conference, based on the open-source transport-tracker project . Note: To implement this yourself, you need a Google Maps APIs Premium Plan license . 1-Click - A virtual \u201ctrip aggregator\u201d that assembles information on a wide variety of available modes: public transit, private, rail, rideshare, carpool, volunteer, paratransit, and walking and biking. Open-source on GitHub . Bustime - Public transport real-time monitoring with WebSocket updates. Open-source on GitHub . Transit Tracker - Realtime vehicle position for Greater Montreal & Toronto, Canada GTFS Builder - A free web-based application to help you create GTFS files. Maintained by the National Rural Transit Assistance Program (RTAP). Dede - An independent and universal passenger information system (PIS) mapping realtime movement. A message feed with Vehicle Position entities in the GTFS-Realtime format or the Dede app can be used as data source. MBTA tile-server - Scripts to create a Docker container that encapsulates all the elements necessary to develop map tiles for use on MBTA.com Tiramisu Transit - An adaptive mobile transit app that shows real-time bus arrival information developed and deployed by Carnegie Mellon University. No longer maintained.","title":"Web Apps (open source)"},{"location":"resources/apps/#web-apps-closed-source","text":"TransitScreen - Custom realtime displays of all local transportation choices Citylines.co - A collaborative platform for mapping transit systems, with an emphasis on their historical evolution. Bikeshare Map - Status of all worldwide bikeshare stations Bongo - Real-time Transit Tracking for Iowa City, Coralville and the University of Iowa. Combines three disparate transit systems into one UI. Brand New Subway - An interactive transportation planning game that lets players alter the NYC subway system to their heart's content. CityMapper Webapp - Really polished webapp with trip planner and route status for over 30 of cities. YourStop - Mobile friendly web app which consumes GTFS feeds and displays both live and scheduled trips for stops. Launched with MBTA, YRT/Viva and Maryland MTA. DC MetroHero - Realtime vehicle position and arrivals and departure information for the Washington, D.C. region's WMATA Metrorail and Metrobus systems. WebApp, Android, and iOS apps avaliable.","title":"Web Apps (closed source)"},{"location":"resources/apps/#native-apps-open-source","text":"OneBusAway Apps - Android (source code) , Fire Phone (source code) , iOS (source code) , Windows Phone (source code) , Windows 8 (source code) , Google Glass GDK (source code) , Alexa skill (source code) OpenTripPlanner Android - An Android app for OpenTripPlanner OpenTripPlanner iOS - An iOS app for OpenTripPlanner opentripplanner-client-library - A Kotlin Multiplatform library for making API requests and parsing responses from an OpenTripPlanner v2 server for trip plans, bike rental info, and server metadata for Android, iOS, and web. Transportr An Android app that uses public-transport-enabler in order to connect to many different transport networks worldwide. Offi Directions - An Android app that provides trip planning, schedules, live departure times, and disruption information for transport authorities in Europe and beyond. Trufi App - A cross-platform Flutter app that uses OpenTripPlanner Dede App - An app making any Android powered phone become an Automatic Vehicle Locating (AVL) device for the Dede passenger information system (PIS). MACS Transit Android App - A bus tracker app for Android devices for the MACS Transit system in Fairbanks, Alaska. Uses RouteMatch APIs. Tiramisu Transit - An adaptive mobile transit app that shows real-time bus arrival information developed and deployed by Carnegie Mellon University. Written using Ionic framework. No longer maintained.","title":"Native Apps (open source)"},{"location":"resources/apps/#native-apps-closed-source","text":"ally Transit CityMapper Moovit TransLoc Rider - Real-time transit maps for over 100 transit systems. Transit Display - Multimodal and real-time transit display software. Ualabee - Community driven trip planner with focus on user interaction, users can report anomalies, upload pictures, edit transit data and chat with other passengers.","title":"Native Apps (closed source)"},{"location":"resources/community/","text":"Community \u00b6 Places to ask questions and find other community resources. German Open Transport Meetup - You can participate in a biweekly meetup of the German-speaking open transport community. OpenTripPlanner Community OpenTripPlanner User mailing list OpenTripPlanner Developers mailing list TransitWiki - A community wiki for transit planners. Like this repo, but better. MobilityData Slack chat Transit Developers mailing list OneBusAway OneBusAway User mailing list OneBusAway Developers mailing list OneBusAway API mailing list OneBusAway Slack chat Transit Techies NYC - NYC-based meetup for those interested in this repo. Speaker list includes many contributors to this repo.","title":"Community"},{"location":"resources/community/#community","text":"Places to ask questions and find other community resources. German Open Transport Meetup - You can participate in a biweekly meetup of the German-speaking open transport community. OpenTripPlanner Community OpenTripPlanner User mailing list OpenTripPlanner Developers mailing list TransitWiki - A community wiki for transit planners. Like this repo, but better. MobilityData Slack chat Transit Developers mailing list OneBusAway OneBusAway User mailing list OneBusAway Developers mailing list OneBusAway API mailing list OneBusAway Slack chat Transit Techies NYC - NYC-based meetup for those interested in this repo. Speaker list includes many contributors to this repo.","title":"Community"},{"location":"resources/data/","text":"Data \u00b6 Places to access collections of GTFS and other transit and multimodal data 3rd party GTFS URL directories \u00b6 ~~GTFS Data Exchange~~ (Deprecated) - Formerly the definitive directory of GTFS feed URLs. Shutdown in 2016. But 93 GB of data from 2008 to 2016 is available upon request. ~~OpenMobilityData~~ (Deprecated) - List of GTFS and GTFS-RT feeds. Archives and validates the GTFS feeds and allows you to preview both GTFS and GTFS-RT through the browser. Formerly TransitFeeds.com. MobilityData announced it is end-of-life as of early 2022 with a shutdown date to be determined. The Mobility Database - JSON and CSV files on GitHub that is a repository of 1300+ mobility datasets across the world. Contains contents of OpenMobilityData/TransitFeeds.com. Transitland - Community editable list of many transit agency GTFS datasets. Also provides an API to access the data as JSON/GeoJSON and a playground to try out the data. Transit agency data archives \u00b6 CapMetrics - Historical vehicle locations for Austin's transit agency (CapMetro). Data is collected by capmetricsd , a Go daemon. National government datasets \u00b6 National Transit Database (USA) - Information and statistics on the transit systems of the United States, run by the Federal Transit Administration. Transport (France) - GTFS datasets for French transit systems. European long-distance transport operators (EU) (Unofficial) - Unofficial list of available API endpoints, GTFS feeds and client libraries Proprietary (non-standard) vendor APIs \u00b6 Transport API - REST API for aggregated transit data for the United Kingdom. Fee-based access. TransLoc OpenAPI - REST API for real-time vehicle, route, stop, and arrival data for over 60 transit systems in the United States that have purchased TransLoc's AVL hardware and software. NextBus API - REST API for real-time vehicle, route, stop, and arrival data for agencies that have puchased NextBus's hardware and/or software. Navitia.io - REST API for journey planning, stop schedules, isocrhons and lot more on US and EU. Navitia is the opensource engine behind the live API. CityBikes - REST API for aggregated bikeshare data from around the world. Powered by pyBikes . HAFAS \u2013 Propriety public transport management software by HaCon ( list of endpoints ) Citymapper API - REST API for transit journey planning, realtime transit data and walk, cycle, scooter travel times. Crowdsourced transit data \u00b6 Citylines.co - A collaborative platform for mapping transit systems, with an emphasis on their historical evolution. The data can be downloaded as GeoJSON or CSV from citylines.co/data . OpenStreetMap (OSM) - The collaborative platform for mapping the world, including transport, transit, and routing data. GTFS-Hub - Community tested, probably quality/content enhanced, partially merged or filtered GTFS-feeds of (currently German) transport agencies. Maintained by MITFAHR|DE|ZENTRALE . Sample GTFS and GTFS Realtime datasets used for software testing \u00b6 sample-gtfs-feed - An imaginary GTFS data set used for testing. transitfeed unit tests - Test data created for the original Google Python GTFS validator . Transitland GTFS and GTFS Realtime unit tests - For testing the transitland-lib library that handles GTFS and GTFS Realtime parsing and validation for Transitland: GTFS - \"bad entities\" at the single row level GTFS - validation errors that that involve entities in one or more files GTFS - best practices GTFS Realtime - JSON test cases that are turned into PB contents gtfs-realtime-validator unit tests - Some GTFS datasets (zip files) are included and a large number of GTFS RT messages are defined programmatically in Java via the gtfs-realtime-bindings library. OpenTripPlanner unit tests - Some GTFS datasets are defined for the unit tests ( GtfsTest and mmri folder ).","title":"Data"},{"location":"resources/data/#data","text":"Places to access collections of GTFS and other transit and multimodal data","title":"Data"},{"location":"resources/data/#3rd-party-gtfs-url-directories","text":"~~GTFS Data Exchange~~ (Deprecated) - Formerly the definitive directory of GTFS feed URLs. Shutdown in 2016. But 93 GB of data from 2008 to 2016 is available upon request. ~~OpenMobilityData~~ (Deprecated) - List of GTFS and GTFS-RT feeds. Archives and validates the GTFS feeds and allows you to preview both GTFS and GTFS-RT through the browser. Formerly TransitFeeds.com. MobilityData announced it is end-of-life as of early 2022 with a shutdown date to be determined. The Mobility Database - JSON and CSV files on GitHub that is a repository of 1300+ mobility datasets across the world. Contains contents of OpenMobilityData/TransitFeeds.com. Transitland - Community editable list of many transit agency GTFS datasets. Also provides an API to access the data as JSON/GeoJSON and a playground to try out the data.","title":"3rd party GTFS URL directories"},{"location":"resources/data/#transit-agency-data-archives","text":"CapMetrics - Historical vehicle locations for Austin's transit agency (CapMetro). Data is collected by capmetricsd , a Go daemon.","title":"Transit agency data archives"},{"location":"resources/data/#national-government-datasets","text":"National Transit Database (USA) - Information and statistics on the transit systems of the United States, run by the Federal Transit Administration. Transport (France) - GTFS datasets for French transit systems. European long-distance transport operators (EU) (Unofficial) - Unofficial list of available API endpoints, GTFS feeds and client libraries","title":"National government datasets"},{"location":"resources/data/#proprietary-non-standard-vendor-apis","text":"Transport API - REST API for aggregated transit data for the United Kingdom. Fee-based access. TransLoc OpenAPI - REST API for real-time vehicle, route, stop, and arrival data for over 60 transit systems in the United States that have purchased TransLoc's AVL hardware and software. NextBus API - REST API for real-time vehicle, route, stop, and arrival data for agencies that have puchased NextBus's hardware and/or software. Navitia.io - REST API for journey planning, stop schedules, isocrhons and lot more on US and EU. Navitia is the opensource engine behind the live API. CityBikes - REST API for aggregated bikeshare data from around the world. Powered by pyBikes . HAFAS \u2013 Propriety public transport management software by HaCon ( list of endpoints ) Citymapper API - REST API for transit journey planning, realtime transit data and walk, cycle, scooter travel times.","title":"Proprietary (non-standard) vendor APIs"},{"location":"resources/data/#crowdsourced-transit-data","text":"Citylines.co - A collaborative platform for mapping transit systems, with an emphasis on their historical evolution. The data can be downloaded as GeoJSON or CSV from citylines.co/data . OpenStreetMap (OSM) - The collaborative platform for mapping the world, including transport, transit, and routing data. GTFS-Hub - Community tested, probably quality/content enhanced, partially merged or filtered GTFS-feeds of (currently German) transport agencies. Maintained by MITFAHR|DE|ZENTRALE .","title":"Crowdsourced transit data"},{"location":"resources/data/#sample-gtfs-and-gtfs-realtime-datasets-used-for-software-testing","text":"sample-gtfs-feed - An imaginary GTFS data set used for testing. transitfeed unit tests - Test data created for the original Google Python GTFS validator . Transitland GTFS and GTFS Realtime unit tests - For testing the transitland-lib library that handles GTFS and GTFS Realtime parsing and validation for Transitland: GTFS - \"bad entities\" at the single row level GTFS - validation errors that that involve entities in one or more files GTFS - best practices GTFS Realtime - JSON test cases that are turned into PB contents gtfs-realtime-validator unit tests - Some GTFS datasets (zip files) are included and a large number of GTFS RT messages are defined programmatically in Java via the gtfs-realtime-bindings library. OpenTripPlanner unit tests - Some GTFS datasets are defined for the unit tests ( GtfsTest and mmri folder ).","title":"Sample GTFS and GTFS Realtime datasets used for software testing"},{"location":"resources/getting-started/","text":"Getting started \u00b6 If this is your first time dealing with transit data, you might find these links useful: GTFS - A GTFS feed is a group of text files that contains infrequently changing transit data, like stops, routes, trips, and other schedule data. Transit agencies typically update their GTFS feed every few months. GTFS Realtime - GTFS Realtime consists of three binary files that contain realtime vehicle positions, realtime arrival information, and service alerts. Transit agencies typically update these files every minute. World Bank - \"Intro. to GTFS\" online course - A free, online, self-paced course for learning about GTFS and GTFS-realtime. Open Transit Data Toolkit - A series of lessons to help people utilize open transit data. MBTA GTFS Onboarding - An interactive tutorial created by MBTA for GTFS static. A stand-alone Docker image is available on GitHub as well as a hosted/no-install version of the Jupyter notebook.","title":"Getting started"},{"location":"resources/getting-started/#getting-started","text":"If this is your first time dealing with transit data, you might find these links useful: GTFS - A GTFS feed is a group of text files that contains infrequently changing transit data, like stops, routes, trips, and other schedule data. Transit agencies typically update their GTFS feed every few months. GTFS Realtime - GTFS Realtime consists of three binary files that contain realtime vehicle positions, realtime arrival information, and service alerts. Transit agencies typically update these files every minute. World Bank - \"Intro. to GTFS\" online course - A free, online, self-paced course for learning about GTFS and GTFS-realtime. Open Transit Data Toolkit - A series of lessons to help people utilize open transit data. MBTA GTFS Onboarding - An interactive tutorial created by MBTA for GTFS static. A stand-alone Docker image is available on GitHub as well as a hosted/no-install version of the Jupyter notebook.","title":"Getting started"},{"location":"resources/gtfs-realtime/","text":"GTFS Realtime \u00b6 GTFS-realtime documentation . Also available in Espa\u00f1ol . GTFS-realtime Autodoc - Automatically generated documentation for GTFS-realtime, generated from the official GTFS-realtime protocol buffer specification and including some extensions. GTFS Realtime Libraries & Demo Apps \u00b6 gtfs-realtime-bindings - The official bindings for Java, .NET, Node.js, Python, and Ruby generated from the official GTFS-realtime protocol buffer specification . GTFS-realtime Exporter - A Java-based tool that assists in producing and sharing a GTFS-relatime feed. GTFS-realtime Alerts Producer Demo - A Java-based demo project for producing GTFS-realtime Service Alerts. GTFS-realtime Alerts Producer Web Application - A Java-based web application for producing GTFS-realtime Service Alerts. GTFS-realtime TripUpdates & VehiclePositions Producer Demo - A Java-based demo project for producing GTFS-realtime TripUpdates (estimated arrivals) and Vehicle Positions. GTFS-realtime Vehicle Positions Consumer/Visualizer Demo - A Java-based demo project for consuming a GTFS-realtime Vehicle Positions feed and displaying this info on a map. GTFS Realtime Validators \u00b6 gtfs-realtime-validator - A GTFS-realtime validation tool developed by the Center for Urban Transportation Research at the University of South Florida. Also includes an integrated version of the gtfs-validator tool. GTFS Realtime (and Other Real-time API) Archival Tools \u00b6 GTFS-realtime to SQL - Parses a GTFS-RealTime feed into an SQL database (used in OpenMobilityData.org ) gtfsrdb - A Python tool that supports reading and archiving GTFS-realtime feeds into a database retro-gtfs - A Python application that collects real-time data from the Nextbus API and archives it into the GTFS format (i.e., retrospective GTFS). GTFS Realtime Convertors \u00b6 SIRI to GTFS-realtime - A Java-based command-line utility to convert from the SIRI format to GTFS-realtime OrbCAD SQL Server to GTFS-realtime - A Java-based command-line utility that extracts vehicle positions and trip updates information from an OrbCAD SQL Server and exports them to the GTFS-realtime TripUpdates and VehiclePositions formats. NextBus API to GTFS-realtime - A Java-based command-line utility to convert from the NextBus API format to GTFS-realtime. Note that NextBus now directly offers a GTFS-realtime API for their products. See Cubic site and this FAQ . Syncromatics API to GTFS-realtime - A Java-based command-line utility to convert from the Syncromatics API format to GTFS-realtime TripUpdates and VehiclePositons. KV6,15,17, and ARNU to GTFS-realtime - Java-based tool to process incoming KV6,15,17 and ARNU and match them to static transit data present in a RID integration database. It then proceeds to export this data as ARNU RITinfo, GTFS(realtime) and KV78turbo WMATA BusPositions API to GTFS-realtime - Java-based tool to convert from WMATA's BusPositions API and Alert RSS feeds from MetroAlerts to GTFS-realtime TripUpdates, VehiclePositions, and Alerts feeds. SEPTA API to GTFS-realtime - Java-based tool to convert SEPTA's real-time bus and rail data to GTFS-realtime CTA API to GTFS-realtime - Java-based tool to convert CTA's Train Tracker data to GTFS-realtime. Detroit DOT to GTFS-realtime - Extract real-time info from DDOT's TransitMaster installation (database) and convert to GTFS-realtime Live Transit Event Trigger - Extracts data from Ride On's OrbCAD database and export as GTFS-realtime. SoundTransit to GTFS-realtime - Convert text file feed from Sound Transit to GTFS-realtime Civic Transit - Screen-scrapes KCATA\u2019s TransitMaster WebWatch installation to produce a GTFS-realtime feed. GTFS-realtime VehiclePositions to GTFS-realtime TripUpdates (TransitClock) - Java application that can consume raw vehicle positions and generate prediction times in formats such as GTFS-realtime. Formerly known as \"Transitime\". gtfs-realtime-translators - A Python-based tool to translate custom arrival API formats to GTFS-realtime. As of July 2019 it supports LA Metro and SEPTA. Transloc API to GTFS-realtime - A Node.js based tool to convert the Transloc API to GTFS-realtime. hafas-gtfs-rt-feed \u2013 A Javascript tool to generate a GTFS Realtime feed from a HAFAS endpoint. GTFS-realtime to SIRI-Lite - A Rust webserver to convert multiple GTFS-RT feeds to a SIRI-Lite API. GTFS Realtime Utilities \u00b6 bus_kalman - A Kalman Filter used to interpolate bus travel times using NYC MTA real-time data. Concentrate - Combines realtime transit information from multiple sources into single output files. Maintained by Massachusetts Bay Transportation Authority (MBTA) . gtfs-realtime-test-service - A tool for mocking GTFS-realtime feed content (e.g., for use in testing a GTFS-realtime consuming application). GTFS-realtime Munin Plugin - Provides a Munin plugin for logging information about a GTFS-realtime feed. GTFS-realtime Nagio Plugin - Provides a Nagios plugin for monitoring a GTFS-realtime feed GTFS-realtime Printer - Java-based utility to print out information from a GTFS-realtime file or URL. gtfs-rt-admin - An admin tool for managing GTFS-RT service alerts (JavaScript and Java). gtfs-rt-differential-to-full-dataset \u2013 Javascript tool to transform a continuous GTFS Realtime stream of DIFFERENTIAL incrementality data into a FULL_DATASET dump. gtfs-rt-dump - Converts protocol buffer format to plain text for easy viewing of a GTFS-realtime feed in plain text (for debugging purposes) gtfs-rt-inspector \u2013 Web app to inspect & analyze any (CORS-enabled) GTFS Realtime feed. Open-source on GitHub . GTFS Data Pipeline for TfNSW Bus Datasets - A data pipeline developed for the TfNSW's GTFS Static and Realtime datasets. The datasets generated using the pipeline have been used to validate the performance of TfNSW's Transit Signal Priority Request via Public Transport Information and Priority System (PTIPS). manual-gtfsrt - A Go-based tool that serves a GTFS-RT feed created from editable JSON. print-gtfs-rt-cli \u2013 Javascript tool to read a GTFS Realtime feed from stdin, print human-readable or as JSON. transitcast - Uses GTFS and GTFS-RT vehicle position feed generating an estimated transition time it takes for each vehicle to move from scheduled stop to scheduled stop recording these an \"observed_stop_time\" table. These records can later be used to train a machine learning model to make vehicle travel predictions. Created by TriMet as part of an FTA IMI project . transit-feed-quality-calculator - A Java project that uses the gtfs-realtime-validator to assess the quality of a large number of transit feeds, fetching the feed URLs from a global directory ( TransitFeeds.com/OpenMobilityData.org ). Transit Network Model - A tool to generate predictions using GTFS-realtime VehiclePositions, a particle filter, and a Kalman Filter.","title":"GTFS Realtime"},{"location":"resources/gtfs-realtime/#gtfs-realtime","text":"GTFS-realtime documentation . Also available in Espa\u00f1ol . GTFS-realtime Autodoc - Automatically generated documentation for GTFS-realtime, generated from the official GTFS-realtime protocol buffer specification and including some extensions.","title":"GTFS Realtime"},{"location":"resources/gtfs-realtime/#gtfs-realtime-libraries-demo-apps","text":"gtfs-realtime-bindings - The official bindings for Java, .NET, Node.js, Python, and Ruby generated from the official GTFS-realtime protocol buffer specification . GTFS-realtime Exporter - A Java-based tool that assists in producing and sharing a GTFS-relatime feed. GTFS-realtime Alerts Producer Demo - A Java-based demo project for producing GTFS-realtime Service Alerts. GTFS-realtime Alerts Producer Web Application - A Java-based web application for producing GTFS-realtime Service Alerts. GTFS-realtime TripUpdates & VehiclePositions Producer Demo - A Java-based demo project for producing GTFS-realtime TripUpdates (estimated arrivals) and Vehicle Positions. GTFS-realtime Vehicle Positions Consumer/Visualizer Demo - A Java-based demo project for consuming a GTFS-realtime Vehicle Positions feed and displaying this info on a map.","title":"GTFS Realtime Libraries &amp; Demo Apps"},{"location":"resources/gtfs-realtime/#gtfs-realtime-validators","text":"gtfs-realtime-validator - A GTFS-realtime validation tool developed by the Center for Urban Transportation Research at the University of South Florida. Also includes an integrated version of the gtfs-validator tool.","title":"GTFS Realtime Validators"},{"location":"resources/gtfs-realtime/#gtfs-realtime-and-other-real-time-api-archival-tools","text":"GTFS-realtime to SQL - Parses a GTFS-RealTime feed into an SQL database (used in OpenMobilityData.org ) gtfsrdb - A Python tool that supports reading and archiving GTFS-realtime feeds into a database retro-gtfs - A Python application that collects real-time data from the Nextbus API and archives it into the GTFS format (i.e., retrospective GTFS).","title":"GTFS Realtime (and Other Real-time API) Archival Tools"},{"location":"resources/gtfs-realtime/#gtfs-realtime-convertors","text":"SIRI to GTFS-realtime - A Java-based command-line utility to convert from the SIRI format to GTFS-realtime OrbCAD SQL Server to GTFS-realtime - A Java-based command-line utility that extracts vehicle positions and trip updates information from an OrbCAD SQL Server and exports them to the GTFS-realtime TripUpdates and VehiclePositions formats. NextBus API to GTFS-realtime - A Java-based command-line utility to convert from the NextBus API format to GTFS-realtime. Note that NextBus now directly offers a GTFS-realtime API for their products. See Cubic site and this FAQ . Syncromatics API to GTFS-realtime - A Java-based command-line utility to convert from the Syncromatics API format to GTFS-realtime TripUpdates and VehiclePositons. KV6,15,17, and ARNU to GTFS-realtime - Java-based tool to process incoming KV6,15,17 and ARNU and match them to static transit data present in a RID integration database. It then proceeds to export this data as ARNU RITinfo, GTFS(realtime) and KV78turbo WMATA BusPositions API to GTFS-realtime - Java-based tool to convert from WMATA's BusPositions API and Alert RSS feeds from MetroAlerts to GTFS-realtime TripUpdates, VehiclePositions, and Alerts feeds. SEPTA API to GTFS-realtime - Java-based tool to convert SEPTA's real-time bus and rail data to GTFS-realtime CTA API to GTFS-realtime - Java-based tool to convert CTA's Train Tracker data to GTFS-realtime. Detroit DOT to GTFS-realtime - Extract real-time info from DDOT's TransitMaster installation (database) and convert to GTFS-realtime Live Transit Event Trigger - Extracts data from Ride On's OrbCAD database and export as GTFS-realtime. SoundTransit to GTFS-realtime - Convert text file feed from Sound Transit to GTFS-realtime Civic Transit - Screen-scrapes KCATA\u2019s TransitMaster WebWatch installation to produce a GTFS-realtime feed. GTFS-realtime VehiclePositions to GTFS-realtime TripUpdates (TransitClock) - Java application that can consume raw vehicle positions and generate prediction times in formats such as GTFS-realtime. Formerly known as \"Transitime\". gtfs-realtime-translators - A Python-based tool to translate custom arrival API formats to GTFS-realtime. As of July 2019 it supports LA Metro and SEPTA. Transloc API to GTFS-realtime - A Node.js based tool to convert the Transloc API to GTFS-realtime. hafas-gtfs-rt-feed \u2013 A Javascript tool to generate a GTFS Realtime feed from a HAFAS endpoint. GTFS-realtime to SIRI-Lite - A Rust webserver to convert multiple GTFS-RT feeds to a SIRI-Lite API.","title":"GTFS Realtime Convertors"},{"location":"resources/gtfs-realtime/#gtfs-realtime-utilities","text":"bus_kalman - A Kalman Filter used to interpolate bus travel times using NYC MTA real-time data. Concentrate - Combines realtime transit information from multiple sources into single output files. Maintained by Massachusetts Bay Transportation Authority (MBTA) . gtfs-realtime-test-service - A tool for mocking GTFS-realtime feed content (e.g., for use in testing a GTFS-realtime consuming application). GTFS-realtime Munin Plugin - Provides a Munin plugin for logging information about a GTFS-realtime feed. GTFS-realtime Nagio Plugin - Provides a Nagios plugin for monitoring a GTFS-realtime feed GTFS-realtime Printer - Java-based utility to print out information from a GTFS-realtime file or URL. gtfs-rt-admin - An admin tool for managing GTFS-RT service alerts (JavaScript and Java). gtfs-rt-differential-to-full-dataset \u2013 Javascript tool to transform a continuous GTFS Realtime stream of DIFFERENTIAL incrementality data into a FULL_DATASET dump. gtfs-rt-dump - Converts protocol buffer format to plain text for easy viewing of a GTFS-realtime feed in plain text (for debugging purposes) gtfs-rt-inspector \u2013 Web app to inspect & analyze any (CORS-enabled) GTFS Realtime feed. Open-source on GitHub . GTFS Data Pipeline for TfNSW Bus Datasets - A data pipeline developed for the TfNSW's GTFS Static and Realtime datasets. The datasets generated using the pipeline have been used to validate the performance of TfNSW's Transit Signal Priority Request via Public Transport Information and Priority System (PTIPS). manual-gtfsrt - A Go-based tool that serves a GTFS-RT feed created from editable JSON. print-gtfs-rt-cli \u2013 Javascript tool to read a GTFS Realtime feed from stdin, print human-readable or as JSON. transitcast - Uses GTFS and GTFS-RT vehicle position feed generating an estimated transition time it takes for each vehicle to move from scheduled stop to scheduled stop recording these an \"observed_stop_time\" table. These records can later be used to train a machine learning model to make vehicle travel predictions. Created by TriMet as part of an FTA IMI project . transit-feed-quality-calculator - A Java project that uses the gtfs-realtime-validator to assess the quality of a large number of transit feeds, fetching the feed URLs from a global directory ( TransitFeeds.com/OpenMobilityData.org ). Transit Network Model - A tool to generate predictions using GTFS-realtime VehiclePositions, a particle filter, and a Kalman Filter.","title":"GTFS Realtime Utilities"},{"location":"resources/gtfs/","text":"GTFS \u00b6 GTFS Spec - Specification for the General Transit Data Feed, or GTFS. Also available in Espa\u00f1ol , Fran\u00e7ais . GTFS Best Practices - Best practices for producers of a GTFS feed. GTFS Libraries \u00b6 Software that makes it easy to consume GTFS data in a variety of languages. C \u00b6 CGTFS - C library for reading static GTFS feeds. Supports reading unpacked feeds into application memory or into SQLite databases. RRRR Rapid Real-time Routing - RRRR (usually pronounced R4) is a C-language implementation of the RAPTOR public transit routing algorithm. C++ \u00b6 just_gtfs - C++17 header-only library for reading and writing GTFS (used in MAPS.ME ). Main features: fast reading and writing of GTFS feeds, support for extended GTFS route types , simple working with GTFS Date and Time formats. C \u00b6 ESRI public-transit-tools - Tools for working with public transit data in ArcGIS (license for ArcGIS required). GTFS Feed Parser - .Net/Mono implementation of a GTFS parser. Go \u00b6 Go GTFS Parser - A GTFS parsing library for Go. Java \u00b6 OneBusAway GTFS Modules - A Java-based library for reading, writing, and transforming public transit data in the GTFS format, including database support. JavaScript \u00b6 gtfs-sequelize - Node.js library modeling the static GTFS using sequelize.js . gtfs-utils \u2013 Utilities to process GTFS data sets (e.g., \"flattening\" calendar.txt & calendar_dates.txt , computing arrival/departure times of trips). gtfs-via-postgres \u2013 Yet another tool to process GTFS using PostgreSQL. Node-GTFS - Loads transit data from GTFS files, unzips it and stores it to a SQLite database. Provides some methods to query for agencies, routes, stops and times. PostgreSQL \u00b6 gtfs-schema - PostgreSQL schema for GTFS feeds. gtfs-via-postgres \u2013 Yet another tool to process GTFS using PostgreSQL. Python \u00b6 combine_gtfs_feeds - A Python tool to combine multiple gtfs feeds into one feed/dataset. ESRI public-transit-tools - Tools for working with public transit data in ArcGIS (license for ArcGIS required). gtfsdb - Python library for converting GTFS files into a relational database. gtfslib-python - An open source library in python for reading GTFS files and computing various stats and indicators about Public Transport networks. gtfsman - Repository-like tool in Python to manage and update a huge number of GTFS feeds. gtfspy - Public transport network analysis and travel time computations using Python3. Compatible with Postgres/PostGIS, Oracle, MySQL, and SQLite. Used by gtfspy-webviz . GTFS Kit - A Python 3.6+ tool kit for analyzing General Transit Feed Specification (GTFS) data. Supersedes GTFSTK . GTFSTK - A Python 3 toolkit for analyzing GTFS data in memory. Uses Pandas and Shapely for speed. Superseded by GTFS Kit . Make GTFS - A Python library to make GTFS feeds from basic route information. Mapzen GTFS - A Python GTFS library that supports reading individual GTFS tables, or constructing a graph to represent each agency in a feed. multigtfs - A Django application to import and export GTFS. partridge - A fast, forgiving Python GTFS reader built on pandas DataFrames. R \u00b6 trread - A transit (GTFS) file reader for R. Ruby \u00b6 GTFS-viz - Ruby script that converts a set of GTFS files into a SQLite database + GeoJSONs (needed by the Transit Map web application) GTFS Converters \u00b6 Converters from various static schedule formats to and from GTFS. Chouette - Converts French-Transmodel, SIRI, NETeX. See Chouette.mobi website for more info. extract-gtfs-pathways \u2013 Command-line tool to extract pathways as GeoJSON from a GTFS dataset. extract-gtfs-shapes \u2013 Command-line tool to extract shapes as GeoJSON from a GTFS dataset. GTFS-OSM-Sync - A Java tool for synchronizing data in GTFS format with OpenStreetMap.org . gtfs-service-area - Compute a transit service area from static GTFS. Results are output as single-layer .geojson files. Dockerized version of gtfs-to-geojson . GTFS-route-shapes - A Python script to generate a single geoJSON shape for each transit route in a GTFS archive. gtfs-to-geojson - Javascript tool that converts transit data in GTFS shapes and stops into geoJSON. This is useful for creating maps of transit routes. gtfs2gps - An R package that converts public transportation data in GTFS format to GPS-like records in a data.table , where each row represents the timestamp of each vehicle at a given spatial resolution. gtsf - general transit (GTFS) simple (geographic) features (sf) in R. can be used to convert from GTFS to Shapefile, GeoJSON, and other formats through GDAL. hafas-generate-gtfs (work-in-progress) \u2013 A Javascript tool to generate GTFS dumps from HAFAS endpoints. Hafas2GTFS - Hafas2GTFS converter written in Python, optimized for SBB HAFAS feeds. kml-to-gtfs-shapes - Javascript tool to convert polylines from a KML file into a GTFS shapes.txt file. Hosted on GitHub here . o2g - A simple tool to extract GTFS feed from OpenStreetMap. Open-Transport SYNTHESE Convertors - Converts French-Transmodel, SIRI, NETeX, HAFAS, HASTUS, VDV452, and more. onebusaway-gtfs-to-barefoot - A Java tool to create a Barefoot mapfile from a GTFS file. onebusaway-vdv-modules - A Java library for working with transit data in the VDV format, including converting VDV-452 schedule data into GTFS. osm2gtfs - Turn OpenStreetMap data and schedule information into GTFS. transit_model - A Rust library to convert to/from the following formats: GTFS, NTFS (for Navitia, see Software for Creating APIs ), TransXChange ( UK standard format ), KV1 ( Netherland standard format ) or NeTEx ( European standard format ). transloc-gtfs-rectifier - Python application that attempts to assign GTFS stop_ids to TransLoc IDs using TransLoc's API ( TransLoc doesn't provide GTFS stop_ids in their API). Transmodel and IFF to GTFS - Imports and syncs (Transmodel) BISON Koppelvlak1, IFF (a format written by HP/EDS, somewhat similiar to ATCO CIF) to import timetables of the railway networks. The internal pseudo-NETeX datastructure allows to export to GTFS and there are proof-of-concepts to export to other formats such as NETeX, GTFS and IFF. GTFS Data Collection and Maintenance Tools \u00b6 bus-router - Python script that generates missing shapes.txt for GTFS using routing from Google Maps Directions API or OSRM . gtfs-blocks-to-transfers - A Python tool to convert GTFS blocks, defined by setting trip.block_id into a series of trip-to-trip transfers (proposal) . GTFS Editor - A (self-hosted) web-based GTFS editing framework. (Note: this project has been deprecated in favor of IBI Data Tools .) GTFS Editor for Vagrant - Quickly set up the GTFS editor (above) using Vagrant static-GTFS-manager - A (self-hosted) browser-based user interface for creating, editing, exporting static GTFS (see related post ). Live demo here . TransitWand - An open source web and mobile application for collecting transit data. Use it to create GTFS feeds, capture passenger counts or generate GIS datasets. IBI Data Tools - A web application that handles GTFS editing, validating, quality checking, and deploying to OpenTripPlanner. (Combines and builds upon the functionality of the deprecated Gtfs Data Manager and GTFS Editor .) GTFS.html - An entirely browser-based tool to view GTFS feeds. Use it to view routes, stops, timetables, etc. pfaedle - Precise map-matching for GTFS using OpenStreetMap data GTFS shape mapfit - Python tool that fits GTFS shape files and stops to a given OSM map file. Uses pymapmatch for the matching. GTFS Builder - A free web-based application to help you create GTFS files. Maintained by the National Rural Transit Assistance Program (RTAP). gtfs-station-builder - UI tool to help build the internal structure of stations (including pathways.txt) GTFS Text-to-Speech Tester - A command-line tool that reads GTFS stop names out loud using Text-to-Speech to determine which need Text-to-Speech values for tts_stop_name in stops.txt. GTFS Analysis Tools \u00b6 Peartree - A Python library for converting transit data into a directed graph for network analysis. gtfsr - An R package for easily importing, validating, and mapping transit data that follows the General Transit Feed Specification (GTFS) format. R5: Rapid Realistic Routing on Real-world and Reimagined networks - A Java-based routing engine developed by Conveyal for multimodal (transit/bike/walk/car) networks. It currently plans many trips over a time window for scenario planning and analytics purposes. A related R wrapper package ( r5r ) is developed independently by IPEA. See also the performance comparison from Higgins et al. (2022), linked below. tidytransit (formerly bustt ) - Reads GTFS data into tidyverse and simple features dataframes to map transit stops and routes, calculate transit frequencies, and validate transit feeds. tidytransit is a fork of gtfsr , published to CRAN , with frequency/headway calculation functions. transitr - An R package for constructing and modelling a transit network in real time to obtain vehicle ETAs Busbuzzard - Inference of probabilistic schedules from empirical data about transit vehicles. ESRI ArcGIS Public Transit Tools (GTFS) - Tools for working with public transit data in ArcGIS GTFS-to-Chart - Creates stringline charts showing all vehicles on a transit route from GTFS data. GTFS Timetable Publishing Tools \u00b6 GTFS-to-HTML - Generate human-readable timetables in HTML or PDF format directly from GTFS. TimeTablePublisher (TTPUB) - A web publishing system developed by TriMet that allows a transit agency to examine, modify, and transform raw scheduling data into easy-to-read timetables for customer information purposes GTFS Validators \u00b6 Conveyal's gtfs-validator - A Java-based GTFS validator based on the OneBusAway GTFS Modules, runs in Java and is faster than the Google provided one. Conveyal's gtfs-lib - Conveyal's successor to their own gtfs-validator , a Java-based library for loading and saving GTFS feeds of arbitrary size with disk-backed storage. Google's feedValidator - Google-supported Python-based GTFS validator. GTFS Data Package Specification - A Data Package specification with validation accomplished with Good Tables . Includes a data package, schemas, tests, and uses South East Queensland GTFS data as an example. GTFS Meta-Validator (hosted by Omni) - A web-based GTFS validator that runs both the Google Python feedValidator and Conveyal's gtfs-validator on uploaded GTFS files. gtfstidy - A Go-based tool to tidy and validate GTFS feeds. gtfs-validator-api - This Python package is a thin wrapper around MobilityData/gtfs-validator that handles intermediate files produced and finds gtfs-validator's output file so it can be given a specific name or returned as a string. GTFSVTOR - An open-source GTFS validator implemented in Java licensed under GPLv3 maintained by Mecatran . MobilityData's gtfs-validator - A open-source GTFS validator canonically following the GTFS spec implemented in Java licensed under Apache v2.0 maintained by MobilityData . Reflect GTFS Validator (hosted by Foursquare ITP) - Transit schedule and GTFS validation platform by Foursquare ITP that includes a free, web-based GTFS validator based on gtfs-lib . Transit App's gtfs-fares-v2-validator - A Python tool that validators GTFS-Fares-v2 data based on the draft specification . Transport Validator - An open-source validator implemented in Rust . Used by the French National Access Point .","title":"GTFS"},{"location":"resources/gtfs/#gtfs","text":"GTFS Spec - Specification for the General Transit Data Feed, or GTFS. Also available in Espa\u00f1ol , Fran\u00e7ais . GTFS Best Practices - Best practices for producers of a GTFS feed.","title":"GTFS"},{"location":"resources/gtfs/#gtfs-libraries","text":"Software that makes it easy to consume GTFS data in a variety of languages.","title":"GTFS Libraries"},{"location":"resources/gtfs/#c","text":"CGTFS - C library for reading static GTFS feeds. Supports reading unpacked feeds into application memory or into SQLite databases. RRRR Rapid Real-time Routing - RRRR (usually pronounced R4) is a C-language implementation of the RAPTOR public transit routing algorithm.","title":"C"},{"location":"resources/gtfs/#c_1","text":"just_gtfs - C++17 header-only library for reading and writing GTFS (used in MAPS.ME ). Main features: fast reading and writing of GTFS feeds, support for extended GTFS route types , simple working with GTFS Date and Time formats.","title":"C++"},{"location":"resources/gtfs/#c_2","text":"ESRI public-transit-tools - Tools for working with public transit data in ArcGIS (license for ArcGIS required). GTFS Feed Parser - .Net/Mono implementation of a GTFS parser.","title":"C"},{"location":"resources/gtfs/#go","text":"Go GTFS Parser - A GTFS parsing library for Go.","title":"Go"},{"location":"resources/gtfs/#java","text":"OneBusAway GTFS Modules - A Java-based library for reading, writing, and transforming public transit data in the GTFS format, including database support.","title":"Java"},{"location":"resources/gtfs/#javascript","text":"gtfs-sequelize - Node.js library modeling the static GTFS using sequelize.js . gtfs-utils \u2013 Utilities to process GTFS data sets (e.g., \"flattening\" calendar.txt & calendar_dates.txt , computing arrival/departure times of trips). gtfs-via-postgres \u2013 Yet another tool to process GTFS using PostgreSQL. Node-GTFS - Loads transit data from GTFS files, unzips it and stores it to a SQLite database. Provides some methods to query for agencies, routes, stops and times.","title":"JavaScript"},{"location":"resources/gtfs/#postgresql","text":"gtfs-schema - PostgreSQL schema for GTFS feeds. gtfs-via-postgres \u2013 Yet another tool to process GTFS using PostgreSQL.","title":"PostgreSQL"},{"location":"resources/gtfs/#python","text":"combine_gtfs_feeds - A Python tool to combine multiple gtfs feeds into one feed/dataset. ESRI public-transit-tools - Tools for working with public transit data in ArcGIS (license for ArcGIS required). gtfsdb - Python library for converting GTFS files into a relational database. gtfslib-python - An open source library in python for reading GTFS files and computing various stats and indicators about Public Transport networks. gtfsman - Repository-like tool in Python to manage and update a huge number of GTFS feeds. gtfspy - Public transport network analysis and travel time computations using Python3. Compatible with Postgres/PostGIS, Oracle, MySQL, and SQLite. Used by gtfspy-webviz . GTFS Kit - A Python 3.6+ tool kit for analyzing General Transit Feed Specification (GTFS) data. Supersedes GTFSTK . GTFSTK - A Python 3 toolkit for analyzing GTFS data in memory. Uses Pandas and Shapely for speed. Superseded by GTFS Kit . Make GTFS - A Python library to make GTFS feeds from basic route information. Mapzen GTFS - A Python GTFS library that supports reading individual GTFS tables, or constructing a graph to represent each agency in a feed. multigtfs - A Django application to import and export GTFS. partridge - A fast, forgiving Python GTFS reader built on pandas DataFrames.","title":"Python"},{"location":"resources/gtfs/#r","text":"trread - A transit (GTFS) file reader for R.","title":"R"},{"location":"resources/gtfs/#ruby","text":"GTFS-viz - Ruby script that converts a set of GTFS files into a SQLite database + GeoJSONs (needed by the Transit Map web application)","title":"Ruby"},{"location":"resources/gtfs/#gtfs-converters","text":"Converters from various static schedule formats to and from GTFS. Chouette - Converts French-Transmodel, SIRI, NETeX. See Chouette.mobi website for more info. extract-gtfs-pathways \u2013 Command-line tool to extract pathways as GeoJSON from a GTFS dataset. extract-gtfs-shapes \u2013 Command-line tool to extract shapes as GeoJSON from a GTFS dataset. GTFS-OSM-Sync - A Java tool for synchronizing data in GTFS format with OpenStreetMap.org . gtfs-service-area - Compute a transit service area from static GTFS. Results are output as single-layer .geojson files. Dockerized version of gtfs-to-geojson . GTFS-route-shapes - A Python script to generate a single geoJSON shape for each transit route in a GTFS archive. gtfs-to-geojson - Javascript tool that converts transit data in GTFS shapes and stops into geoJSON. This is useful for creating maps of transit routes. gtfs2gps - An R package that converts public transportation data in GTFS format to GPS-like records in a data.table , where each row represents the timestamp of each vehicle at a given spatial resolution. gtsf - general transit (GTFS) simple (geographic) features (sf) in R. can be used to convert from GTFS to Shapefile, GeoJSON, and other formats through GDAL. hafas-generate-gtfs (work-in-progress) \u2013 A Javascript tool to generate GTFS dumps from HAFAS endpoints. Hafas2GTFS - Hafas2GTFS converter written in Python, optimized for SBB HAFAS feeds. kml-to-gtfs-shapes - Javascript tool to convert polylines from a KML file into a GTFS shapes.txt file. Hosted on GitHub here . o2g - A simple tool to extract GTFS feed from OpenStreetMap. Open-Transport SYNTHESE Convertors - Converts French-Transmodel, SIRI, NETeX, HAFAS, HASTUS, VDV452, and more. onebusaway-gtfs-to-barefoot - A Java tool to create a Barefoot mapfile from a GTFS file. onebusaway-vdv-modules - A Java library for working with transit data in the VDV format, including converting VDV-452 schedule data into GTFS. osm2gtfs - Turn OpenStreetMap data and schedule information into GTFS. transit_model - A Rust library to convert to/from the following formats: GTFS, NTFS (for Navitia, see Software for Creating APIs ), TransXChange ( UK standard format ), KV1 ( Netherland standard format ) or NeTEx ( European standard format ). transloc-gtfs-rectifier - Python application that attempts to assign GTFS stop_ids to TransLoc IDs using TransLoc's API ( TransLoc doesn't provide GTFS stop_ids in their API). Transmodel and IFF to GTFS - Imports and syncs (Transmodel) BISON Koppelvlak1, IFF (a format written by HP/EDS, somewhat similiar to ATCO CIF) to import timetables of the railway networks. The internal pseudo-NETeX datastructure allows to export to GTFS and there are proof-of-concepts to export to other formats such as NETeX, GTFS and IFF.","title":"GTFS Converters"},{"location":"resources/gtfs/#gtfs-data-collection-and-maintenance-tools","text":"bus-router - Python script that generates missing shapes.txt for GTFS using routing from Google Maps Directions API or OSRM . gtfs-blocks-to-transfers - A Python tool to convert GTFS blocks, defined by setting trip.block_id into a series of trip-to-trip transfers (proposal) . GTFS Editor - A (self-hosted) web-based GTFS editing framework. (Note: this project has been deprecated in favor of IBI Data Tools .) GTFS Editor for Vagrant - Quickly set up the GTFS editor (above) using Vagrant static-GTFS-manager - A (self-hosted) browser-based user interface for creating, editing, exporting static GTFS (see related post ). Live demo here . TransitWand - An open source web and mobile application for collecting transit data. Use it to create GTFS feeds, capture passenger counts or generate GIS datasets. IBI Data Tools - A web application that handles GTFS editing, validating, quality checking, and deploying to OpenTripPlanner. (Combines and builds upon the functionality of the deprecated Gtfs Data Manager and GTFS Editor .) GTFS.html - An entirely browser-based tool to view GTFS feeds. Use it to view routes, stops, timetables, etc. pfaedle - Precise map-matching for GTFS using OpenStreetMap data GTFS shape mapfit - Python tool that fits GTFS shape files and stops to a given OSM map file. Uses pymapmatch for the matching. GTFS Builder - A free web-based application to help you create GTFS files. Maintained by the National Rural Transit Assistance Program (RTAP). gtfs-station-builder - UI tool to help build the internal structure of stations (including pathways.txt) GTFS Text-to-Speech Tester - A command-line tool that reads GTFS stop names out loud using Text-to-Speech to determine which need Text-to-Speech values for tts_stop_name in stops.txt.","title":"GTFS Data Collection and Maintenance Tools"},{"location":"resources/gtfs/#gtfs-analysis-tools","text":"Peartree - A Python library for converting transit data into a directed graph for network analysis. gtfsr - An R package for easily importing, validating, and mapping transit data that follows the General Transit Feed Specification (GTFS) format. R5: Rapid Realistic Routing on Real-world and Reimagined networks - A Java-based routing engine developed by Conveyal for multimodal (transit/bike/walk/car) networks. It currently plans many trips over a time window for scenario planning and analytics purposes. A related R wrapper package ( r5r ) is developed independently by IPEA. See also the performance comparison from Higgins et al. (2022), linked below. tidytransit (formerly bustt ) - Reads GTFS data into tidyverse and simple features dataframes to map transit stops and routes, calculate transit frequencies, and validate transit feeds. tidytransit is a fork of gtfsr , published to CRAN , with frequency/headway calculation functions. transitr - An R package for constructing and modelling a transit network in real time to obtain vehicle ETAs Busbuzzard - Inference of probabilistic schedules from empirical data about transit vehicles. ESRI ArcGIS Public Transit Tools (GTFS) - Tools for working with public transit data in ArcGIS GTFS-to-Chart - Creates stringline charts showing all vehicles on a transit route from GTFS data.","title":"GTFS Analysis Tools"},{"location":"resources/gtfs/#gtfs-timetable-publishing-tools","text":"GTFS-to-HTML - Generate human-readable timetables in HTML or PDF format directly from GTFS. TimeTablePublisher (TTPUB) - A web publishing system developed by TriMet that allows a transit agency to examine, modify, and transform raw scheduling data into easy-to-read timetables for customer information purposes","title":"GTFS Timetable Publishing Tools"},{"location":"resources/gtfs/#gtfs-validators","text":"Conveyal's gtfs-validator - A Java-based GTFS validator based on the OneBusAway GTFS Modules, runs in Java and is faster than the Google provided one. Conveyal's gtfs-lib - Conveyal's successor to their own gtfs-validator , a Java-based library for loading and saving GTFS feeds of arbitrary size with disk-backed storage. Google's feedValidator - Google-supported Python-based GTFS validator. GTFS Data Package Specification - A Data Package specification with validation accomplished with Good Tables . Includes a data package, schemas, tests, and uses South East Queensland GTFS data as an example. GTFS Meta-Validator (hosted by Omni) - A web-based GTFS validator that runs both the Google Python feedValidator and Conveyal's gtfs-validator on uploaded GTFS files. gtfstidy - A Go-based tool to tidy and validate GTFS feeds. gtfs-validator-api - This Python package is a thin wrapper around MobilityData/gtfs-validator that handles intermediate files produced and finds gtfs-validator's output file so it can be given a specific name or returned as a string. GTFSVTOR - An open-source GTFS validator implemented in Java licensed under GPLv3 maintained by Mecatran . MobilityData's gtfs-validator - A open-source GTFS validator canonically following the GTFS spec implemented in Java licensed under Apache v2.0 maintained by MobilityData . Reflect GTFS Validator (hosted by Foursquare ITP) - Transit schedule and GTFS validation platform by Foursquare ITP that includes a free, web-based GTFS validator based on gtfs-lib . Transit App's gtfs-fares-v2-validator - A Python tool that validators GTFS-Fares-v2 data based on the draft specification . Transport Validator - An open-source validator implemented in Rust . Used by the French National Access Point .","title":"GTFS Validators"},{"location":"resources/hardware/","text":"Hardware \u00b6 Experimental and production transit hardware. Bus Tracking GPS - Code for Miami prototype of a cheap open-source solution to track transit buses.","title":"Hardware"},{"location":"resources/hardware/#hardware","text":"Experimental and production transit hardware. Bus Tracking GPS - Code for Miami prototype of a cheap open-source solution to track transit buses.","title":"Hardware"},{"location":"resources/multimodal/","text":"Other multimodal data formats \u00b6 Alliance for Parking Data Standards (APDS) - Formed by the International Parking Institute (IPI) , the British Parking Association (BPA) , and the European Parking Association (EPA) , APDS is a not-for-profit organization with the mission to develop, promote, manage, and maintain a uniform global standard that will allow organizations to share parking data across platforms worldwide. APDS Version 1.0 documents are here . CurbLR - A specification for curb regulations. Dyno-Demand - A GTFS-based travel demand data format focusing on individual passenger demand suitable for dynamic network modeling developed by San Francisco County Transportation Authority, LMZ LLC, and UrbanLabs LLC. Dyno-Path - (Under development - see this post ) Data for individual passenger trajectories . General Bikeshare Feed Specification (GBFS) - Open data standard for real-time bikeshare information developed by members of the North American Bikeshare Association (NABSA) . gbfs-validator - 3rd party tool to validate GBFS feeds. gbfs R package - Functions to interface with GBFS feeds in R, allowing users to save and accumulate tidy .rds datasets for specified cities/bikeshare programs. GTFS-flex - A data format that models flexible public transportation services as an extension to GTFS. GTFS-plus - A GTFS-based transit network format for vehicle and capacity data suitable for dynamic transit modeling developed by Puget Sound Regional Council, UrbanLabs LLC, LMZ LLC, and San Francisco County Transportation Authority. GTFS-ride - An open, fixed-route transit ridership data standard developed through a partnership between the Oregon Department of Transportation and Oregon State University. GTFS-stat - An extension to a GTFS transit network with additional files that contain performance data developed by UrbanLabs LLC and San Francisco County Transportation Authority. General Modeling Network Specification (GMNS) - A format for sharing routable road network files designed to be used in multi-modal static and dynamic transportation planning and operations models. Volpe/FHWA partnership with Zephyr Foundation. General Travel Network Specification - A planned data specification for sharing travel demand model networks. Managed and Tolled Lanes Feed Specification (MTLFS) - Proposal for a schema that comprise the Managed and Tolled Lanes Tolling Feed Specification (MTLFS) and defines the fields used in all of those files developed by Santa Clara Valley Transportation Authority . Mobility as a Service API - A set of open documents and test suite that defines a MaaS-compatible API (e.g., a MaaS Transport Service Provider Booking API ). Mobility Data Specification (MDS) - A format to implement realtime data sharing, measurement and regulation for municipalities and mobility as a service providers. It is meant to ensure that governments have the ability to enforce, evaluate and manage providers. Maintained by the Open Mobility Foundation . NCHRP 08-119 Developing Data Standards and Guidance for Transportation Planning and Traffic Operations - Phase 1 (Anticipated) - The objective of this research is to develop standards and/or guidance to be used and adopted by the transportation community in collecting, managing, and sharing static and real-time data for transportation planning and operations. NeTex - A general purpose XML format designed for the exchange of complex static transport data among distributed systems managed by the CEN standards process . OMX: The Open Matrix data file format - A structured collection of two-dimensional array objects and associated metadata, for possible use in the transportation modeling industry. Open Sales and Distribution Model (OSDM) - Aims to substantially simplify the booking process for customers of rail trips and to lower complexity and distribution costs for distributors and railway carriers. Contains a specification of an offline model and on-line API. Maintained by the International Union of Railways (UIC) . SAE Shared and Digital Mobility Committee - Appears to be working on a data standard for car share and transportation network companies (TNCs) / rideshare. shared-row - A specification for right-of-way (ROW) for a SharedStreets Reference. TCRP G-16 Development of Transactional Data Specifications for Demand-Responsive Transportation (In progress) - The objective of this research is to develop technical specifications for transactional data for entities involved in the provision of demand-responsive transportation. Expected completion date is late 2018. TIDES project - Transit ITS Data Exchange Specification (TIDES) is a proposed effort to create standard data structures, APIs, and data management tools for historical transit ITS data including AVL, APC and AFC Data. Transport Operator Mobility-as-a-service Provider (TOMP)-API - Working group in the Netherlands with a goal to develop an API for use by Transport Operators and Mobility-as-a-service Providers for operator discovery, trip planning, end user interaction, booking, and payment.","title":"Other multimodal data formats"},{"location":"resources/multimodal/#other-multimodal-data-formats","text":"Alliance for Parking Data Standards (APDS) - Formed by the International Parking Institute (IPI) , the British Parking Association (BPA) , and the European Parking Association (EPA) , APDS is a not-for-profit organization with the mission to develop, promote, manage, and maintain a uniform global standard that will allow organizations to share parking data across platforms worldwide. APDS Version 1.0 documents are here . CurbLR - A specification for curb regulations. Dyno-Demand - A GTFS-based travel demand data format focusing on individual passenger demand suitable for dynamic network modeling developed by San Francisco County Transportation Authority, LMZ LLC, and UrbanLabs LLC. Dyno-Path - (Under development - see this post ) Data for individual passenger trajectories . General Bikeshare Feed Specification (GBFS) - Open data standard for real-time bikeshare information developed by members of the North American Bikeshare Association (NABSA) . gbfs-validator - 3rd party tool to validate GBFS feeds. gbfs R package - Functions to interface with GBFS feeds in R, allowing users to save and accumulate tidy .rds datasets for specified cities/bikeshare programs. GTFS-flex - A data format that models flexible public transportation services as an extension to GTFS. GTFS-plus - A GTFS-based transit network format for vehicle and capacity data suitable for dynamic transit modeling developed by Puget Sound Regional Council, UrbanLabs LLC, LMZ LLC, and San Francisco County Transportation Authority. GTFS-ride - An open, fixed-route transit ridership data standard developed through a partnership between the Oregon Department of Transportation and Oregon State University. GTFS-stat - An extension to a GTFS transit network with additional files that contain performance data developed by UrbanLabs LLC and San Francisco County Transportation Authority. General Modeling Network Specification (GMNS) - A format for sharing routable road network files designed to be used in multi-modal static and dynamic transportation planning and operations models. Volpe/FHWA partnership with Zephyr Foundation. General Travel Network Specification - A planned data specification for sharing travel demand model networks. Managed and Tolled Lanes Feed Specification (MTLFS) - Proposal for a schema that comprise the Managed and Tolled Lanes Tolling Feed Specification (MTLFS) and defines the fields used in all of those files developed by Santa Clara Valley Transportation Authority . Mobility as a Service API - A set of open documents and test suite that defines a MaaS-compatible API (e.g., a MaaS Transport Service Provider Booking API ). Mobility Data Specification (MDS) - A format to implement realtime data sharing, measurement and regulation for municipalities and mobility as a service providers. It is meant to ensure that governments have the ability to enforce, evaluate and manage providers. Maintained by the Open Mobility Foundation . NCHRP 08-119 Developing Data Standards and Guidance for Transportation Planning and Traffic Operations - Phase 1 (Anticipated) - The objective of this research is to develop standards and/or guidance to be used and adopted by the transportation community in collecting, managing, and sharing static and real-time data for transportation planning and operations. NeTex - A general purpose XML format designed for the exchange of complex static transport data among distributed systems managed by the CEN standards process . OMX: The Open Matrix data file format - A structured collection of two-dimensional array objects and associated metadata, for possible use in the transportation modeling industry. Open Sales and Distribution Model (OSDM) - Aims to substantially simplify the booking process for customers of rail trips and to lower complexity and distribution costs for distributors and railway carriers. Contains a specification of an offline model and on-line API. Maintained by the International Union of Railways (UIC) . SAE Shared and Digital Mobility Committee - Appears to be working on a data standard for car share and transportation network companies (TNCs) / rideshare. shared-row - A specification for right-of-way (ROW) for a SharedStreets Reference. TCRP G-16 Development of Transactional Data Specifications for Demand-Responsive Transportation (In progress) - The objective of this research is to develop technical specifications for transactional data for entities involved in the provision of demand-responsive transportation. Expected completion date is late 2018. TIDES project - Transit ITS Data Exchange Specification (TIDES) is a proposed effort to create standard data structures, APIs, and data management tools for historical transit ITS data including AVL, APC and AFC Data. Transport Operator Mobility-as-a-service Provider (TOMP)-API - Working group in the Netherlands with a goal to develop an API for use by Transport Operators and Mobility-as-a-service Providers for operator discovery, trip planning, end user interaction, booking, and payment.","title":"Other multimodal data formats"},{"location":"resources/other/","text":"Other Resources \u00b6 On-line courses, blog posts, and reports related to open transit data. On-line courses \u00b6 World Bank - \"Intro. to GTFS\" online course - A free, online, self-paced course for learning about GTFS and GTFS-realtime. Open Transit Data Toolkit - A series of lessons to help people utilize open transit data. MBTA GTFS Onboarding - An interactive tutorial created by MBTA for GTFS static. A stand-alone Docker image is available on GitHub as well as a hosted/no-install version of the Jupyter notebook. Planetizen \"Building a Transit Map Web App\" course - A video tutorial on setting up your own web-based mapping application, with no coding experience required. Blog posts \u00b6 When(ish) is my bus? Data and code - The data and code (R) behind Whenish is my bus? Data includes three days of historical vehicle positions and the survey results. \"Legacy AVL system? It's okay, join the club.\" by Kurt Raschke - Discussion of options for transforming legacy AVL system data into the GTFS-realtime format. \"GTFS Best Practices now available!\" by Sean Barbeau - Discusses some of the challenges of an open data format like GTFS and the GTFS Best Practices that were launched in early 2017 to help address data quality. \"What's new in GTFS-realtime v2.0\" by Sean Barbeau - Discuss the shortfalls in GTFS-realtime v1.0 and the improvements in v2.0. \"AVL, CAD, and Real-Time Passenger Info for Beginners\" by Tony Laidig - Provides a general introduction to technology used to track vehicles. \"Visualizing Better Transportation: Data & Tools\" by Steve Pepple - A collection of transportation-related data and tools for the San Francisco Bay Area and other cities in North America, originally collected and discussed at a 2018 Transit Week Event at ARUP in San Francisco. \"How to use GTFS data to track transit vehicles in realtime\" by Tom Camp - Using GTFS and GTFS Realtime to provide continuous realtime updates. Academic papers \u00b6 Tang et al. - \"Ridership effects of real-time bus information system: A case study in the City of Chicago\" - Experiment in Chicago, IL showed modest increase in ridership when riders had access to real-time info via text message or email. Kay et al. - \"When(ish) is my bus? User-centered Visualizations of Uncertainty in Everyday, Mobile Predictive Systems\" - Paper attempts to answr the question of \"how do we communicate uncertainty in transit predictions?\" Explains the problem, existing solutions and designs a better interface for letting users know when to arrive at the bus stop . Watkins et al. - \"Where Is My Bus? Impact of mobile real-time information on the perceived and actual wait time of transit riders\" - Experiments in Seattl,e WA showed that riders perceived shorter bus wait times when they had access to real-time info via mobile apps. Brakewood et al. - \u201cAn experiment evaluating the impacts of real-time transit information on bus riders in Tampa, Florida\u201d - Controlled experiment in Tampa, FL showed that riders with access to real-time info via mobile apps perceived nearly 2 minute reduction in wait times compared to riders without real-time info. Riders with real-time info also had decreases in anxiety and frustration and better reception of agency. Brakewood et al. - \"The impact of real-time information on bus ridership in New York City\" - Experiment in NYC showed that ridership increased on long routes when real-time info was made available to riders. Brakewood and Watkins - \"A literature review of the passenger benefits of real-time transit information\" (2018) - An overview of many different research studies looking at the benefits of real-time transit information. Gramacki et al. - \"gtfs2vec - Learning GTFS Embeddings for comparing Public Transport Offer in Microregions\" - Methology using Uber's H3 spatial index and machine learning to identify areas of \"similar\" public transit service quality in cities. Source code available on GitHub . Higgins et al. - \"Calculating place-based transit accessibility: Methods, tools and algorithmic dependence\" (2022) - Compares software tools for calculating accessibility by walking and public transit including ArcGIS Pro, Emme, R5R, and OpenTripPlanner. Aemmer et al. - \"Measurement and classification of transit delays using GTFS-RT data\" - Presents a method for extracting transit performance metrics from a General Transit Feed Specification\u2019s Real-Time (GTFS-RT) component and aggregating them to roadway segments. Used with Transit Vis , viewable here . Government reports \u00b6 APTA Policy Development and Research - Public Transportation Embracing Open Data - APTA's discussion of the benefits and challenges of open transit data (a short summary of the below TCRP report). TCRP Synthesis 115 - Open Data: Challenges and Opportunities for Transit Agencies (2015) - A comprehensive report looking at the benefits and challenges of open transit data. TCRP Research Report 213: Data Sharing Guidance for Public Transit Agencies \u2013 Now and in the Future (2020) - A report designed to help agencies make decisions about sharing their data, including how to evaluate benefits, costs, and risks. TCRP G-16 Development of Transactional Data Specifications for Demand-Responsive Transportation (In progress) - The objective of this research is to develop technical specifications for transactional data for entities involved in the provision of demand-responsive transportation. Expected completion date is late 2018. Community-maintained lists \u00b6 Vendors Providing GTFS Creation/Maintenance services - Add new vendors here . Entities Providing Transportation Software Development Consulting Services - Add new entities here .","title":"Other Resources"},{"location":"resources/other/#other-resources","text":"On-line courses, blog posts, and reports related to open transit data.","title":"Other Resources"},{"location":"resources/other/#on-line-courses","text":"World Bank - \"Intro. to GTFS\" online course - A free, online, self-paced course for learning about GTFS and GTFS-realtime. Open Transit Data Toolkit - A series of lessons to help people utilize open transit data. MBTA GTFS Onboarding - An interactive tutorial created by MBTA for GTFS static. A stand-alone Docker image is available on GitHub as well as a hosted/no-install version of the Jupyter notebook. Planetizen \"Building a Transit Map Web App\" course - A video tutorial on setting up your own web-based mapping application, with no coding experience required.","title":"On-line courses"},{"location":"resources/other/#blog-posts","text":"When(ish) is my bus? Data and code - The data and code (R) behind Whenish is my bus? Data includes three days of historical vehicle positions and the survey results. \"Legacy AVL system? It's okay, join the club.\" by Kurt Raschke - Discussion of options for transforming legacy AVL system data into the GTFS-realtime format. \"GTFS Best Practices now available!\" by Sean Barbeau - Discusses some of the challenges of an open data format like GTFS and the GTFS Best Practices that were launched in early 2017 to help address data quality. \"What's new in GTFS-realtime v2.0\" by Sean Barbeau - Discuss the shortfalls in GTFS-realtime v1.0 and the improvements in v2.0. \"AVL, CAD, and Real-Time Passenger Info for Beginners\" by Tony Laidig - Provides a general introduction to technology used to track vehicles. \"Visualizing Better Transportation: Data & Tools\" by Steve Pepple - A collection of transportation-related data and tools for the San Francisco Bay Area and other cities in North America, originally collected and discussed at a 2018 Transit Week Event at ARUP in San Francisco. \"How to use GTFS data to track transit vehicles in realtime\" by Tom Camp - Using GTFS and GTFS Realtime to provide continuous realtime updates.","title":"Blog posts"},{"location":"resources/other/#academic-papers","text":"Tang et al. - \"Ridership effects of real-time bus information system: A case study in the City of Chicago\" - Experiment in Chicago, IL showed modest increase in ridership when riders had access to real-time info via text message or email. Kay et al. - \"When(ish) is my bus? User-centered Visualizations of Uncertainty in Everyday, Mobile Predictive Systems\" - Paper attempts to answr the question of \"how do we communicate uncertainty in transit predictions?\" Explains the problem, existing solutions and designs a better interface for letting users know when to arrive at the bus stop . Watkins et al. - \"Where Is My Bus? Impact of mobile real-time information on the perceived and actual wait time of transit riders\" - Experiments in Seattl,e WA showed that riders perceived shorter bus wait times when they had access to real-time info via mobile apps. Brakewood et al. - \u201cAn experiment evaluating the impacts of real-time transit information on bus riders in Tampa, Florida\u201d - Controlled experiment in Tampa, FL showed that riders with access to real-time info via mobile apps perceived nearly 2 minute reduction in wait times compared to riders without real-time info. Riders with real-time info also had decreases in anxiety and frustration and better reception of agency. Brakewood et al. - \"The impact of real-time information on bus ridership in New York City\" - Experiment in NYC showed that ridership increased on long routes when real-time info was made available to riders. Brakewood and Watkins - \"A literature review of the passenger benefits of real-time transit information\" (2018) - An overview of many different research studies looking at the benefits of real-time transit information. Gramacki et al. - \"gtfs2vec - Learning GTFS Embeddings for comparing Public Transport Offer in Microregions\" - Methology using Uber's H3 spatial index and machine learning to identify areas of \"similar\" public transit service quality in cities. Source code available on GitHub . Higgins et al. - \"Calculating place-based transit accessibility: Methods, tools and algorithmic dependence\" (2022) - Compares software tools for calculating accessibility by walking and public transit including ArcGIS Pro, Emme, R5R, and OpenTripPlanner. Aemmer et al. - \"Measurement and classification of transit delays using GTFS-RT data\" - Presents a method for extracting transit performance metrics from a General Transit Feed Specification\u2019s Real-Time (GTFS-RT) component and aggregating them to roadway segments. Used with Transit Vis , viewable here .","title":"Academic papers"},{"location":"resources/other/#government-reports","text":"APTA Policy Development and Research - Public Transportation Embracing Open Data - APTA's discussion of the benefits and challenges of open transit data (a short summary of the below TCRP report). TCRP Synthesis 115 - Open Data: Challenges and Opportunities for Transit Agencies (2015) - A comprehensive report looking at the benefits and challenges of open transit data. TCRP Research Report 213: Data Sharing Guidance for Public Transit Agencies \u2013 Now and in the Future (2020) - A report designed to help agencies make decisions about sharing their data, including how to evaluate benefits, costs, and risks. TCRP G-16 Development of Transactional Data Specifications for Demand-Responsive Transportation (In progress) - The objective of this research is to develop technical specifications for transactional data for entities involved in the provision of demand-responsive transportation. Expected completion date is late 2018.","title":"Government reports"},{"location":"resources/other/#community-maintained-lists","text":"Vendors Providing GTFS Creation/Maintenance services - Add new vendors here . Entities Providing Transportation Software Development Consulting Services - Add new entities here .","title":"Community-maintained lists"},{"location":"resources/sdk/","text":"SDKs \u00b6 Citymapper SDK - Allows you to add journey planning and turn-by-turn navigation for walking, cycling, scooting and transit into native iOS and Android apps.","title":"SDKs"},{"location":"resources/sdk/#sdks","text":"Citymapper SDK - Allows you to add journey planning and turn-by-turn navigation for walking, cycling, scooting and transit into native iOS and Android apps.","title":"SDKs"},{"location":"resources/siri/","text":"SIRI \u00b6 SIRI API - Java classes generated from the v1.0 and v1.3 SIRI schemas. SIRI 2.0 API - Java classes generated from the v2.0 SIRI schemas. SIRI to GTFS-realtime - A Java-based command-line utility to convert from the SIRI format to GTFS-realtime. SIRI 2.0 Autodoc - Automatically generated documentation from the (incredibly well) annotated SIRI 2.0 Schema Definition. King County Metro Legacy AVL to SIRI - Java-based tool to convert King County Metro's Legacy AVL format to SIRI. SIRI REST Client - An open-source Android library for interacting with the RESTful SIRI interface for real-time transit data, such as that currently being used by the MTA Bus Time API . SIRI 1.3 POJOs (Android-compatible) - Android-compatible Plain Old Java Objects (POJOSs) used for data binding (deserliazing XML/JSON) responses for SIRI v1.3 APIs. Used by the SIRI REST Client . pysiri2validator - Simple validator for SIRI 2.0 written in Python 3. Edwig - A golang server for real-time public transport data exchange, using the SIRI protocol.","title":"SIRI"},{"location":"resources/siri/#siri","text":"SIRI API - Java classes generated from the v1.0 and v1.3 SIRI schemas. SIRI 2.0 API - Java classes generated from the v2.0 SIRI schemas. SIRI to GTFS-realtime - A Java-based command-line utility to convert from the SIRI format to GTFS-realtime. SIRI 2.0 Autodoc - Automatically generated documentation from the (incredibly well) annotated SIRI 2.0 Schema Definition. King County Metro Legacy AVL to SIRI - Java-based tool to convert King County Metro's Legacy AVL format to SIRI. SIRI REST Client - An open-source Android library for interacting with the RESTful SIRI interface for real-time transit data, such as that currently being used by the MTA Bus Time API . SIRI 1.3 POJOs (Android-compatible) - Android-compatible Plain Old Java Objects (POJOSs) used for data binding (deserliazing XML/JSON) responses for SIRI v1.3 APIs. Used by the SIRI REST Client . pysiri2validator - Simple validator for SIRI 2.0 written in Python 3. Edwig - A golang server for real-time public transport data exchange, using the SIRI protocol.","title":"SIRI"},{"location":"resources/software-for-creating-apis/","text":"Software for Creating APIs \u00b6 Software that you can set up to provide an API to transit and multimodal data. GraphHopper Routing Engine Open source routing engine for OpenStreetMap. Use it as Java library or server. gtfs-server - A web server, written in Rust that uses PostGIS as a backend to serve GTFS data via a HTTP endpoint hafas-rest-api \u2013 Expose a HAFAS endpoint as a REST API. Linked Connections - An open-source, scalable intermodal route planning engine, which allows clients to execute the route planning algorithm (as opposed to the server). Uses GTFS data. MOTIS - Multi Objective Travel Information System, written in C++ and Java. Can consume schedule timetables in the GTFS or HAFAS format as well as real time information in the GTFS-RT (and RISML, a propriatary format at Deutsche Bahn) as input data. For pedestrian routing (handled by Per Pedes Routing) and car routing (handled by OSRM) OpenStreetMap data is used. Navitia is the opensource engine behind the Navitia.io live API. OneBusAway - A Java app that consumes GTFS and GTFS-Realtime (along with other formats ) and turns them into an easy to use REST API . OpenTripPlanner - An open source platform for multi-modal and multi-agency journey planning, as well as returning information about a multi-modal graph (using data sources such as GTFS and OpenStreetMap ). pyBikes - Software powering CityBikes for worldwide bikeshare system info TransitClock - Java application that can consume raw vehicle positions and generate prediction times in formats such as GTFS-realtime. Formerly known as \"Transitime\". TransiCast - Provides public transportation data for North America in a single, integrated call and response format. The data is provided in stream-parsable XML and JSON formats. Open-source on Google Code . Hosted version at www.transitcast.com requires payment .","title":"Software for Creating APIs"},{"location":"resources/software-for-creating-apis/#software-for-creating-apis","text":"Software that you can set up to provide an API to transit and multimodal data. GraphHopper Routing Engine Open source routing engine for OpenStreetMap. Use it as Java library or server. gtfs-server - A web server, written in Rust that uses PostGIS as a backend to serve GTFS data via a HTTP endpoint hafas-rest-api \u2013 Expose a HAFAS endpoint as a REST API. Linked Connections - An open-source, scalable intermodal route planning engine, which allows clients to execute the route planning algorithm (as opposed to the server). Uses GTFS data. MOTIS - Multi Objective Travel Information System, written in C++ and Java. Can consume schedule timetables in the GTFS or HAFAS format as well as real time information in the GTFS-RT (and RISML, a propriatary format at Deutsche Bahn) as input data. For pedestrian routing (handled by Per Pedes Routing) and car routing (handled by OSRM) OpenStreetMap data is used. Navitia is the opensource engine behind the Navitia.io live API. OneBusAway - A Java app that consumes GTFS and GTFS-Realtime (along with other formats ) and turns them into an easy to use REST API . OpenTripPlanner - An open source platform for multi-modal and multi-agency journey planning, as well as returning information about a multi-modal graph (using data sources such as GTFS and OpenStreetMap ). pyBikes - Software powering CityBikes for worldwide bikeshare system info TransitClock - Java application that can consume raw vehicle positions and generate prediction times in formats such as GTFS-realtime. Formerly known as \"Transitime\". TransiCast - Provides public transportation data for North America in a single, integrated call and response format. The data is provided in stream-parsable XML and JSON formats. Open-source on Google Code . Hosted version at www.transitcast.com requires payment .","title":"Software for Creating APIs"},{"location":"resources/visualizations/","text":"Visualizations \u00b6 All Transit - Interactive GTFS route and schedule animation (for U.S. cities) using Mapbox GL JS, Deck.gl and Transitland. Github repository here . fastest-bus-analysis-in-the-west - A python Pandas script that combines Ridership/APC, Swiftly speed and dwell data, bus stop inventory, GTFS, and geospatial shapes to create a stop by stop, route by route, time grouping filterable dataset for cross-analyses. The dataset is then visualized in Tableau to help VTA Planners find places to make bus and rail network faster and more reliable through speedups methods like stop consolidation and dedicated lanes. gtfspy-webviz - Web application for animation and visualization of GTFS data using gtfspy . gtfs-visualizations - Open-source NodeJS application for visualizing the routes of GTFS datasets. Mapnificent - Shows areas you can reach with public transport in a given time. Open-source on GitHub , live at https://www.mapnificent.net/. MIT COAXS - Co-creative Planning of Transit Corridors using Accessibility-Based Stakeholder Engagement (shows route scenarios using OpenTripPlanner Analyst ). MOTIS - Intermodal Mobility Information System including visualization MTA Frequency - Frequency visualization of subways and buses in New York City built using Transitland . SEPTA Rail OTP Report - An online on-time performance reporing & drill down tool using GTFS. TNExT - Transit Network Explorer Tool (TNExT) is a web-based software tool developed for the visualization, analysis, and reporting of regional and statewide transit networks in the state of Oregon. Toronto Transit Explorer - A Java application that visualizes transit, biking and walking accessibility across the city of Toronto. Live version hosted here . Uses a modified version of R5 for routing. Transit Vis - A visualization tool to display performance metrics derived from the King County Metro GTFS-RT feed (OneBusAway API). Viewable here . Used for this paper . TransitFlow Animate GTFS data around the world using Processing and Transitland. TRAVIC Transit Visualization Client - Visualizes vehicles moving based on static GTFS data (and sometimes realtime data). Supports over 260 cities. Github account for geOps organization is here . Traze by Veridict - Visualization of public transport vehicles from all over the world. Collaborate with other users to get real-time updates even when it is not available from the agency. Based on a number of sources, including GTFS and GTFS-RT. (Previously known as Livemap24 ). Visualizing MBTA Data - Interactive graphs that show how people use Boston's subway system.","title":"Visualizations"},{"location":"resources/visualizations/#visualizations","text":"All Transit - Interactive GTFS route and schedule animation (for U.S. cities) using Mapbox GL JS, Deck.gl and Transitland. Github repository here . fastest-bus-analysis-in-the-west - A python Pandas script that combines Ridership/APC, Swiftly speed and dwell data, bus stop inventory, GTFS, and geospatial shapes to create a stop by stop, route by route, time grouping filterable dataset for cross-analyses. The dataset is then visualized in Tableau to help VTA Planners find places to make bus and rail network faster and more reliable through speedups methods like stop consolidation and dedicated lanes. gtfspy-webviz - Web application for animation and visualization of GTFS data using gtfspy . gtfs-visualizations - Open-source NodeJS application for visualizing the routes of GTFS datasets. Mapnificent - Shows areas you can reach with public transport in a given time. Open-source on GitHub , live at https://www.mapnificent.net/. MIT COAXS - Co-creative Planning of Transit Corridors using Accessibility-Based Stakeholder Engagement (shows route scenarios using OpenTripPlanner Analyst ). MOTIS - Intermodal Mobility Information System including visualization MTA Frequency - Frequency visualization of subways and buses in New York City built using Transitland . SEPTA Rail OTP Report - An online on-time performance reporing & drill down tool using GTFS. TNExT - Transit Network Explorer Tool (TNExT) is a web-based software tool developed for the visualization, analysis, and reporting of regional and statewide transit networks in the state of Oregon. Toronto Transit Explorer - A Java application that visualizes transit, biking and walking accessibility across the city of Toronto. Live version hosted here . Uses a modified version of R5 for routing. Transit Vis - A visualization tool to display performance metrics derived from the King County Metro GTFS-RT feed (OneBusAway API). Viewable here . Used for this paper . TransitFlow Animate GTFS data around the world using Processing and Transitland. TRAVIC Transit Visualization Client - Visualizes vehicles moving based on static GTFS data (and sometimes realtime data). Supports over 260 cities. Github account for geOps organization is here . Traze by Veridict - Visualization of public transport vehicles from all over the world. Collaborate with other users to get real-time updates even when it is not available from the agency. Based on a number of sources, including GTFS and GTFS-RT. (Previously known as Livemap24 ). Visualizing MBTA Data - Interactive graphs that show how people use Boston's subway system.","title":"Visualizations"},{"location":"schedule/","text":"GTFS Schedule Overview \u00b6 Reference Best Practices Examples Changes Getting Started \u00b6 A GTFS feed, which contains static transit information, is composed of a number of text (.txt) files that are contained in a single ZIP file. Each file describes a particular aspect of transit information: stops, routes, trips, fares, etc. For more information about each file, consult the GTFS reference. In order to create a GTFS feed follow the steps below. Create all the required files described in the GTFS Schedule reference. Create the optional files if their functionality is desired. Save all files in the .txt format. Field values should be comma delimited and each line should end with a line break. See the GTFS reference for detailed information on the file contents. Zip all the text files together. The zipped file comprises a version of the feed. Publish the feed by using one of the options below. Making a Transit Feed Publicly Available \u00b6 Datasets should be published at a public, permanent URL, including the zip file name. (e.g., www.agency.org/gtfs/gtfs.zip). Ideally, the URL should be directly downloadable without requiring login to access the file, to facilitate download by consuming software applications. While it is recommended (and the most common practice) to make a GTFS dataset openly downloadable, if a data provider does need to control access to GTFS for licensing or other reasons, it is recommended to control access to the GTFS dataset using API keys, which will facilitate automatic downloads. The web-server hosting GTFS data should be configured to correctly report the file modification date (see HTTP/1.1 - Request for Comments 2616, under Section 14.29). See \u201c Best Practices: Dataset Publishing \u201d for further recommendations. Training \u00b6 The World Bank Open Learning Campus (OLC) offers a self-based online course called \u201c Introduction to the General Transit Feed Specification (GTFS) and Informal Transit System Mapping \u201d. This course includes the following sections: What is GTFS? History & File Structure What is GTFS? Visualization & Community Setting up a GTFS Feed Introduction to GitHub & Open Source Tools Stories from the Field How to Map Transit Data How to Collect Data for a City\u2019s First Feed App Survey GTFS-Realtime See more online courses . Getting Help & Community \u00b6 Mailing Lists \u00b6 There are a number of mailing lists that can be good resources when you have questions about public transit data, software, formats like GTFS and GTFS-realtime, and other issues: GTFS Changes : discussion of proposal for extending the GTFS specification. GTFS Slack : Slack \"organization\" at with channels devoted to GTFS topics. Request an invite to gtfs.slack.com here . Transit Developers : general transit developer discussions. Many transit agencies also have their own developer mailing lists specific to the agency. For example: NYC MTA Portland, OR BART - San Francisco, CA MassDOT Atlanta, GA region 511 San Francisco Bay Area Developer Resources Check with your local transit agency to see if they have a mailing list of their own. See more community resources .","title":"Getting Started"},{"location":"schedule/#gtfs-schedule-overview","text":"Reference Best Practices Examples Changes","title":"GTFS Schedule Overview"},{"location":"schedule/#getting-started","text":"A GTFS feed, which contains static transit information, is composed of a number of text (.txt) files that are contained in a single ZIP file. Each file describes a particular aspect of transit information: stops, routes, trips, fares, etc. For more information about each file, consult the GTFS reference. In order to create a GTFS feed follow the steps below. Create all the required files described in the GTFS Schedule reference. Create the optional files if their functionality is desired. Save all files in the .txt format. Field values should be comma delimited and each line should end with a line break. See the GTFS reference for detailed information on the file contents. Zip all the text files together. The zipped file comprises a version of the feed. Publish the feed by using one of the options below.","title":"Getting Started"},{"location":"schedule/#making-a-transit-feed-publicly-available","text":"Datasets should be published at a public, permanent URL, including the zip file name. (e.g., www.agency.org/gtfs/gtfs.zip). Ideally, the URL should be directly downloadable without requiring login to access the file, to facilitate download by consuming software applications. While it is recommended (and the most common practice) to make a GTFS dataset openly downloadable, if a data provider does need to control access to GTFS for licensing or other reasons, it is recommended to control access to the GTFS dataset using API keys, which will facilitate automatic downloads. The web-server hosting GTFS data should be configured to correctly report the file modification date (see HTTP/1.1 - Request for Comments 2616, under Section 14.29). See \u201c Best Practices: Dataset Publishing \u201d for further recommendations.","title":"Making a Transit Feed Publicly Available"},{"location":"schedule/#training","text":"The World Bank Open Learning Campus (OLC) offers a self-based online course called \u201c Introduction to the General Transit Feed Specification (GTFS) and Informal Transit System Mapping \u201d. This course includes the following sections: What is GTFS? History & File Structure What is GTFS? Visualization & Community Setting up a GTFS Feed Introduction to GitHub & Open Source Tools Stories from the Field How to Map Transit Data How to Collect Data for a City\u2019s First Feed App Survey GTFS-Realtime See more online courses .","title":"Training"},{"location":"schedule/#getting-help-community","text":"","title":"Getting Help &amp; Community"},{"location":"schedule/#mailing-lists","text":"There are a number of mailing lists that can be good resources when you have questions about public transit data, software, formats like GTFS and GTFS-realtime, and other issues: GTFS Changes : discussion of proposal for extending the GTFS specification. GTFS Slack : Slack \"organization\" at with channels devoted to GTFS topics. Request an invite to gtfs.slack.com here . Transit Developers : general transit developer discussions. Many transit agencies also have their own developer mailing lists specific to the agency. For example: NYC MTA Portland, OR BART - San Francisco, CA MassDOT Atlanta, GA region 511 San Francisco Bay Area Developer Resources Check with your local transit agency to see if they have a mailing list of their own. See more community resources .","title":"Mailing Lists"},{"location":"schedule/best-practices/","text":"GTFS Schedule Best Practices \u00b6 These are recommended practices for describing public transportation services in the General Transit Feed Specification (GTFS) . These practices have been synthesized from the experience of the GTFS Best Practices working group members and application-specific GTFS practice recommendations . For further background, see the Frequently Asked Questions . Document Structure \u00b6 Practices are organized into four primary sections: Dataset Publishing & General Practices : These practices relate to the overall structure of the GTFS dataset and to the manner in which GTFS datasets are published. Practice Recommendations Organized by File : Recommendations are organized by file and field in the GTFS to facilitate mapping practices back to the official GTFS reference. Practice Recommendations Organized by Case : With particular cases, such as loop routes, practices may need to be applied across several files and fields. Such recommendations are consolidated in this section. Dataset Publishing & General Practices \u00b6 Datasets should be published at a public, permanent URL, including the zip file name. (e.g., www.agency.org/gtfs/gtfs.zip). Ideally, the URL should be directly downloadable without requiring login to access the file, to facilitate download by consuming software applications. While it is recommended (and the most common practice) to make a GTFS dataset openly downloadable, if a data provider does need to control access to GTFS for licensing or other reasons, it is recommended to control access to the GTFS dataset using API keys, which will facilitate automatic downloads. GTFS data is published in iterations so that a single file at a stable location always contains the latest official description of service for a transit agency (or agencies). Maintain persistent identifiers (id fields) for stop_id , route_id , and agency_id across data iterations whenever possible. One GTFS dataset should contain current and upcoming service (sometimes called a \u201cmerged\u201d dataset). Google transitfeed tool's merge function can be used to create a merged dataset from two different GTFS feeds. At any time, the published GTFS dataset should be valid for at least the next 7 days, and ideally for as long as the operator is confident that the schedule will continue to be operated. If possible, the GTFS dataset should cover at least the next 30 days of service. Remove old services (expired calendars) from the feed. If a service modification will go into effect in 7 days or fewer, express this service change through a GTFS-realtime feed (service advisories or trip updates) rather than static GTFS dataset. The web-server hosting GTFS data should be configured to correctly report the file modification date (see HTTP/1.1 - Request for Comments 2616 , under Section 14.29). Practice Recommendations Organized by File \u00b6 This section shows practices organized by file and field, aligning with the GTFS reference . All Files \u00b6 Field Name Recommendation Mixed Case All customer-facing text strings (including stop names, route names, and headsigns) should use Mixed Case (not ALL CAPS), following local conventions for capitalization of place names on displays capable of displaying lower case characters. Examples: Brighton Churchill Square Villiers-sur-Marne Market Street Abbreviations Avoid use of abbreviations throughout the feed for names and other text (e.g. St. for Street) unless a location is called by its abbreviated name (e.g. \u201cJFK Airport\u201d). Abbreviations may be problematic for accessibility by screen reader software and voice user interfaces. Consuming software can be engineered to reliably convert full words to abbreviations for display, but converting from abbreviations to full words is prone to more risk of error. agency.txt \u00b6 Field Name Recommendation agency_id Should be included, even if there is only one agency in the feed. (See also recommendation to include agency_id in routes.txt and fare_attributes.txt ) agency_phone Should be included unless no such customer service phone exists. agency_email Should be included unless no such customer service email exists. agency_fare_url Should be included unless the agency is fully fare-free. Examples: Bus services are run by several small bus agencies. But there is one big agency that is responsible for scheduling and ticketing and from a user\u2019s perspective responsible for the bus services.The one big agency should be defined as agency within the feed. Even if the data is split internally by different small bus operators there should only be one agency defined in the feed. The feed provider runs the ticketing portal, but there are different agencies that actually operate the services and are known by users to be responsible. The agencies actually operating the services should be defined as agencies within the feed. stops.txt \u00b6 Field Name Recommendation stop_name When there is not a published stop name, follow consistent stop naming conventions throughout the feed. By default, stop_name should not contain generic or redundant words like \u201cStation\u201d or \u201cStop\u201d, but some edge cases are allowed. When it is actually part of the name (Union Station, Central Station When the stop_name is too generic (such as if it is the name of the city). \u201cStation\u201d, \u201cTerminal\u201d, or other words make the meaning clear. stop_lat & stop_lon Stop locations should be as accurate possible. Stop locations should have an error of no more than four meters when compared to the actual stop position. Stop locations should be placed very near to the pedestrian right of way where a passenger will board (i.e. correct side of the street). If a stop location is shared across separate data feeds (i.e. two agencies use exactly the same stop / boarding facility), indicate the stop is shared by using the exact same stop_lat and stop_lon for both stops. parent_station & location_type Many stations or terminals have multiple boarding facilities (depending on mode, they might be called a bus bay, platform, wharf, gate, or another term). In such cases, feed producers should describe stations, boarding facilities (also called child stops), and their relation. The station or terminal should be defined as a record in stops.txt with location_type = 1 . Each boarding facility should be defined as a stop with location_type = 0 . The parent_station field should reference the stop_id of the station the boarding facility is in. When naming the station and child stops, set names that are well-recognized by riders, and can help riders to identify the station and boarding facility (bus bay, platform, wharf, gate, etc.). Parent Station Name Child Stop Name Chicago Union Station Chicago Union Station Platform 19 San Francisco Ferry Building Terminal San Francisco Ferry Building Terminal Gate E Downtown Transit Center Downtown Transit Center Bay B routes.txt \u00b6 Field Name Recommendation route_short_name Include route_short_name if there is a brief service designation. This should be the commonly-known passenger name of the service, no longer than 12 characters. route_long_name The definition from Specification reference: This name is generally more descriptive than the route_short_name and will often include the route's destination or stop. At least one of route_short_name or route_long_name must be specified, or potentially both if appropriate. If the route does not have a long name, please specify a route_short_name and use an empty string as the value for this field. Examples of types of long names are below: Primary Travel Path or Corridor Route Name Form Agency \u201cN\u201d/\u201cJudah\u201d route_short_name / route_long_name Muni , in San Francisco \u201c6\u201c/\u201cML King Jr Blvd\u201c route_short_name / route_long_name TriMet , in Portland, Or. \u201c6\u201d/\u201cNation - \u00c9toile\u201d route_short_name / route_long_name RATP , in Paris France. \u201cU2\u201d-\u201cPankow \u2013 Ruhleben\u201d route_short_name - route_long_name BVG , in Berlin, Germany Description of the Service \u201cHartwell Area Shuttle\u201c route_long_name should not contain the route_short_name . Include the full designation including a service identity when populating route_long_name . Examples: Service Identity Recommendation Examples \"MAX Light Rail\" TriMet, in Portland, Oregon The route_long_name should include the brand (MAX) and the specific route designation \"MAX Red Line\" \"MAX Blue Line\" \"Rapid Ride\" ABQ Ride, in Albuquerque, New Mexico The route_long_name should include the brand (Rapid Ride) and the specific route designation \"Rapid Ride Red Line\" \"Rapid Ride Blue Line\" route_id All trips on a given named route should reference the same route_id . Different directions of a route should not be separated into different route_id values. Different spans of operation of a route should not be separated into different route_id values. i.e. do not create different records in routes.txt for \u201cDowntown AM\u201d and \u201cDowntown PM\u201d services). If a route group includes distinctly named branches (e.g. 1A and 1B), follow recommendations in the route branches case to determine route_short_name and route_long_name . route_color & route_text_color Should be consistent with signage and printed and online customer information (and thus not included if they do not exist in other places). trips.txt \u00b6 See special case for loop routes: Loop routes are cases where trips start and end at the same stop, as opposed to linear routes, which have two distinct termini. Loop routes must be described following specific practices. See Loop route case. See special case for lasso routes: Lasso routes are a hybrid of linear and loop geometries, in which vehicles travel on a loop for only a portion of the route. Lasso routes must be described following specific practices. See Lasso route case. Field Name Recommendation trip_headsign Do not provide route names (matching route_short_name and route_long_name ) in the trip_headsign or stop_headsign fields. Should contain destination, direction, and/or other trip designation text shown on the headsign of the vehicle which may be used to distinguish amongst trips in a route. Consistency with direction information shown on the vehicle is the primary and overriding goal for determining headsigns supplied in GTFS datasets. Other information should be included only if it does not compromise this primary goal. If headsigns change during a trip, override trip_headsign with stop_times.stop_headsign . Below are recommendations for some possible cases: Route Description Recommendation 2A. Destination-only Provide the terminus destination. e.g. \"Transit Center\", \u201cPortland City Center\u201d, or \u201cJantzen Beach\u201d> 2B. Destinations with waypoints <destination> via <waypoint> \u201cHighgate via Charing Cross\u201d. If waypoint(s) are removed from the headsign show to passengers after the vehicle passes those waypoints, use stop_times.stop_headsign to set an updated headsign.> 2C. Regional placename with local stops If there will be multiple stops inside the city or borough of destination, use stop_times.stop_headsign once reaching the destination city.> 2D. Direction-only Indicate using terms such as \u201cNorthbound\u201d, \u201cInbound\u201d, \u201cClockwise,\u201d or similar directions.> 2E. Direction with destination <direction> to <terminus name> e.g. \u201cSouthbound to San Jose\u201d> 2F. Direction with destination and waypoints <direction> via <waypoint> to <destination> (\u201cNorthbound via Charing Cross to Highgate\u201d).> Do not begin a headsign with the words \u201cTo\u201d or \u201cTowards\u201d. direction_id Use values 0 and 1 consistently throughout the dataset. i.e. If 1 = Outbound on the Red route, then 1 = Outbound on the Green route If 1 = Northbound on Route X, then 1 = Northbound on Route Y If 1 = clockwise on Route X then 1 = clockwise on Route Y stop_times.txt \u00b6 Loop routes: Loop routes require special stop_times considerations. (See: Loop route case ) Field Name Recommendation pickup_type & drop_off_type Non-revenue (deadhead) trips that do not provide passenger service should be marked with pickup_type and drop_off_type value of 1 for all stop_times rows. On revenue trips, internal \u201ctiming points\u201d for monitoring operational performance and other places such as garages that a passenger cannot board should be marked with pickup_type = 1 (no pickup available) and drop_off_type = 1 (no drop off available). arrival_time & departure_time arrival_time and departure_time fields should specify time values whenever possible, including non-binding estimated or interpolated times between timepoints. stop_headsign In general, headsign values should also correspond to signs in the stations. In the cases below, \u201cSouthbound\u201d would mislead customers because it is not used in the station signs. In NYC, for the 2 going Southbound: For stop_times.txt rows: Use stop_headsign value: Until Manhattan is Reached Manhattan & Brooklyn Until Downtown is Reached Downtown & Brooklyn Until Brooklyn is Reached Brooklyn Once Brooklyn is Reached Brooklyn (New Lots Av) In Boston, for the Red Line going Southbound, for the Braintree branch: For stop_times.txt rows: Use stop_headsign value: Until Downtown is Reached Inbound to Braintree Once Downtown is Reached Braintree After Downtown Outbound to Braintree shape_dist_traveled shape_dist_traveled must be provided for routes that have looping or inlining (the vehicle crosses or travels over the same portion of alignment in one trip). See the shapes.shape_dist_traveled recommendation. calendar.txt \u00b6 Field Name Recommendation All Fields Including a calendar.service_name field can also increase the human readability of GTFS, although this is not adopted in the spec. calendar_dates.txt \u00b6 Field Name Recommendation All Fields Including a calendar.service_name field can also increase the human readability of GTFS, although this is not adopted in the spec. fare_attributes.txt \u00b6 Field Name Recommendation All Fields agency_id should be included in fare_attributes.txt if it the field is included in agency.txt . If a fare system cannot be accurately modeled, avoid further confusion and leave it blank. Include fares ( fare_attributes.txt and fare_rules.txt ) and model them as accurately as possible. In edge cases where fares cannot be accurately modeled, the fare should be represented as more expensive rather than less expensive so customers will not attempt to board with insufficient fare. If the vast majority of fares cannot be modeled correctly, do not include fare information in the feed. fare_rules.txt \u00b6 Field Name Recommendation All Fields If a fare system cannot be accurately modeled, avoid further confusion and leave it blank. Include fares ( fare_attributes.txt and fare_rules.txt ) and model them as accurately as possible. In edge cases where fares cannot be accurately modeled, the fare should be represented as more expensive rather than less expensive so customers will not attempt to board with insufficient fare. If the vast majority of fares cannot be modeled correctly, do not include fare information in the feed. shapes.txt \u00b6 Field Name Recommendation All Fields Ideally, for alignments that are shared (i.e. in a case where Routes 1 and 2 operate on the same segment of roadway or track) then the shared portion of alignment should match exactly. This helps to facilitate high-quality transit cartography. Alignments should follow the centerline of the right of way on which the vehicle travels. This could be either the centerline of the street if there are no designated lanes, or the centerline of the side of the roadway that travels in the direction the vehicle moves. Alignments should not \u201cjag\u201d to a curb stop, platform, or boarding location. shape_dist_traveled Must be provided in both shapes.txt and stop_times.txt if an alignment includes looping or inlining (the vehicle crosses or travels over the same portion of alignment in one trip). If a vehicle retraces or crosses the route alignment at points in the course of a trip, shape_dist_traveled is important to clarify how portions of the points in shapes.txt line up correspond with records in stop_times.txt . The shape_dist_traveled field allows the agency to specify exactly how the stops in the stop_times.txt file fit into their respective shape. A common value to use for the shape_dist_traveled field is the distance from the beginning of the shape as traveled by the vehicle (think something like an odometer reading). Route alignments (in shapes.txt ) should be within 100 meters of stop locations which a trip serves. Simplify alignments so that shapes.txt does not contain extraneous points (i.e. remove extra points on straight-line segments; see discussion of line simplification problem). frequencies.txt \u00b6 Field Name Recommendation All Fields Actual stop times are ignored for trips referenced by frequencies.txt ; only travel time intervals between stops are significant for frequency-based trips. For clarity/human readability, it is recommended that the first stop time of a trip referenced in frequencies.txt should begin at 00:00:00 (first arrival_time value of 00:00:00). block_id Can be provided for frequency-based trips. transfers.txt \u00b6 transfers.transfer_type can be one of four values defined in the GTFS . These transfer_type definitions are quoted from the GTFS Specification below, in italics , with additional practice recommendations. Field Name Recommendation transfer_type 0 or (empty): This is a recommended transfer point between routes. If there are multiple transfer opportunities that include a superior option (i.e. a transit center with additional amenities or a station with adjacent or connected boarding facilities/platforms), specify a recommended transfer point. 1: This is a timed transfer point between two routes. The departing vehicle is expected to wait for the arriving one, with sufficient time for a passenger to transfer between routes. This transfer type overrides a required interval to reliably make transfers. As an example, Google Maps assumes that passengers need 3 minutes to safely make a transfer. Other applications may assume other defaults. 2: This transfer requires a minimum amount of time between arrival and departure to ensure a connection. The time required to transfer is specified by min_transfer_time . Specify minimum transfer time if there are obstructions or other factors which increase the time to travel between stops. 3: Transfers are not possible between routes at this location. Specify this value if transfers are not possible because of physical barriers, or if they are made unsafe or complicated by difficult road crossings or gaps in the pedestrian network. If in-seat (block) transfers are allowed between trips, then the last stop of the arriving trip must be the same as the first stop of the departing trip. feed_info.txt \u00b6 feed_info.txt should be included, with all fields below. Field Name Recommendation feed_start_date & feed_end_date Should be included feed_version Should be included feed_contact_email & feed_contact_url Provide at least one Practice Recommendations Organized by Case \u00b6 This section covers particular cases with implications across files and fields. Loop Routes \u00b6 On loop routes, vehicles\u2019 trips begin and end at the same location (sometimes a transit or transfer center). Vehicles usually operate continuously and allow passengers to stay onboard as the vehicle continues its loop. Headsigns recommendations should therefore be applied in order to show riders the direction in which the vehicle is going. To indicate the changing direction of travel, provide stop_headsigns in the stop_times.txt file. The stop_headsign describes the direction for trips departing from the stop for which it's defined. Adding stop_headsigns to each stop of a trip allows you to change the headsign information along a trip. Don\u2019t define one single circular trip in the stop_times.txt file for a route that operates between two endpoints (such as when the same bus goes back and forth). Instead, split the trip into two separate trip directions. Examples of circular trip modeling: Circular trip with changing headsign for each stop trip_id arrival_time departure_time stop_id stop_sequence stop_headsign trip_1 06:10:00 06:10:00 stop_A 1 \"B\" trip_1 06:15:00 06:15:00 stop_B 2 \"C\" trip_1 06:20:00 06:20:00 stop_C 3 \"D\" trip_1 06:25:00 06:25:00 stop_D 4 \"E\" trip_1 06:30:00 06:30:00 stop_E 5 \"A\" trip_1 06:35:00 06:35:00 stop_A 6 \"\" Circular trip with two headsigns trip_id arrival_time departure_time stop_id stop_sequence stop_headsign trip_1 06:10:00 06:10:00 stop_A 1 \"outbound\" trip_1 06:15:00 06:15:00 stop_B 2 \"outbound\" trip_1 06:20:00 06:20:00 stop_C 3 \"outbound\" trip_1 06:25:00 06:25:00 stop_D 4 \"inbound\" trip_1 06:30:00 06:30:00 stop_E 5 \"inbound\" trip_1 06:35:00 06:35:00 stop_F 6 \"inbound\" trip_1 06:40:00 06:40:00 stop_A 7 \"\" Field Name Recommendation trips.trip_id Model the complete round-trip for the loop with a single trip. stop_times.stop_id Include the first/last stop twice in stop_times.txt for the trip that is a loop. Example below. Often, a loop route may include first and last trips that do not travel the entire loop. Include these trips as well. trip_id stop_id stop_sequence 9000 101 1 9000 102 2 9000 103 3 9000 101 4 trips.direction_id If loop operates in opposite directions (i.e. clockwise and counterclockwise), then designate direction_id as 0 or 1 . trips.block_id Indicate continuous loop trips with the same block_id . Lasso Routes \u00b6 Lasso routes combine aspects of a loop route and directional route. Examples: Subway Routes ( Chicago ) Bus Suburb to Downtown Routes ( St. Albert or Edmonton ) CTA Brown Line ( CTA Website and TransitFeeds ) Field Name Recommendation trips.trip_id The full extent of a \u201cvehicle round-trip\u201d (see illustration above ) consists of travel from A to B to B and back to A. An entire vehicle round-trip may be expressed by: A single trip_id value/record in trips.txt Multiple trip_id values/records in trips.txt , with continuous travel indicated by block_id . stop_times.stop_headsign The stops along the A-B section will be passed through in both directions. stop_headsign facilitates distinguishing travel direction. Therefore, providing stop_headsign is recommended for these trips.example_table: Examples: \"A via B\" \"A\" Chicago Transit Authority's Purple Line \"Southbound to Loop\" \"Northbound via Loop\" \"Northbound to Linden\" Edmonton Transit Service Bus Lines, here the 39 \"Rutherford\" \"Century Park\" trip.trip_headsign The trip headsign should be a global description of the trip, like displayed in the schedules. Could be \u201cLinden to Linden via Loop\u201d (Chicago example), or \u201cA to A via B\u201d (generic example). Branches \u00b6 Some routes may include branches. Alignment and stops are shared amongst these branches, but each also serves distinct stops and alignment sections. The relationship among branches may be indicated by route name(s), headsigns, and trip short name using the further guidelines below. Field Name Recommendation All Fields In naming branch routes, it is recommended to follow other passenger information materials. Below are descriptions and examples of two cases: If timetables and on-street signage represent two distinctly named routes (e.g. 1A and 1B), then present this as such in the GTFS, using the route_short_name and/or route_long_name fields. Example: GoDurham Transit routes 2, 2A, and 2B share a common alignment throughout the majority of the route, but they vary in several different aspects. Route 2 is core service, running most hours. Route 2 includes a deviation on Main Street nights, Sundays, and holidays. Routes 2A and 2B operate daytime hours Monday through Saturday. Route 2B serves additional stops in a deviation of the shared alignment path. If agency-provided information describes branches as the same named route, then utilize the trips.trip_headsign , stop_times.stop_headsign , and/or trips.trip_short_name fields. Example: GoTriangle route 300 travels to different locations depending on the time of day. During peak commuter hours extra legs are added onto the standard route to accommodate workers entering and leaving the city. Frequently Asked Questions (FAQ) \u00b6 Why are these GTFS Best Practices important? \u00b6 The objectives of GTFS Best Practices are: To improve end-user customer experience in public transportation apps Support broad data interoperability to make it easier for software developers to deploy and scale applications, products, and services Facilitate the use of GTFS in various application categories (beyond its original focus on trip planning) Without coordinated GTFS Best Practices, various GTFS-consuming applications may establish requirements and expectations in an uncoordinated way, which leads to diverging requirements and application-specific datasets and less interoperability. Prior to the release of the Best Practices, there was greater ambiguity and disagreement in what constitutes correctly-formed GTFS data. How were they developed? Who developed them? \u00b6 These Best Practices were developed by a working group of 17 organizations involved in GTFS, including app providers & data consumers, transit providers, and consultants with extensive involvement in GTFS. The working group was convened and facilitated by Rocky Mountain Institute . Working Group members voted on each Best Practice. Most Best Practices were approved by a unanimous vote. In a minority of cases, Best Practices were approved a large majority of organizations. Why not just change the GTFS reference? \u00b6 Good question! The process of examining the Specification, data usage and needs did indeed trigger some changes to the Specification (see closed pull requests in GitHub ). Specification reference amendments are subject to a higher bar of scrutiny and comment than the Best Practices. However, there was still need to agree on a clear set of Best Practice recommendations. The working group anticipates that some GTFS Best Practices will eventually become part of the core GTFS reference. Do GTFS validator tools check for conformance with these Best Practices? \u00b6 No validator tool currently checks for conformance with all Best Practices. Various validator tools check for conformance with some of these best practices. For a list of GTFS validator tools, see GTFS Validators . If you write a GTFS validator tool that references these Best Practices, please email specifications@mobilitydata.org . I represent a transit agency. What steps can I take so that our software service providers and vendors follow these Best Practices? \u00b6 Refer your vendor or software service provider to these Best Practices. We recommend referencing the GTFS Best Practices URL, as well as core Spec Reference in procurement for GTFS-producing software. What should I do if I notice a GTFS data feed does not conform to these Best Practices? \u00b6 Identify the contact for the feed, using the proposed feed_contact_email or feed_contact_url fields in feed_info.txt if they exist, or looking up contact information on the transit agency or feed producer website. When communicating the issue to the feed producer, link to the specific GTFS Best Practice under discussion. (See \"Linking to this Document\" ). I would like to propose a modification/addition to the Best Practices. How do I do this? \u00b6 Email specifications@mobilitydata.org or open an issue or pull request in the GitHub GTFS Best Practices repo . How do I get involved? \u00b6 Email specifications@mobilitydata.org . About This Document \u00b6 Objectives \u00b6 The objectives of maintaining GTFS Best Practices is to: Support greater interoperability of transit data Improve end-user customer experience in public transportation apps Make it easier for software developers to deploy and scale applications, products, and services Facilitate the use of GTFS in various application categories (beyond its original focus on trip planning) How to propose or amend published GTFS Best Practices \u00b6 GTFS applications and practice evolve, and so this document may need to be amended from time to time. To propose an amendment to this document, open a pull request in the GTFS Best Practices GitHub repository and advocate for the change. You can slo email any comments to specifications@mobilitydata.org . Linking to This Document \u00b6 Please link here in order to provide feed producers with guidance for correct formation of GTFS data. Each individual recommendation has an anchor link. Click the recommendation to get the URL for the in-page anchor link. If a GTFS-consuming application makes requirements or recommendations for GTFS data practices that are not described here, it is recommended to publish a document with those requirements or recommendations to supplement these common best practices. GTFS Best Practices Working Group \u00b6 The GTFS Best Practices Working Group was convened by Rocky Mountain Institute in 2016-17, consisting of public transportation providers, developers of GTFS-consuming applications, consultants, and academic organizations to define common practices and expectations for GTFS data. Members of this working group included: Cambridge Systematics Capital Metro Center for Urban Transportation Research at University of South Florida Conveyal Google IBI Group Mapzen Microsoft Moovel Oregon Department of Transportation Swiftly Transit Trillium TriMet World Bank Today, this document is maintained by MobilityData .","title":"Best Practices"},{"location":"schedule/best-practices/#gtfs-schedule-best-practices","text":"These are recommended practices for describing public transportation services in the General Transit Feed Specification (GTFS) . These practices have been synthesized from the experience of the GTFS Best Practices working group members and application-specific GTFS practice recommendations . For further background, see the Frequently Asked Questions .","title":"GTFS Schedule Best Practices"},{"location":"schedule/best-practices/#document-structure","text":"Practices are organized into four primary sections: Dataset Publishing & General Practices : These practices relate to the overall structure of the GTFS dataset and to the manner in which GTFS datasets are published. Practice Recommendations Organized by File : Recommendations are organized by file and field in the GTFS to facilitate mapping practices back to the official GTFS reference. Practice Recommendations Organized by Case : With particular cases, such as loop routes, practices may need to be applied across several files and fields. Such recommendations are consolidated in this section.","title":"Document Structure"},{"location":"schedule/best-practices/#dataset-publishing-general-practices","text":"Datasets should be published at a public, permanent URL, including the zip file name. (e.g., www.agency.org/gtfs/gtfs.zip). Ideally, the URL should be directly downloadable without requiring login to access the file, to facilitate download by consuming software applications. While it is recommended (and the most common practice) to make a GTFS dataset openly downloadable, if a data provider does need to control access to GTFS for licensing or other reasons, it is recommended to control access to the GTFS dataset using API keys, which will facilitate automatic downloads. GTFS data is published in iterations so that a single file at a stable location always contains the latest official description of service for a transit agency (or agencies). Maintain persistent identifiers (id fields) for stop_id , route_id , and agency_id across data iterations whenever possible. One GTFS dataset should contain current and upcoming service (sometimes called a \u201cmerged\u201d dataset). Google transitfeed tool's merge function can be used to create a merged dataset from two different GTFS feeds. At any time, the published GTFS dataset should be valid for at least the next 7 days, and ideally for as long as the operator is confident that the schedule will continue to be operated. If possible, the GTFS dataset should cover at least the next 30 days of service. Remove old services (expired calendars) from the feed. If a service modification will go into effect in 7 days or fewer, express this service change through a GTFS-realtime feed (service advisories or trip updates) rather than static GTFS dataset. The web-server hosting GTFS data should be configured to correctly report the file modification date (see HTTP/1.1 - Request for Comments 2616 , under Section 14.29).","title":"Dataset Publishing &amp; General Practices"},{"location":"schedule/best-practices/#practice-recommendations-organized-by-file","text":"This section shows practices organized by file and field, aligning with the GTFS reference .","title":"Practice Recommendations Organized by File"},{"location":"schedule/best-practices/#all-files","text":"Field Name Recommendation Mixed Case All customer-facing text strings (including stop names, route names, and headsigns) should use Mixed Case (not ALL CAPS), following local conventions for capitalization of place names on displays capable of displaying lower case characters. Examples: Brighton Churchill Square Villiers-sur-Marne Market Street Abbreviations Avoid use of abbreviations throughout the feed for names and other text (e.g. St. for Street) unless a location is called by its abbreviated name (e.g. \u201cJFK Airport\u201d). Abbreviations may be problematic for accessibility by screen reader software and voice user interfaces. Consuming software can be engineered to reliably convert full words to abbreviations for display, but converting from abbreviations to full words is prone to more risk of error.","title":"All Files"},{"location":"schedule/best-practices/#agencytxt","text":"Field Name Recommendation agency_id Should be included, even if there is only one agency in the feed. (See also recommendation to include agency_id in routes.txt and fare_attributes.txt ) agency_phone Should be included unless no such customer service phone exists. agency_email Should be included unless no such customer service email exists. agency_fare_url Should be included unless the agency is fully fare-free. Examples: Bus services are run by several small bus agencies. But there is one big agency that is responsible for scheduling and ticketing and from a user\u2019s perspective responsible for the bus services.The one big agency should be defined as agency within the feed. Even if the data is split internally by different small bus operators there should only be one agency defined in the feed. The feed provider runs the ticketing portal, but there are different agencies that actually operate the services and are known by users to be responsible. The agencies actually operating the services should be defined as agencies within the feed.","title":"agency.txt"},{"location":"schedule/best-practices/#stopstxt","text":"Field Name Recommendation stop_name When there is not a published stop name, follow consistent stop naming conventions throughout the feed. By default, stop_name should not contain generic or redundant words like \u201cStation\u201d or \u201cStop\u201d, but some edge cases are allowed. When it is actually part of the name (Union Station, Central Station When the stop_name is too generic (such as if it is the name of the city). \u201cStation\u201d, \u201cTerminal\u201d, or other words make the meaning clear. stop_lat & stop_lon Stop locations should be as accurate possible. Stop locations should have an error of no more than four meters when compared to the actual stop position. Stop locations should be placed very near to the pedestrian right of way where a passenger will board (i.e. correct side of the street). If a stop location is shared across separate data feeds (i.e. two agencies use exactly the same stop / boarding facility), indicate the stop is shared by using the exact same stop_lat and stop_lon for both stops. parent_station & location_type Many stations or terminals have multiple boarding facilities (depending on mode, they might be called a bus bay, platform, wharf, gate, or another term). In such cases, feed producers should describe stations, boarding facilities (also called child stops), and their relation. The station or terminal should be defined as a record in stops.txt with location_type = 1 . Each boarding facility should be defined as a stop with location_type = 0 . The parent_station field should reference the stop_id of the station the boarding facility is in. When naming the station and child stops, set names that are well-recognized by riders, and can help riders to identify the station and boarding facility (bus bay, platform, wharf, gate, etc.). Parent Station Name Child Stop Name Chicago Union Station Chicago Union Station Platform 19 San Francisco Ferry Building Terminal San Francisco Ferry Building Terminal Gate E Downtown Transit Center Downtown Transit Center Bay B","title":"stops.txt"},{"location":"schedule/best-practices/#routestxt","text":"Field Name Recommendation route_short_name Include route_short_name if there is a brief service designation. This should be the commonly-known passenger name of the service, no longer than 12 characters. route_long_name The definition from Specification reference: This name is generally more descriptive than the route_short_name and will often include the route's destination or stop. At least one of route_short_name or route_long_name must be specified, or potentially both if appropriate. If the route does not have a long name, please specify a route_short_name and use an empty string as the value for this field. Examples of types of long names are below: Primary Travel Path or Corridor Route Name Form Agency \u201cN\u201d/\u201cJudah\u201d route_short_name / route_long_name Muni , in San Francisco \u201c6\u201c/\u201cML King Jr Blvd\u201c route_short_name / route_long_name TriMet , in Portland, Or. \u201c6\u201d/\u201cNation - \u00c9toile\u201d route_short_name / route_long_name RATP , in Paris France. \u201cU2\u201d-\u201cPankow \u2013 Ruhleben\u201d route_short_name - route_long_name BVG , in Berlin, Germany Description of the Service \u201cHartwell Area Shuttle\u201c route_long_name should not contain the route_short_name . Include the full designation including a service identity when populating route_long_name . Examples: Service Identity Recommendation Examples \"MAX Light Rail\" TriMet, in Portland, Oregon The route_long_name should include the brand (MAX) and the specific route designation \"MAX Red Line\" \"MAX Blue Line\" \"Rapid Ride\" ABQ Ride, in Albuquerque, New Mexico The route_long_name should include the brand (Rapid Ride) and the specific route designation \"Rapid Ride Red Line\" \"Rapid Ride Blue Line\" route_id All trips on a given named route should reference the same route_id . Different directions of a route should not be separated into different route_id values. Different spans of operation of a route should not be separated into different route_id values. i.e. do not create different records in routes.txt for \u201cDowntown AM\u201d and \u201cDowntown PM\u201d services). If a route group includes distinctly named branches (e.g. 1A and 1B), follow recommendations in the route branches case to determine route_short_name and route_long_name . route_color & route_text_color Should be consistent with signage and printed and online customer information (and thus not included if they do not exist in other places).","title":"routes.txt"},{"location":"schedule/best-practices/#tripstxt","text":"See special case for loop routes: Loop routes are cases where trips start and end at the same stop, as opposed to linear routes, which have two distinct termini. Loop routes must be described following specific practices. See Loop route case. See special case for lasso routes: Lasso routes are a hybrid of linear and loop geometries, in which vehicles travel on a loop for only a portion of the route. Lasso routes must be described following specific practices. See Lasso route case. Field Name Recommendation trip_headsign Do not provide route names (matching route_short_name and route_long_name ) in the trip_headsign or stop_headsign fields. Should contain destination, direction, and/or other trip designation text shown on the headsign of the vehicle which may be used to distinguish amongst trips in a route. Consistency with direction information shown on the vehicle is the primary and overriding goal for determining headsigns supplied in GTFS datasets. Other information should be included only if it does not compromise this primary goal. If headsigns change during a trip, override trip_headsign with stop_times.stop_headsign . Below are recommendations for some possible cases: Route Description Recommendation 2A. Destination-only Provide the terminus destination. e.g. \"Transit Center\", \u201cPortland City Center\u201d, or \u201cJantzen Beach\u201d> 2B. Destinations with waypoints <destination> via <waypoint> \u201cHighgate via Charing Cross\u201d. If waypoint(s) are removed from the headsign show to passengers after the vehicle passes those waypoints, use stop_times.stop_headsign to set an updated headsign.> 2C. Regional placename with local stops If there will be multiple stops inside the city or borough of destination, use stop_times.stop_headsign once reaching the destination city.> 2D. Direction-only Indicate using terms such as \u201cNorthbound\u201d, \u201cInbound\u201d, \u201cClockwise,\u201d or similar directions.> 2E. Direction with destination <direction> to <terminus name> e.g. \u201cSouthbound to San Jose\u201d> 2F. Direction with destination and waypoints <direction> via <waypoint> to <destination> (\u201cNorthbound via Charing Cross to Highgate\u201d).> Do not begin a headsign with the words \u201cTo\u201d or \u201cTowards\u201d. direction_id Use values 0 and 1 consistently throughout the dataset. i.e. If 1 = Outbound on the Red route, then 1 = Outbound on the Green route If 1 = Northbound on Route X, then 1 = Northbound on Route Y If 1 = clockwise on Route X then 1 = clockwise on Route Y","title":"trips.txt"},{"location":"schedule/best-practices/#stop_timestxt","text":"Loop routes: Loop routes require special stop_times considerations. (See: Loop route case ) Field Name Recommendation pickup_type & drop_off_type Non-revenue (deadhead) trips that do not provide passenger service should be marked with pickup_type and drop_off_type value of 1 for all stop_times rows. On revenue trips, internal \u201ctiming points\u201d for monitoring operational performance and other places such as garages that a passenger cannot board should be marked with pickup_type = 1 (no pickup available) and drop_off_type = 1 (no drop off available). arrival_time & departure_time arrival_time and departure_time fields should specify time values whenever possible, including non-binding estimated or interpolated times between timepoints. stop_headsign In general, headsign values should also correspond to signs in the stations. In the cases below, \u201cSouthbound\u201d would mislead customers because it is not used in the station signs. In NYC, for the 2 going Southbound: For stop_times.txt rows: Use stop_headsign value: Until Manhattan is Reached Manhattan & Brooklyn Until Downtown is Reached Downtown & Brooklyn Until Brooklyn is Reached Brooklyn Once Brooklyn is Reached Brooklyn (New Lots Av) In Boston, for the Red Line going Southbound, for the Braintree branch: For stop_times.txt rows: Use stop_headsign value: Until Downtown is Reached Inbound to Braintree Once Downtown is Reached Braintree After Downtown Outbound to Braintree shape_dist_traveled shape_dist_traveled must be provided for routes that have looping or inlining (the vehicle crosses or travels over the same portion of alignment in one trip). See the shapes.shape_dist_traveled recommendation.","title":"stop_times.txt"},{"location":"schedule/best-practices/#calendartxt","text":"Field Name Recommendation All Fields Including a calendar.service_name field can also increase the human readability of GTFS, although this is not adopted in the spec.","title":"calendar.txt"},{"location":"schedule/best-practices/#calendar_datestxt","text":"Field Name Recommendation All Fields Including a calendar.service_name field can also increase the human readability of GTFS, although this is not adopted in the spec.","title":"calendar_dates.txt"},{"location":"schedule/best-practices/#fare_attributestxt","text":"Field Name Recommendation All Fields agency_id should be included in fare_attributes.txt if it the field is included in agency.txt . If a fare system cannot be accurately modeled, avoid further confusion and leave it blank. Include fares ( fare_attributes.txt and fare_rules.txt ) and model them as accurately as possible. In edge cases where fares cannot be accurately modeled, the fare should be represented as more expensive rather than less expensive so customers will not attempt to board with insufficient fare. If the vast majority of fares cannot be modeled correctly, do not include fare information in the feed.","title":"fare_attributes.txt"},{"location":"schedule/best-practices/#fare_rulestxt","text":"Field Name Recommendation All Fields If a fare system cannot be accurately modeled, avoid further confusion and leave it blank. Include fares ( fare_attributes.txt and fare_rules.txt ) and model them as accurately as possible. In edge cases where fares cannot be accurately modeled, the fare should be represented as more expensive rather than less expensive so customers will not attempt to board with insufficient fare. If the vast majority of fares cannot be modeled correctly, do not include fare information in the feed.","title":"fare_rules.txt"},{"location":"schedule/best-practices/#shapestxt","text":"Field Name Recommendation All Fields Ideally, for alignments that are shared (i.e. in a case where Routes 1 and 2 operate on the same segment of roadway or track) then the shared portion of alignment should match exactly. This helps to facilitate high-quality transit cartography. Alignments should follow the centerline of the right of way on which the vehicle travels. This could be either the centerline of the street if there are no designated lanes, or the centerline of the side of the roadway that travels in the direction the vehicle moves. Alignments should not \u201cjag\u201d to a curb stop, platform, or boarding location. shape_dist_traveled Must be provided in both shapes.txt and stop_times.txt if an alignment includes looping or inlining (the vehicle crosses or travels over the same portion of alignment in one trip). If a vehicle retraces or crosses the route alignment at points in the course of a trip, shape_dist_traveled is important to clarify how portions of the points in shapes.txt line up correspond with records in stop_times.txt . The shape_dist_traveled field allows the agency to specify exactly how the stops in the stop_times.txt file fit into their respective shape. A common value to use for the shape_dist_traveled field is the distance from the beginning of the shape as traveled by the vehicle (think something like an odometer reading). Route alignments (in shapes.txt ) should be within 100 meters of stop locations which a trip serves. Simplify alignments so that shapes.txt does not contain extraneous points (i.e. remove extra points on straight-line segments; see discussion of line simplification problem).","title":"shapes.txt"},{"location":"schedule/best-practices/#frequenciestxt","text":"Field Name Recommendation All Fields Actual stop times are ignored for trips referenced by frequencies.txt ; only travel time intervals between stops are significant for frequency-based trips. For clarity/human readability, it is recommended that the first stop time of a trip referenced in frequencies.txt should begin at 00:00:00 (first arrival_time value of 00:00:00). block_id Can be provided for frequency-based trips.","title":"frequencies.txt"},{"location":"schedule/best-practices/#transferstxt","text":"transfers.transfer_type can be one of four values defined in the GTFS . These transfer_type definitions are quoted from the GTFS Specification below, in italics , with additional practice recommendations. Field Name Recommendation transfer_type 0 or (empty): This is a recommended transfer point between routes. If there are multiple transfer opportunities that include a superior option (i.e. a transit center with additional amenities or a station with adjacent or connected boarding facilities/platforms), specify a recommended transfer point. 1: This is a timed transfer point between two routes. The departing vehicle is expected to wait for the arriving one, with sufficient time for a passenger to transfer between routes. This transfer type overrides a required interval to reliably make transfers. As an example, Google Maps assumes that passengers need 3 minutes to safely make a transfer. Other applications may assume other defaults. 2: This transfer requires a minimum amount of time between arrival and departure to ensure a connection. The time required to transfer is specified by min_transfer_time . Specify minimum transfer time if there are obstructions or other factors which increase the time to travel between stops. 3: Transfers are not possible between routes at this location. Specify this value if transfers are not possible because of physical barriers, or if they are made unsafe or complicated by difficult road crossings or gaps in the pedestrian network. If in-seat (block) transfers are allowed between trips, then the last stop of the arriving trip must be the same as the first stop of the departing trip.","title":"transfers.txt"},{"location":"schedule/best-practices/#feed_infotxt","text":"feed_info.txt should be included, with all fields below. Field Name Recommendation feed_start_date & feed_end_date Should be included feed_version Should be included feed_contact_email & feed_contact_url Provide at least one","title":"feed_info.txt"},{"location":"schedule/best-practices/#practice-recommendations-organized-by-case","text":"This section covers particular cases with implications across files and fields.","title":"Practice Recommendations Organized by Case"},{"location":"schedule/best-practices/#loop-routes","text":"On loop routes, vehicles\u2019 trips begin and end at the same location (sometimes a transit or transfer center). Vehicles usually operate continuously and allow passengers to stay onboard as the vehicle continues its loop. Headsigns recommendations should therefore be applied in order to show riders the direction in which the vehicle is going. To indicate the changing direction of travel, provide stop_headsigns in the stop_times.txt file. The stop_headsign describes the direction for trips departing from the stop for which it's defined. Adding stop_headsigns to each stop of a trip allows you to change the headsign information along a trip. Don\u2019t define one single circular trip in the stop_times.txt file for a route that operates between two endpoints (such as when the same bus goes back and forth). Instead, split the trip into two separate trip directions. Examples of circular trip modeling: Circular trip with changing headsign for each stop trip_id arrival_time departure_time stop_id stop_sequence stop_headsign trip_1 06:10:00 06:10:00 stop_A 1 \"B\" trip_1 06:15:00 06:15:00 stop_B 2 \"C\" trip_1 06:20:00 06:20:00 stop_C 3 \"D\" trip_1 06:25:00 06:25:00 stop_D 4 \"E\" trip_1 06:30:00 06:30:00 stop_E 5 \"A\" trip_1 06:35:00 06:35:00 stop_A 6 \"\" Circular trip with two headsigns trip_id arrival_time departure_time stop_id stop_sequence stop_headsign trip_1 06:10:00 06:10:00 stop_A 1 \"outbound\" trip_1 06:15:00 06:15:00 stop_B 2 \"outbound\" trip_1 06:20:00 06:20:00 stop_C 3 \"outbound\" trip_1 06:25:00 06:25:00 stop_D 4 \"inbound\" trip_1 06:30:00 06:30:00 stop_E 5 \"inbound\" trip_1 06:35:00 06:35:00 stop_F 6 \"inbound\" trip_1 06:40:00 06:40:00 stop_A 7 \"\" Field Name Recommendation trips.trip_id Model the complete round-trip for the loop with a single trip. stop_times.stop_id Include the first/last stop twice in stop_times.txt for the trip that is a loop. Example below. Often, a loop route may include first and last trips that do not travel the entire loop. Include these trips as well. trip_id stop_id stop_sequence 9000 101 1 9000 102 2 9000 103 3 9000 101 4 trips.direction_id If loop operates in opposite directions (i.e. clockwise and counterclockwise), then designate direction_id as 0 or 1 . trips.block_id Indicate continuous loop trips with the same block_id .","title":"Loop Routes"},{"location":"schedule/best-practices/#lasso-routes","text":"Lasso routes combine aspects of a loop route and directional route. Examples: Subway Routes ( Chicago ) Bus Suburb to Downtown Routes ( St. Albert or Edmonton ) CTA Brown Line ( CTA Website and TransitFeeds ) Field Name Recommendation trips.trip_id The full extent of a \u201cvehicle round-trip\u201d (see illustration above ) consists of travel from A to B to B and back to A. An entire vehicle round-trip may be expressed by: A single trip_id value/record in trips.txt Multiple trip_id values/records in trips.txt , with continuous travel indicated by block_id . stop_times.stop_headsign The stops along the A-B section will be passed through in both directions. stop_headsign facilitates distinguishing travel direction. Therefore, providing stop_headsign is recommended for these trips.example_table: Examples: \"A via B\" \"A\" Chicago Transit Authority's Purple Line \"Southbound to Loop\" \"Northbound via Loop\" \"Northbound to Linden\" Edmonton Transit Service Bus Lines, here the 39 \"Rutherford\" \"Century Park\" trip.trip_headsign The trip headsign should be a global description of the trip, like displayed in the schedules. Could be \u201cLinden to Linden via Loop\u201d (Chicago example), or \u201cA to A via B\u201d (generic example).","title":"Lasso Routes"},{"location":"schedule/best-practices/#branches","text":"Some routes may include branches. Alignment and stops are shared amongst these branches, but each also serves distinct stops and alignment sections. The relationship among branches may be indicated by route name(s), headsigns, and trip short name using the further guidelines below. Field Name Recommendation All Fields In naming branch routes, it is recommended to follow other passenger information materials. Below are descriptions and examples of two cases: If timetables and on-street signage represent two distinctly named routes (e.g. 1A and 1B), then present this as such in the GTFS, using the route_short_name and/or route_long_name fields. Example: GoDurham Transit routes 2, 2A, and 2B share a common alignment throughout the majority of the route, but they vary in several different aspects. Route 2 is core service, running most hours. Route 2 includes a deviation on Main Street nights, Sundays, and holidays. Routes 2A and 2B operate daytime hours Monday through Saturday. Route 2B serves additional stops in a deviation of the shared alignment path. If agency-provided information describes branches as the same named route, then utilize the trips.trip_headsign , stop_times.stop_headsign , and/or trips.trip_short_name fields. Example: GoTriangle route 300 travels to different locations depending on the time of day. During peak commuter hours extra legs are added onto the standard route to accommodate workers entering and leaving the city.","title":"Branches"},{"location":"schedule/best-practices/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"schedule/best-practices/#why-are-these-gtfs-best-practices-important","text":"The objectives of GTFS Best Practices are: To improve end-user customer experience in public transportation apps Support broad data interoperability to make it easier for software developers to deploy and scale applications, products, and services Facilitate the use of GTFS in various application categories (beyond its original focus on trip planning) Without coordinated GTFS Best Practices, various GTFS-consuming applications may establish requirements and expectations in an uncoordinated way, which leads to diverging requirements and application-specific datasets and less interoperability. Prior to the release of the Best Practices, there was greater ambiguity and disagreement in what constitutes correctly-formed GTFS data.","title":"Why are these GTFS Best Practices important?"},{"location":"schedule/best-practices/#how-were-they-developed-who-developed-them","text":"These Best Practices were developed by a working group of 17 organizations involved in GTFS, including app providers & data consumers, transit providers, and consultants with extensive involvement in GTFS. The working group was convened and facilitated by Rocky Mountain Institute . Working Group members voted on each Best Practice. Most Best Practices were approved by a unanimous vote. In a minority of cases, Best Practices were approved a large majority of organizations.","title":"How were they developed? Who developed them?"},{"location":"schedule/best-practices/#why-not-just-change-the-gtfs-reference","text":"Good question! The process of examining the Specification, data usage and needs did indeed trigger some changes to the Specification (see closed pull requests in GitHub ). Specification reference amendments are subject to a higher bar of scrutiny and comment than the Best Practices. However, there was still need to agree on a clear set of Best Practice recommendations. The working group anticipates that some GTFS Best Practices will eventually become part of the core GTFS reference.","title":"Why not just change the GTFS reference?"},{"location":"schedule/best-practices/#do-gtfs-validator-tools-check-for-conformance-with-these-best-practices","text":"No validator tool currently checks for conformance with all Best Practices. Various validator tools check for conformance with some of these best practices. For a list of GTFS validator tools, see GTFS Validators . If you write a GTFS validator tool that references these Best Practices, please email specifications@mobilitydata.org .","title":"Do GTFS validator tools check for conformance with these Best Practices?"},{"location":"schedule/best-practices/#i-represent-a-transit-agency-what-steps-can-i-take-so-that-our-software-service-providers-and-vendors-follow-these-best-practices","text":"Refer your vendor or software service provider to these Best Practices. We recommend referencing the GTFS Best Practices URL, as well as core Spec Reference in procurement for GTFS-producing software.","title":"I represent a transit agency. What steps can I take so that our software service providers and vendors follow these Best Practices?"},{"location":"schedule/best-practices/#what-should-i-do-if-i-notice-a-gtfs-data-feed-does-not-conform-to-these-best-practices","text":"Identify the contact for the feed, using the proposed feed_contact_email or feed_contact_url fields in feed_info.txt if they exist, or looking up contact information on the transit agency or feed producer website. When communicating the issue to the feed producer, link to the specific GTFS Best Practice under discussion. (See \"Linking to this Document\" ).","title":"What should I do if I notice a GTFS data feed does not conform to these Best Practices?"},{"location":"schedule/best-practices/#i-would-like-to-propose-a-modificationaddition-to-the-best-practices-how-do-i-do-this","text":"Email specifications@mobilitydata.org or open an issue or pull request in the GitHub GTFS Best Practices repo .","title":"I would like to propose a modification/addition to the Best Practices. How do I do this?"},{"location":"schedule/best-practices/#how-do-i-get-involved","text":"Email specifications@mobilitydata.org .","title":"How do I get involved?"},{"location":"schedule/best-practices/#about-this-document","text":"","title":"About This Document"},{"location":"schedule/best-practices/#objectives","text":"The objectives of maintaining GTFS Best Practices is to: Support greater interoperability of transit data Improve end-user customer experience in public transportation apps Make it easier for software developers to deploy and scale applications, products, and services Facilitate the use of GTFS in various application categories (beyond its original focus on trip planning)","title":"Objectives"},{"location":"schedule/best-practices/#how-to-propose-or-amend-published-gtfs-best-practices","text":"GTFS applications and practice evolve, and so this document may need to be amended from time to time. To propose an amendment to this document, open a pull request in the GTFS Best Practices GitHub repository and advocate for the change. You can slo email any comments to specifications@mobilitydata.org .","title":"How to propose or amend published GTFS Best Practices"},{"location":"schedule/best-practices/#linking-to-this-document","text":"Please link here in order to provide feed producers with guidance for correct formation of GTFS data. Each individual recommendation has an anchor link. Click the recommendation to get the URL for the in-page anchor link. If a GTFS-consuming application makes requirements or recommendations for GTFS data practices that are not described here, it is recommended to publish a document with those requirements or recommendations to supplement these common best practices.","title":"Linking to This Document"},{"location":"schedule/best-practices/#gtfs-best-practices-working-group","text":"The GTFS Best Practices Working Group was convened by Rocky Mountain Institute in 2016-17, consisting of public transportation providers, developers of GTFS-consuming applications, consultants, and academic organizations to define common practices and expectations for GTFS data. Members of this working group included: Cambridge Systematics Capital Metro Center for Urban Transportation Research at University of South Florida Conveyal Google IBI Group Mapzen Microsoft Moovel Oregon Department of Transportation Swiftly Transit Trillium TriMet World Bank Today, this document is maintained by MobilityData .","title":"GTFS Best Practices Working Group"},{"location":"schedule/data-examples/","text":"Data Examples \u00b6 Introduction \u00b6 These GTFS Data Examples are meant to ease comprehension of the GTFS specification and its different extensions. They provide data samples based on real-life transit systems throughout the world. These examples have been generated by MobilityData in order to facilitate both production and consumption of GTFS data by anyone. GTFS-ContinuousStops \u00b6 Example A - Pickup and drop-off everywhere! \u00b6 [Source: pdf schedules available at https://crtransit.org/bus-schedules/ ] The transit agency The Current (Rockingham, US-VT) applies a continuous-stop policy on the routes 2, 53, and 55. A rider may request to be picked up and dropped off between scheduled stops all along the route, as soon as there is a safe place for the bus to stop. Using GTFS-ContinuousStops , the data would be: File routes.txt route_id,route_short_name,route_long_name,route_type,continuous_pickup,continuous_drop_off 2,2,Bellows Falls In-Town,3,0,0 53,53,Bellows Falls / Battleboro Commuter,3,0,0 55,55,Bellows Falls / Springfield Shuttle,3,0,0 If the transit agency wants to emphasize that a coordination between the bus driver and the rider must occur, such as hand waving for being picked up or asking the bus driver for being dropped off, the data would be: File routes.txt route_id,route_short_name,route_long_name,route_type,continuous_pickup,continuous_drop_off 2,2,Bellows Falls In-Town,3,3,3 53,53,Bellows Falls / Battleboro Commuter,3,3,3 55,55,Bellows Falls / Springfield Shuttle,3,3,3 Example B - Continuous pickup and drop-off on a route section \u00b6 [Source: pdf schedules available at https://vvta.org/routes/route-22/ ] The transit agency Victor Valley Transit (Victorville, US-CA) applies a continuous-stop policy only on a part of route 22. A rider may board and get off the bus in any safe location within the County Fare zone. This behavior is not allowed within the Local Fare zone. On northbound trips, the bus 22 starts in the Local Fare zone at Victorville Transfer Center (A) and ends in the County Fare zone at Silver Lakes Market (F). Example B1: Continuous pickup and drop-off starting from a scheduled stop \u00b6 National Trails Highway - Air Expressway is the first scheduled stop in the County Fare zone, from which the continuous pickup and drop-off is available. Using GTFS-ContinuousStops , the data would be: File stops.txt stop_id,stop_name,stop_lat,stop_lon A,Victoriaville Transfer Station,34.514356,-117.318323 B,Dante St & Venus Ave,34.564499,-117.287097 C,Victorville Transportation Center,34.538433,-117.294703 D,National Trails Highway - Air Expressway,34.567536,-117.319716 E,Oro Grande Post Office,34.599292,-117.334452 F,Silver Lakes Market,34.744662,-117.335407 File stop_times.txt trip_id,stop_id,stop_sequence,departure_time,arrival_time,continuous_pickup,continuous_drop_off 22NB9AM,A,1,09:00:00,09:00:00,1,1 22NB9AM,B,1,09:14:00,09:14:00,1,1 22NB9AM,C,1,09:21:00,09:21:00,1,1 22NB9AM,D,1,09:25:00,09:25:00,0,0 22NB9AM,E,1,09:31:00,09:31:00,0,0 22NB9AM,F,1,09:46:00,09:46:00,0,0 Example B2: Continuous pickup and drop-off starting between 2 scheduled stops \u00b6 Victor Valley Transit defines the boundary between the Local Fare zone and the County Fare zone as the road Air Expressway. The scheduled stop National Trails Highway - Air Expressway is located slightly north of this boundary. To be accurate, the transit agency can add a stop at the actual intersection of the bus route with the boundary, from which the continuous pickup and drop-off is available. This stop may remain unscheduled. Using GTFS-ContinuousStops and timepoints for adding an unscheduled stop, the data would be: File stops.txt stop_id,stop_name,stop_lat,stop_lon A,Victoriaville Transfer Station,34.514356,-117.318323 B,Dante St & Venus Ave,34.564499,-117.287097 C,Victorville Transportation Center,34.538433,-117.294703 X,Local/County Fare Boundary,34.566224,-117.318357 D,National Trails Highway - Air Expressway,34.567536,-117.319716 E,Oro Grande Post Office,34.599292,-117.334452 F,Silver Lakes Market,34.744662,-117.335407 File stop_times.txt trip_id,stop_id,stop_sequence,departure_time,arrival_time,continuous_pickup,continuouse_drop_off,timepoint 22NB9AM,A,1,09:00:00,09:00:00,1,1,1 22NB9AM,B,1,09:14:00,09:14:00,1,1,1 22NB9AM,C,1,09:21:00,09:21:00,1,1,1 22NB9AM,X,1,,,0,0,0 22NB9AM,D,1,09:25:00,09:25:00,0,0,1 22NB9AM,E,1,09:31:00,09:31:00,0,0,1 22NB9AM,F,1,09:46:00,09:46:00,0,0,1","title":"Data Examples"},{"location":"schedule/data-examples/#data-examples","text":"","title":"Data Examples"},{"location":"schedule/data-examples/#introduction","text":"These GTFS Data Examples are meant to ease comprehension of the GTFS specification and its different extensions. They provide data samples based on real-life transit systems throughout the world. These examples have been generated by MobilityData in order to facilitate both production and consumption of GTFS data by anyone.","title":"Introduction"},{"location":"schedule/data-examples/#gtfs-continuousstops","text":"","title":"GTFS-ContinuousStops"},{"location":"schedule/data-examples/#example-a-pickup-and-drop-off-everywhere","text":"[Source: pdf schedules available at https://crtransit.org/bus-schedules/ ] The transit agency The Current (Rockingham, US-VT) applies a continuous-stop policy on the routes 2, 53, and 55. A rider may request to be picked up and dropped off between scheduled stops all along the route, as soon as there is a safe place for the bus to stop. Using GTFS-ContinuousStops , the data would be: File routes.txt route_id,route_short_name,route_long_name,route_type,continuous_pickup,continuous_drop_off 2,2,Bellows Falls In-Town,3,0,0 53,53,Bellows Falls / Battleboro Commuter,3,0,0 55,55,Bellows Falls / Springfield Shuttle,3,0,0 If the transit agency wants to emphasize that a coordination between the bus driver and the rider must occur, such as hand waving for being picked up or asking the bus driver for being dropped off, the data would be: File routes.txt route_id,route_short_name,route_long_name,route_type,continuous_pickup,continuous_drop_off 2,2,Bellows Falls In-Town,3,3,3 53,53,Bellows Falls / Battleboro Commuter,3,3,3 55,55,Bellows Falls / Springfield Shuttle,3,3,3","title":"Example A - Pickup and drop-off everywhere!"},{"location":"schedule/data-examples/#example-b-continuous-pickup-and-drop-off-on-a-route-section","text":"[Source: pdf schedules available at https://vvta.org/routes/route-22/ ] The transit agency Victor Valley Transit (Victorville, US-CA) applies a continuous-stop policy only on a part of route 22. A rider may board and get off the bus in any safe location within the County Fare zone. This behavior is not allowed within the Local Fare zone. On northbound trips, the bus 22 starts in the Local Fare zone at Victorville Transfer Center (A) and ends in the County Fare zone at Silver Lakes Market (F).","title":"Example B - Continuous pickup and drop-off on a route section"},{"location":"schedule/data-examples/#example-b1-continuous-pickup-and-drop-off-starting-from-a-scheduled-stop","text":"National Trails Highway - Air Expressway is the first scheduled stop in the County Fare zone, from which the continuous pickup and drop-off is available. Using GTFS-ContinuousStops , the data would be: File stops.txt stop_id,stop_name,stop_lat,stop_lon A,Victoriaville Transfer Station,34.514356,-117.318323 B,Dante St & Venus Ave,34.564499,-117.287097 C,Victorville Transportation Center,34.538433,-117.294703 D,National Trails Highway - Air Expressway,34.567536,-117.319716 E,Oro Grande Post Office,34.599292,-117.334452 F,Silver Lakes Market,34.744662,-117.335407 File stop_times.txt trip_id,stop_id,stop_sequence,departure_time,arrival_time,continuous_pickup,continuous_drop_off 22NB9AM,A,1,09:00:00,09:00:00,1,1 22NB9AM,B,1,09:14:00,09:14:00,1,1 22NB9AM,C,1,09:21:00,09:21:00,1,1 22NB9AM,D,1,09:25:00,09:25:00,0,0 22NB9AM,E,1,09:31:00,09:31:00,0,0 22NB9AM,F,1,09:46:00,09:46:00,0,0","title":"Example B1:  Continuous pickup and drop-off starting from a scheduled stop"},{"location":"schedule/data-examples/#example-b2-continuous-pickup-and-drop-off-starting-between-2-scheduled-stops","text":"Victor Valley Transit defines the boundary between the Local Fare zone and the County Fare zone as the road Air Expressway. The scheduled stop National Trails Highway - Air Expressway is located slightly north of this boundary. To be accurate, the transit agency can add a stop at the actual intersection of the bus route with the boundary, from which the continuous pickup and drop-off is available. This stop may remain unscheduled. Using GTFS-ContinuousStops and timepoints for adding an unscheduled stop, the data would be: File stops.txt stop_id,stop_name,stop_lat,stop_lon A,Victoriaville Transfer Station,34.514356,-117.318323 B,Dante St & Venus Ave,34.564499,-117.287097 C,Victorville Transportation Center,34.538433,-117.294703 X,Local/County Fare Boundary,34.566224,-117.318357 D,National Trails Highway - Air Expressway,34.567536,-117.319716 E,Oro Grande Post Office,34.599292,-117.334452 F,Silver Lakes Market,34.744662,-117.335407 File stop_times.txt trip_id,stop_id,stop_sequence,departure_time,arrival_time,continuous_pickup,continuouse_drop_off,timepoint 22NB9AM,A,1,09:00:00,09:00:00,1,1,1 22NB9AM,B,1,09:14:00,09:14:00,1,1,1 22NB9AM,C,1,09:21:00,09:21:00,1,1,1 22NB9AM,X,1,,,0,0,0 22NB9AM,D,1,09:25:00,09:25:00,0,0,1 22NB9AM,E,1,09:31:00,09:31:00,0,0,1 22NB9AM,F,1,09:46:00,09:46:00,0,0,1","title":"Example B2:  Continuous pickup and drop-off starting between 2 scheduled stops"},{"location":"schedule/example-feed/","text":"Example GTFS Feed \u00b6 This example GTFS feed shows comma-delimited data samples for each file in a transit feed. The sample data files shown here aren't all related to each other. You can also download a complete GTFS feed in final form to work with as well. agency.txt \u00b6 agency_id,agency_name,agency_url,agency_timezone,agency_phone,agency_lang FunBus,The Fun Bus,https://www.thefunbus.org,America/Los_Angeles,(310) 555-0222,en agency_id,agency_name,agency_url,agency_timezone,agency_lang agency001,Transit Agency,https://www.transitcommuterbus.com/,PST,en [...] stops.txt \u00b6 stop_id,level_id,stop_name,stop_lat,stop_lon,location_type,parent_station F12,,5 Av/53 St,40.760167,-73.975224,1, E1,L0,5 Av/53 St SW,40.760474,-73.976099,2,F12 E2,L0,5 Av/53 St NE,40.76035,-73.97546,2,F12 E3,L0,5 Av/53 St SE,40.760212,-73.975512,2,F12 E4,L0,Madison/53 St NE,40.759612,-73.973731,2,F12 E5,L0,Madison/53 St SE,40.759491,-73.973820,2,F12 N1,L1,,,40.760457,-73.975912,3,F12 N2,L1,,40.760531,-73.976111,3,F12 N3,L1,,40.759746,-73.974203,3,F12 N4,L1,,40.759679,-73.974064,3,F12 F12S,,5 Av/53 St,40.760167,-73.975224,0,F12 B1,L2,,40.759746,-73.974203,4,F12S B3,L2,,40.759828,-73.974442,4,F12S F12N,,5 Av/53 St,40.760167,-73.975224,0,F12 B2,L3,,40.760457,-73.975912,4,F12N B4,L3,,40.760375,-73.975729,4,F12N location_type= 0: platform; 1: station; 2: entrance/exit; 3: generic node; 4: boarding area. routes.txt \u00b6 route_id,route_short_name,route_long_name,route_desc,route_type A,17,Mission,\"The \"\"A\"\" route travels from lower Mission to Downtown.\",3 trips.txt \u00b6 route_id,service_id,trip_id,trip_headsign,block_id A,WE,AWE1,Downtown,1 A,WE,AWE2,Downtown,2 stop_times.txt \u00b6 trip_id,arrival_time,departure_time,stop_id,stop_sequence,pickup_type,drop_off_type AWE1,0:06:10,0:06:10,S1,1,0,0 AWE1,,,S2,2,1,3 AWE1,0:06:20,0:06:30,S3,3,0,0 AWE1,,,S5,4,0,0 AWE1,0:06:45,0:06:45,S6,5,0,0 AWD1,0:06:10,0:06:10,S1,1,0,0 AWD1,,,S2,2,0,0 AWD1,0:06:20,0:06:20,S3,3,0,0 AWD1,,,S4,4,0,0 AWD1,,,S5,5,0,0 AWD1,0:06:45,0:06:45,S6,6,0,0 calendar.txt \u00b6 service_id,monday,tuesday,wednesday,thursday,friday,saturday,sunday,start_date,end_date WE,0,0,0,0,0,1,1,20060701,20060731 WD,1,1,1,1,1,0,0,20060701,20060731 calendar_dates.txt \u00b6 service_id,date,exception_type WD,20060703,2 WE,20060703,1 WD,20060704,2 WE,20060704,1 fare_attributes.txt \u00b6 fare_id,price,currency_type,payment_method,transfers,transfer_duration 1,0.00,USD,0,0,0 2,0.50,USD,0,0,0 3,1.50,USD,0,0,0 4,2.00,USD,0,0,0 5,2.50,USD,0,0,0 fare_rules.txt \u00b6 fare_id,route_id,origin_id,destination_id,contains_id a,TSW,1,1, a,TSE,1,1, a,GRT,1,1, a,GRJ,1,1, a,SVJ,1,1, a,JSV,1,1, a,GRT,2,4, a,GRJ,4,2, b,GRT,3,3, c,GRT,,,6 shapes.txt \u00b6 shape_id,shape_pt_lat,shape_pt_lon,shape_pt_sequence,shape_dist_traveled A_shp,37.61956,-122.48161,1,0 A_shp,37.64430,-122.41070,2,6.8310 A_shp,37.65863,-122.30839,3,15.8765 pathways.txt \u00b6 pathway_id,from_stop_id,to_stop_id,pathway_mode,is_bidirectional E1N1,E1,N1,2,1 E2N1,E2,N1,2,1 E3N1,E3,N1,2,1 N1-N2,N1,N2,6,1 N2-N1,N2,N1,7,1 N2N3,N2,N3,2,1 N2-B1,N2,B1,4,0 B1-N2,B1,N2,4,0 B1B2,B1,B2,2,1 B1B3,B1,B3,1,1 B2B4,B2,B4,1,1 E4N3,E4,N3,2,1 E5N3,E5,N3,2,1 N3-N4,N3,N4,6,1 N4-N3,N4,N3,7,1 N4B3,N4,B3,2,1 N4-B3,N4,B3,4,0 B3-N4,B3,N4,4,0 B3B4,B3,B4,2,1 frequencies.txt \u00b6 trip_id,start_time,end_time,headway_secs AWE1,05:30:00,06:30:00,300 AWE1,06:30:00,20:30:00,180 AWE1,20:30:00,28:00:00,420 transfers.txt \u00b6 from_stop_id,to_stop_id,transfer_type,min_transfer_time S6,S7,2,300 S7,S6,3, S23,S7,1, levels.txt \u00b6 level_id,level_index,level_name,elevation L0,0,Street,0 L1,-1,Mezzanine,-6 L2,-2,Southbound,-18 L3,-3,Northbound,-24 translations.txt \u00b6 table_name,field_name,language,translation,record_id stops,stop_name,en,Tokyo Station,stopid000001 stops,stop_name,fr,Gare de Tokyo,stopid000001 stops,stop_name,zh,\u6771\u4eac\u7ad9,stopid000001 attributions.txt \u00b6 attribution_id,is_producer,is_operator,organization_name,agency_id attribution001,1,0,Transit Feed Solutions USA,agency001 attribution002,0,1,Transit Bus Operations USA ,agency001 [...]","title":"Example GTFS Feed"},{"location":"schedule/example-feed/#example-gtfs-feed","text":"This example GTFS feed shows comma-delimited data samples for each file in a transit feed. The sample data files shown here aren't all related to each other. You can also download a complete GTFS feed in final form to work with as well.","title":"Example GTFS Feed"},{"location":"schedule/example-feed/#agencytxt","text":"agency_id,agency_name,agency_url,agency_timezone,agency_phone,agency_lang FunBus,The Fun Bus,https://www.thefunbus.org,America/Los_Angeles,(310) 555-0222,en agency_id,agency_name,agency_url,agency_timezone,agency_lang agency001,Transit Agency,https://www.transitcommuterbus.com/,PST,en [...]","title":"agency.txt"},{"location":"schedule/example-feed/#stopstxt","text":"stop_id,level_id,stop_name,stop_lat,stop_lon,location_type,parent_station F12,,5 Av/53 St,40.760167,-73.975224,1, E1,L0,5 Av/53 St SW,40.760474,-73.976099,2,F12 E2,L0,5 Av/53 St NE,40.76035,-73.97546,2,F12 E3,L0,5 Av/53 St SE,40.760212,-73.975512,2,F12 E4,L0,Madison/53 St NE,40.759612,-73.973731,2,F12 E5,L0,Madison/53 St SE,40.759491,-73.973820,2,F12 N1,L1,,,40.760457,-73.975912,3,F12 N2,L1,,40.760531,-73.976111,3,F12 N3,L1,,40.759746,-73.974203,3,F12 N4,L1,,40.759679,-73.974064,3,F12 F12S,,5 Av/53 St,40.760167,-73.975224,0,F12 B1,L2,,40.759746,-73.974203,4,F12S B3,L2,,40.759828,-73.974442,4,F12S F12N,,5 Av/53 St,40.760167,-73.975224,0,F12 B2,L3,,40.760457,-73.975912,4,F12N B4,L3,,40.760375,-73.975729,4,F12N location_type= 0: platform; 1: station; 2: entrance/exit; 3: generic node; 4: boarding area.","title":"stops.txt"},{"location":"schedule/example-feed/#routestxt","text":"route_id,route_short_name,route_long_name,route_desc,route_type A,17,Mission,\"The \"\"A\"\" route travels from lower Mission to Downtown.\",3","title":"routes.txt"},{"location":"schedule/example-feed/#tripstxt","text":"route_id,service_id,trip_id,trip_headsign,block_id A,WE,AWE1,Downtown,1 A,WE,AWE2,Downtown,2","title":"trips.txt"},{"location":"schedule/example-feed/#stop_timestxt","text":"trip_id,arrival_time,departure_time,stop_id,stop_sequence,pickup_type,drop_off_type AWE1,0:06:10,0:06:10,S1,1,0,0 AWE1,,,S2,2,1,3 AWE1,0:06:20,0:06:30,S3,3,0,0 AWE1,,,S5,4,0,0 AWE1,0:06:45,0:06:45,S6,5,0,0 AWD1,0:06:10,0:06:10,S1,1,0,0 AWD1,,,S2,2,0,0 AWD1,0:06:20,0:06:20,S3,3,0,0 AWD1,,,S4,4,0,0 AWD1,,,S5,5,0,0 AWD1,0:06:45,0:06:45,S6,6,0,0","title":"stop_times.txt"},{"location":"schedule/example-feed/#calendartxt","text":"service_id,monday,tuesday,wednesday,thursday,friday,saturday,sunday,start_date,end_date WE,0,0,0,0,0,1,1,20060701,20060731 WD,1,1,1,1,1,0,0,20060701,20060731","title":"calendar.txt"},{"location":"schedule/example-feed/#calendar_datestxt","text":"service_id,date,exception_type WD,20060703,2 WE,20060703,1 WD,20060704,2 WE,20060704,1","title":"calendar_dates.txt"},{"location":"schedule/example-feed/#fare_attributestxt","text":"fare_id,price,currency_type,payment_method,transfers,transfer_duration 1,0.00,USD,0,0,0 2,0.50,USD,0,0,0 3,1.50,USD,0,0,0 4,2.00,USD,0,0,0 5,2.50,USD,0,0,0","title":"fare_attributes.txt"},{"location":"schedule/example-feed/#fare_rulestxt","text":"fare_id,route_id,origin_id,destination_id,contains_id a,TSW,1,1, a,TSE,1,1, a,GRT,1,1, a,GRJ,1,1, a,SVJ,1,1, a,JSV,1,1, a,GRT,2,4, a,GRJ,4,2, b,GRT,3,3, c,GRT,,,6","title":"fare_rules.txt"},{"location":"schedule/example-feed/#shapestxt","text":"shape_id,shape_pt_lat,shape_pt_lon,shape_pt_sequence,shape_dist_traveled A_shp,37.61956,-122.48161,1,0 A_shp,37.64430,-122.41070,2,6.8310 A_shp,37.65863,-122.30839,3,15.8765","title":"shapes.txt"},{"location":"schedule/example-feed/#pathwaystxt","text":"pathway_id,from_stop_id,to_stop_id,pathway_mode,is_bidirectional E1N1,E1,N1,2,1 E2N1,E2,N1,2,1 E3N1,E3,N1,2,1 N1-N2,N1,N2,6,1 N2-N1,N2,N1,7,1 N2N3,N2,N3,2,1 N2-B1,N2,B1,4,0 B1-N2,B1,N2,4,0 B1B2,B1,B2,2,1 B1B3,B1,B3,1,1 B2B4,B2,B4,1,1 E4N3,E4,N3,2,1 E5N3,E5,N3,2,1 N3-N4,N3,N4,6,1 N4-N3,N4,N3,7,1 N4B3,N4,B3,2,1 N4-B3,N4,B3,4,0 B3-N4,B3,N4,4,0 B3B4,B3,B4,2,1","title":"pathways.txt"},{"location":"schedule/example-feed/#frequenciestxt","text":"trip_id,start_time,end_time,headway_secs AWE1,05:30:00,06:30:00,300 AWE1,06:30:00,20:30:00,180 AWE1,20:30:00,28:00:00,420","title":"frequencies.txt"},{"location":"schedule/example-feed/#transferstxt","text":"from_stop_id,to_stop_id,transfer_type,min_transfer_time S6,S7,2,300 S7,S6,3, S23,S7,1,","title":"transfers.txt"},{"location":"schedule/example-feed/#levelstxt","text":"level_id,level_index,level_name,elevation L0,0,Street,0 L1,-1,Mezzanine,-6 L2,-2,Southbound,-18 L3,-3,Northbound,-24","title":"levels.txt"},{"location":"schedule/example-feed/#translationstxt","text":"table_name,field_name,language,translation,record_id stops,stop_name,en,Tokyo Station,stopid000001 stops,stop_name,fr,Gare de Tokyo,stopid000001 stops,stop_name,zh,\u6771\u4eac\u7ad9,stopid000001","title":"translations.txt"},{"location":"schedule/example-feed/#attributionstxt","text":"attribution_id,is_producer,is_operator,organization_name,agency_id attribution001,1,0,Transit Feed Solutions USA,agency001 attribution002,0,1,Transit Bus Operations USA ,agency001 [...]","title":"attributions.txt"},{"location":"schedule/guiding-principles/","text":"Guiding Principles \u00b6 In order to preserve the original vision of GTFS, a number of guiding principles have been established to take into consideration when extending the spec: Feeds should be easy to create and edit We chose CSV as the basis for the specification because it's easy to view and edit using spreadsheet programs and text editors, which is helpful for smaller agencies. It's also straightforward to generate from most programming languages and databases, which is good for publishers of larger feeds. Feeds should be easy to parse Feed readers should be able to extract the information they're looking for with as little work as possible. Changes and additions to the feed should be as broadly useful as possible, to minimize the number of code paths that readers of the feed need to implement. (However, making creation easier should be given precedence, since there will ultimately be more feed publishers than feed readers.) Changes to the spec should be backwards-compatible When adding features to the specification, we want to avoid making changes that will make existing feeds invalid. We don't want to create more work for existing feed publishers until they want to add capabilities to their feeds. Also, whenever possible, we want existing parsers to be able to continue to read the older parts of newer feeds. Speculative features are discouraged Every new feature adds complexity to the creation and reading of feeds. Therefore, we want to take care to only add features that we know to be useful. Ideally, any proposal will have been tested by generating data for a real transit system that uses the new feature and writing software to read and display it. Note that the GTFS readily allows for extensions to the format through the addition of extra columns and files that are ignored by the official parsers & validators, so proposals can be easily prototyped and tested on existing feeds.","title":"Guiding Principles"},{"location":"schedule/guiding-principles/#guiding-principles","text":"In order to preserve the original vision of GTFS, a number of guiding principles have been established to take into consideration when extending the spec: Feeds should be easy to create and edit We chose CSV as the basis for the specification because it's easy to view and edit using spreadsheet programs and text editors, which is helpful for smaller agencies. It's also straightforward to generate from most programming languages and databases, which is good for publishers of larger feeds. Feeds should be easy to parse Feed readers should be able to extract the information they're looking for with as little work as possible. Changes and additions to the feed should be as broadly useful as possible, to minimize the number of code paths that readers of the feed need to implement. (However, making creation easier should be given precedence, since there will ultimately be more feed publishers than feed readers.) Changes to the spec should be backwards-compatible When adding features to the specification, we want to avoid making changes that will make existing feeds invalid. We don't want to create more work for existing feed publishers until they want to add capabilities to their feeds. Also, whenever possible, we want existing parsers to be able to continue to read the older parts of newer feeds. Speculative features are discouraged Every new feature adds complexity to the creation and reading of feeds. Therefore, we want to take care to only add features that we know to be useful. Ideally, any proposal will have been tested by generating data for a real transit system that uses the new feature and writing software to read and display it. Note that the GTFS readily allows for extensions to the format through the addition of extra columns and files that are ignored by the official parsers & validators, so proposals can be easily prototyped and tested on existing feeds.","title":"Guiding Principles"},{"location":"schedule/process/","text":"Specification amendment process \u00b6 The official specification, reference and documentation are written in English. If a translation to a different language differs from the English original, the latter takes precedence. All communication is performed in English. Create a git branch with update of all relevant parts of protocol definition, specification and documentation files (except for translations). Create pull request on https://github.com/google/transit. Pull request must contain an extended description of the patch. The creator of the pull request becomes the advocate . Once pull request is registered, it must be announced by its advocate in the GTFS Changes mailing list , including a link to the pull request. Once announced, the pull request is considered a proposal. The pull request should also be edited to contain a link to the Google Groups announcement so they can easily be cross-referenced. Since the advocate is a contributor, they must sign the Contributor License Agreement before pull request can be accepted. The discussion of the proposal follows. Pull request comments should be used as the sole discussion forum. The discussion lasts for as long as the advocate feels necessary, but must be at least 7 calendar days. The advocate is responsible for timely update of the proposal (i.e. pull request) based on the comments for which they agree to. At any point in time the advocate can claim proposal abandoned. The advocate can call for a vote on a version of the proposal at any point in time following the initial 7-day interval required for discussion. Before calling for a vote, at least one GTFS producer and one GTFS consumer should implement the proposed change. It is expected that the GTFS producer(s) include the change in a public-facing GTFS feed and provide a link to that data within the pull request comments, and that the GTFS consumer(s) provides a link in the pull request comments to an application that is utilizing the change in a non-trivial manner (i.e, it is supporting new or improved functionality). Vote lasts the minimum period sufficient to cover 7 full calendar days and 5 full Swiss business days. Vote ends at 23:59:59 UTC. The advocate should announce the specific end time at the start of the vote. During voting period only editorial changes to the proposal are allowed (typos, wording may change as long as it does not change the meaning). Anyone is allowed to vote yes/no in a form of comment to the pull request, and votes can be changed until the end of the voting period. If a voter changes her vote, it is recommended to do it by updating the original vote comment by striking through the vote and writing the new vote. Votes before the start of the voting period are not considered. Opening and closing of votes must be announced on the GTFS Changes mailing list . The proposal is accepted if there is a unanimous consensus yes with at least 3 votes. The proposer's vote does not count towards the 3 vote total. For example, if Proposer X creates a pull request and votes yes, and User Y and Z vote yes, this is counted as 2 total yes votes. Votes against shall be motivated, and ideally provide actionable feedback. If the vote has failed, then the advocate may choose to continue work on the proposal, or to abandon the proposal. Either decision of the advocate must be announced in the GTFS Changes mailing list . If the advocate continues the work on proposal then a new vote can be called for at any point in time. Any pull request remaining inactive for 30 calendar days will be closed. When a pull request is closed, the corresponding proposal is considered abandoned. The advocate may reopen the pull request at any time if they wish to continue or maintain the conversation. If the proposal is accepted: Google is committed to merging the voted upon version of the pull request (provided that the contributors have signed the CLA ), and performing the pull request within 5 business days. Translations must not be included into the original pull request. Google is responsible for eventually updating relevant translations into supported languages, but pure translation pull requests from the community are welcome and will be accepted as soon as all editorial comments are addressed. The final result of the pull request (accepted or abandoned) should be announced on the same Google Groups thread where the pull request was originally announced.","title":"Specification Amendment Process"},{"location":"schedule/process/#specification-amendment-process","text":"The official specification, reference and documentation are written in English. If a translation to a different language differs from the English original, the latter takes precedence. All communication is performed in English. Create a git branch with update of all relevant parts of protocol definition, specification and documentation files (except for translations). Create pull request on https://github.com/google/transit. Pull request must contain an extended description of the patch. The creator of the pull request becomes the advocate . Once pull request is registered, it must be announced by its advocate in the GTFS Changes mailing list , including a link to the pull request. Once announced, the pull request is considered a proposal. The pull request should also be edited to contain a link to the Google Groups announcement so they can easily be cross-referenced. Since the advocate is a contributor, they must sign the Contributor License Agreement before pull request can be accepted. The discussion of the proposal follows. Pull request comments should be used as the sole discussion forum. The discussion lasts for as long as the advocate feels necessary, but must be at least 7 calendar days. The advocate is responsible for timely update of the proposal (i.e. pull request) based on the comments for which they agree to. At any point in time the advocate can claim proposal abandoned. The advocate can call for a vote on a version of the proposal at any point in time following the initial 7-day interval required for discussion. Before calling for a vote, at least one GTFS producer and one GTFS consumer should implement the proposed change. It is expected that the GTFS producer(s) include the change in a public-facing GTFS feed and provide a link to that data within the pull request comments, and that the GTFS consumer(s) provides a link in the pull request comments to an application that is utilizing the change in a non-trivial manner (i.e, it is supporting new or improved functionality). Vote lasts the minimum period sufficient to cover 7 full calendar days and 5 full Swiss business days. Vote ends at 23:59:59 UTC. The advocate should announce the specific end time at the start of the vote. During voting period only editorial changes to the proposal are allowed (typos, wording may change as long as it does not change the meaning). Anyone is allowed to vote yes/no in a form of comment to the pull request, and votes can be changed until the end of the voting period. If a voter changes her vote, it is recommended to do it by updating the original vote comment by striking through the vote and writing the new vote. Votes before the start of the voting period are not considered. Opening and closing of votes must be announced on the GTFS Changes mailing list . The proposal is accepted if there is a unanimous consensus yes with at least 3 votes. The proposer's vote does not count towards the 3 vote total. For example, if Proposer X creates a pull request and votes yes, and User Y and Z vote yes, this is counted as 2 total yes votes. Votes against shall be motivated, and ideally provide actionable feedback. If the vote has failed, then the advocate may choose to continue work on the proposal, or to abandon the proposal. Either decision of the advocate must be announced in the GTFS Changes mailing list . If the advocate continues the work on proposal then a new vote can be called for at any point in time. Any pull request remaining inactive for 30 calendar days will be closed. When a pull request is closed, the corresponding proposal is considered abandoned. The advocate may reopen the pull request at any time if they wish to continue or maintain the conversation. If the proposal is accepted: Google is committed to merging the voted upon version of the pull request (provided that the contributors have signed the CLA ), and performing the pull request within 5 business days. Translations must not be included into the original pull request. Google is responsible for eventually updating relevant translations into supported languages, but pure translation pull requests from the community are welcome and will be accepted as soon as all editorial comments are addressed. The final result of the pull request (accepted or abandoned) should be announced on the same Google Groups thread where the pull request was originally announced.","title":"Specification amendment process"},{"location":"schedule/reference/","text":"GTFS Schedule Reference \u00b6 Revised September 15, 2021. See Revision History for more details. This document defines the format and structure of the files that comprise a GTFS dataset. Table of Contents \u00b6 Document Conventions Dataset Files File Requirements Field Definitions agency.txt stops.txt routes.txt trips.txt stop_times.txt calendar.txt calendar_dates.txt fare_attributes.txt fare_rules.txt shapes.txt frequencies.txt transfers.txt pathways.txt levels.txt translations.txt feed_info.txt attributions.txt Document Conventions \u00b6 The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \u201cSHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 . Term Definitions \u00b6 This section defines terms that are used throughout this document. Dataset - A complete set of files defined by this specification reference. Altering the dataset creates a new version of the dataset. Datasets should be published at a public, permanent URL, including the zip file name. (e.g., https://www.agency.org/gtfs/gtfs.zip). Record - A basic data structure comprised of a number of different field values describing a single entity (e.g. transit agency, stop, route, etc.). Represented, in a table, as a row. Field - A property of an object or entity. Represented, in a table, as a column. Field value - An individual entry in a field. Represented, in a table, as a single cell. Service day - A service day is a time period used to indicate route scheduling. The exact definition of service day varies from agency to agency but service days often do not correspond with calendar days. A service day may exceed 24:00:00 if service begins on one day and ends on a following day. For example, service that runs from 08:00:00 on Friday to 02:00:00 on Saturday, could be denoted as running from 08:00:00 to 26:00:00 on a single service day. Text-to-speech field - The field should contain the same information than its parent field (on which it falls back if it is empty). It is aimed to be read as text-to-speech, therefore, abbreviation should be either removed (\"St\" should be either read as \"Street\" or \"Saint\"; \"Elizabeth I\" should be \"Elizabeth the first\") or kept to be read as it (\"JFK Airport\" is said abbreviated). Presence \u00b6 Presence conditions applicable to fields and files: Required - The field or file must be included in the dataset and contain a valid value for each record. Optional - The field or file may be omitted from the dataset. Conditionally Required - The field or file must be included under conditions outlined in the field or file description. Field Types \u00b6 Color - A color encoded as a six-digit hexadecimal number. Refer to https://htmlcolorcodes.com to generate a valid value (the leading \"#\" must not be included). Example: FFFFFF for white, 000000 for black or 0039A6 for the A,C,E lines in NYMTA. Currency code - An ISO 4217 alphabetical currency code. For the list of current currency, refer to https://en.wikipedia.org/wiki/ISO_4217#Active_codes . Example: CAD for Canadian dollars, EUR for euros or JPY for Japanese yen. Date - Service day in the YYYYMMDD format. Since time within a service day may be above 24:00:00, a service day may contain information for the subsequent day(s). Example: 20180913 for September 13th, 2018. Email - An email address. Example: example@example.com Enum - An option from a set of predefined constants defined in the \"Description\" column. Example: The route_type field contains a 0 for tram, a 1 for subway... ID - An ID field value is an internal ID, not intended to be shown to riders, and is a sequence of any UTF-8 characters. Using only printable ASCII characters is recommended. An ID is labeled \"unique ID\" when it must be unique within a file. IDs defined in one .txt file are often referenced in another .txt file. IDs that reference an ID in another table are labeled \"foreign ID\". Example: The stop_id field in stops.txt is a \"unique ID\". The parent_station field in stops.txt is a \"foreign ID referencing stops.stop_id \". Language code - An IETF BCP 47 language code. For an introduction to IETF BCP 47, refer to https://www.rfc-editor.org/rfc/bcp/bcp47.txt and https://www.w3.org/International/articles/language-tags/ . Example: en for English, en-US for American English or de for German. Latitude - WGS84 latitude in decimal degrees. The value must be greater than or equal to -90.0 and less than or equal to 90.0. Example: 41.890169 for the Colosseum in Rome. Longitude - WGS84 longitude in decimal degrees. The value must be greater than or equal to -180.0 and less than or equal to 180.0. Example: 12.492269 for the Colosseum in Rome. Float - A floating point number. Integer - An integer. Phone number - A phone number. Time - Time in the HH:MM:SS format (H:MM:SS is also accepted). The time is measured from \"noon minus 12h\" of the service day (effectively midnight except for days on which daylight savings time changes occur). For times occurring after midnight, enter the time as a value greater than 24:00:00 in HH:MM:SS local time for the day on which the trip schedule begins. Example: 14:30:00 for 2:30PM or 25:35:00 for 1:35AM on the next day. Text - A string of UTF-8 characters, which is aimed to be displayed and which must therefore be human readable. Timezone - TZ timezone from the https://www.iana.org/time-zones . Timezone names never contain the space character but may contain an underscore. Refer to https://en.wikipedia.org/wiki/List_of_tz_zones for a list of valid values. Example: Asia/Tokyo , America/Los_Angeles or Africa/Cairo . URL - A fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following https://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values. Field Signs \u00b6 Signs applicable to Float or Integer field types: Non-negative - Greater than or equal to 0. Non-zero - Not equal to 0. Positive - Greater than 0. Example: Non-negative float - A floating point number greater than or equal to 0. Dataset Attributes \u00b6 The primary key of a dataset is the field or combination of fields that uniquely identify a row. Primary key (*) is used when all provided fields for a file are used to uniquely identify a row. Primary key (none) means that the file allows only one row. Example: the trip_id and stop_sequence fields make the primary key of stop_times.txt . Dataset Files \u00b6 This specification defines the following files: File Name Presence Description agency.txt Required Transit agencies with service represented in this dataset. stops.txt Required Stops where vehicles pick up or drop off riders. Also defines stations and station entrances. routes.txt Required Transit routes. A route is a group of trips that are displayed to riders as a single service. trips.txt Required Trips for each route. A trip is a sequence of two or more stops that occur during a specific time period. stop_times.txt Required Times that a vehicle arrives at and departs from stops for each trip. calendar.txt Conditionally Required Service dates specified using a weekly schedule with start and end dates. Conditionally Required: - Required unless all dates of service are defined in calendar_dates.txt . - Optional otherwise. calendar_dates.txt Conditionally Required Exceptions for the services defined in the calendar.txt . Conditionally Required: - Required if calendar.txt is omitted. In which case calendar_dates.txt must contain all dates of service. - Optional otherwise. fare_attributes.txt Optional Fare information for a transit agency's routes. fare_rules.txt Optional Rules to apply fares for itineraries. shapes.txt Optional Rules for mapping vehicle travel paths, sometimes referred to as route alignments. frequencies.txt Optional Headway (time between trips) for headway-based service or a compressed representation of fixed-schedule service. transfers.txt Optional Rules for making connections at transfer points between routes. pathways.txt Optional Pathways linking together locations within stations. levels.txt Conditionally Required Levels within stations. Conditionally Required: - Required when describing pathways with elevators ( pathway_mode=5 ). - Optional otherwise. translations.txt Optional Translations of customer-facing dataset values. feed_info.txt Optional Dataset metadata, including publisher, version, and expiration information. attributions.txt Optional Dataset attributions. File Requirements \u00b6 The following requirements apply to the format and contents of the dataset files: All files must be saved as comma-delimited text. The first line of each file must contain field names. Each subsection of the Field Definitions section corresponds to one of the files in a GTFS dataset and lists the field names that may be used in that file. All file and field names are case-sensitive. Field values must not contain tabs, carriage returns or new lines. Field values that contain quotation marks or commas must be enclosed within quotation marks. In addition, each quotation mark in the field value must be preceded with a quotation mark. This is consistent with the manner in which Microsoft Excel outputs comma-delimited (CSV) files. For more information on the CSV file format, see https://tools.ietf.org/html/rfc4180 . The following example demonstrates how a field value would appear in a comma-delimited file: Original field value: Contains \"quotes\", commas and text Field value in CSV file: \"Contains \"\"quotes\"\", commas and text\" Field values must not contain HTML tags, comments or escape sequences. Extra spaces between fields or field names should be removed. Many parsers consider the spaces to be part of the value, which may cause errors. Each line must end with a CRLF or LF linebreak character. Files should be encoded in UTF-8 to support all Unicode characters. Files that include the Unicode byte-order mark (BOM) character are acceptable. See https://unicode.org/faq/utf_bom.html#BOM for more information on the BOM character and UTF-8. All dataset files must be zipped together. Field Definitions \u00b6 agency.txt \u00b6 File: Required Primary key ( agency_id ) Field Name Type Presence Description agency_id Unique ID Conditionally Required Identifies a transit brand which is often synonymous with a transit agency. Note that in some cases, such as when a single agency operates multiple separate services, agencies and brands are distinct. This document uses the term \"agency\" in place of \"brand\". A dataset may contain data from multiple agencies. Conditionally Required: - Required when the dataset contains data for multiple transit agencies. - Optional otherwise. agency_name Text Required Full name of the transit agency. agency_url URL Required URL of the transit agency. agency_timezone Timezone Required Timezone where the transit agency is located. If multiple agencies are specified in the dataset, each must have the same agency_timezone . agency_lang Language code Optional Primary language used by this transit agency. Should be provided to help GTFS consumers choose capitalization rules and other language-specific settings for the dataset. agency_phone Phone number Optional A voice telephone number for the specified agency. This field is a string value that presents the telephone number as typical for the agency's service area. It may contain punctuation marks to group the digits of the number. Dialable text (for example, TriMet's \"503-238-RIDE\") is permitted, but the field must not contain any other descriptive text. agency_fare_url URL Optional URL of a web page that allows a rider to purchase tickets or other fare instruments for that agency online. agency_email Email Optional Email address actively monitored by the agency\u2019s customer service department. This email address should be a direct contact point where transit riders can reach a customer service representative at the agency. stops.txt \u00b6 File: Required Primary key ( stop_id ) Field Name Type Presence Description stop_id Unique ID Required Identifies a location: stop/platform, station, entrance/exit, generic node or boarding area (see location_type ). Multiple routes may use the same stop_id . stop_code Text Optional Short text or a number that identifies the location for riders. These codes are often used in phone-based transit information systems or printed on signage to make it easier for riders to get information for a particular location. The stop_code may be the same as stop_id if it is public facing. This field should be left empty for locations without a code presented to riders. stop_name Text Conditionally Required Name of the location. The stop_name should match the agency's rider-facing name for the location as printed on a timetable, published online, or represented on signage. For translations into other languages, use translations.txt . When the location is a boarding area ( location_type=4 ), the stop_name should contains the name of the boarding area as displayed by the agency. It could be just one letter (like on some European intercity railway stations), or text like \u201cWheelchair boarding area\u201d (NYC\u2019s Subway) or \u201cHead of short trains\u201d (Paris\u2019 RER). Conditionally Required: - Required for locations which are stops ( location_type=0 ), stations ( location_type=1 ) or entrances/exits ( location_type=2 ). - Optional for locations which are generic nodes ( location_type=3 ) or boarding areas ( location_type=4 ). tts_stop_name Text Optional Readable version of the stop_name . See \"Text-to-speech field\" in the Term Definitions for more. stop_desc Text Optional Description of the location that provides useful, quality information. Should not be a duplicate of stop_name . stop_lat Latitude Conditionally Required Latitude of the location. For stops/platforms ( location_type=0 ) and boarding area ( location_type=4 ), the coordinates must be the ones of the bus pole \u2014 if exists \u2014 and otherwise of where the travelers are boarding the vehicle (on the sidewalk or the platform, and not on the roadway or the track where the vehicle stops). Conditionally Required: - Required for locations which are stops ( location_type=0 ), stations ( location_type=1 ) or entrances/exits ( location_type=2 ). - Optional for locations which are generic nodes ( location_type=3 ) or boarding areas ( location_type=4 ). stop_lon Longitude Conditionally Required Longitude of the location. For stops/platforms ( location_type=0 ) and boarding area ( location_type=4 ), the coordinates must be the ones of the bus pole \u2014 if exists \u2014 and otherwise of where the travelers are boarding the vehicle (on the sidewalk or the platform, and not on the roadway or the track where the vehicle stops). Conditionally Required: - Required for locations which are stops ( location_type=0 ), stations ( location_type=1 ) or entrances/exits ( location_type=2 ). - Optional for locations which are generic nodes ( location_type=3 ) or boarding areas ( location_type=4 ). zone_id ID Conditionally Required Identifies the fare zone for a stop. If this record represents a station or station entrance, the zone_id is ignored. Conditionally Required: - Required if providing fare information using fare_rules.txt - Optional otherwise. stop_url URL Optional URL of a web page about the location. This should be different from the agency.agency_url and the routes.route_url field values. location_type Enum Optional Location type. Valid options are: 0 (or blank) - Stop (or Platform ). A location where passengers board or disembark from a transit vehicle. Is called a platform when defined within a parent_station . 1 - Station . A physical structure or area that contains one or more platform. 2 - Entrance/Exit . A location where passengers can enter or exit a station from the street. If an entrance/exit belongs to multiple stations, it may be linked by pathways to both, but the data provider must pick one of them as parent. 3 - Generic Node . A location within a station, not matching any other location_type , that may be used to link together pathways define in pathways.txt. 4 - Boarding Area . A specific location on a platform, where passengers can board and/or alight vehicles. parent_station Foreign ID referencing stops.stop_id Conditionally Required Defines hierarchy between the different locations defined in stops.txt . It contains the ID of the parent location, as followed: - Stop/platform ( location_type=0 ): the parent_station field contains the ID of a station. - Station ( location_type=1 ): this field must be empty. - Entrance/exit ( location_type=2 ) or generic node ( location_type=3 ): the parent_station field contains the ID of a station ( location_type=1 ) - Boarding Area ( location_type=4 ): the parent_station field contains ID of a platform. Conditionally Required: - Required for locations which are entrances ( location_type=2 ), generic nodes ( location_type=3 ) or boarding areas ( location_type=4 ). - Optional for stops/platforms ( location_type=0 ). - Forbidden for stations ( location_type=1 ). stop_timezone Timezone Optional Timezone of the location. If the location has a parent station, it inherits the parent station\u2019s timezone instead of applying its own. Stations and parentless stops with empty stop_timezone inherit the timezone specified by agency.agency_timezone . If stop_timezone values are provided, the times in stop_times.txt should be entered as the time since midnight in the timezone specified by agency.agency_timezone . This ensures that the time values in a trip always increase over the course of a trip, regardless of which timezones the trip crosses. wheelchair_boarding Enum Optional Indicates whether wheelchair boardings are possible from the location. Valid options are: For parentless stops: 0 or empty - No accessibility information for the stop. 1 - Some vehicles at this stop can be boarded by a rider in a wheelchair. 2 - Wheelchair boarding is not possible at this stop. For child stops: 0 or empty - Stop will inherit its wheelchair_boarding behavior from the parent station, if specified in the parent. 1 - There exists some accessible path from outside the station to the specific stop/platform. 2 - There exists no accessible path from outside the station to the specific stop/platform. For station entrances/exits: 0 or empty - Station entrance will inherit its wheelchair_boarding behavior from the parent station, if specified for the parent. 1 - Station entrance is wheelchair accessible. 2 - No accessible path from station entrance to stops/platforms. level_id Foreign ID referencing levels.level_id Optional Level of the location. The same level may be used by multiple unlinked stations. platform_code Text Optional Platform identifier for a platform stop (a stop belonging to a station). This should be just the platform identifier (eg. \"G\" or \"3\"). Words like \u201cplatform\u201d or \"track\" (or the feed\u2019s language-specific equivalent) should not be included. This allows feed consumers to more easily internationalize and localize the platform identifier into other languages. routes.txt \u00b6 File: Required Primary key ( route_id ) Field Name Type Presence Description route_id Unique ID Required Identifies a route. agency_id Foreign ID referencing agency.agency_id Conditionally Required Agency for the specified route. Conditionally Required: - Required if multiple agencies are defined in agency.txt . - Optional otherwise. route_short_name Text Conditionally Required Short name of a route. Often a short, abstract identifier (e.g., \"32\", \"100X\", \"Green\") that riders use to identify a route. Both route_short_name and route_long_name may be defined. Conditionally Required: - Required if routes.route_long_name is empty. - Optional otherwise. route_long_name Text Conditionally Required Full name of a route. This name is generally more descriptive than the route_short_name and often includes the route's destination or stop. Both route_short_name and route_long_name may be defined. Conditionally Required: - Required if routes.route_short_name is empty. - Optional otherwise. route_desc Text Optional Description of a route that provides useful, quality information. Should not be a duplicate of route_short_name or route_long_name . Example: \"A\" trains operate between Inwood-207 St, Manhattan and Far Rockaway-Mott Avenue, Queens at all times. Also from about 6AM until about midnight, additional \"A\" trains operate between Inwood-207 St and Lefferts Boulevard (trains typically alternate between Lefferts Blvd and Far Rockaway). route_type Enum Required Indicates the type of transportation used on a route. Valid options are: 0 - Tram, Streetcar, Light rail. Any light rail or street level system within a metropolitan area. 1 - Subway, Metro. Any underground rail system within a metropolitan area. 2 - Rail. Used for intercity or long-distance travel. 3 - Bus. Used for short- and long-distance bus routes. 4 - Ferry. Used for short- and long-distance boat service. 5 - Cable tram. Used for street-level rail cars where the cable runs beneath the vehicle (e.g., cable car in San Francisco). 6 - Aerial lift, suspended cable car (e.g., gondola lift, aerial tramway). Cable transport where cabins, cars, gondolas or open chairs are suspended by means of one or more cables. 7 - Funicular. Any rail system designed for steep inclines. 11 - Trolleybus. Electric buses that draw power from overhead wires using poles. 12 - Monorail. Railway in which the track consists of a single rail or a beam. route_url URL Optional URL of a web page about the particular route. Should be different from the agency.agency_url value. route_color Color Optional Route color designation that matches public facing material. Defaults to white ( FFFFFF ) when omitted or left empty. The color difference between route_color and route_text_color should provide sufficient contrast when viewed on a black and white screen. route_text_color Color Optional Legible color to use for text drawn against a background of route_color . Defaults to black ( 000000 ) when omitted or left empty. The color difference between route_color and route_text_color should provide sufficient contrast when viewed on a black and white screen. route_sort_order Non-negative integer Optional Orders the routes in a way which is ideal for presentation to customers. Routes with smaller route_sort_order values should be displayed first. continuous_pickup Enum Optional Indicates that the rider can board the transit vehicle at any point along the vehicle\u2019s travel path as described by shapes.txt , on every trip of the route. Valid options are: 0 - Continuous stopping pickup. 1 or empty - No continuous stopping pickup. 2 - Must phone agency to arrange continuous stopping pickup. 3 - Must coordinate with driver to arrange continuous stopping pickup. Values for routes.continuous_pickup may be overridden by defining values in stop_times.continuous_pickup for specific stop_time s along the route. continuous_drop_off Enum Optional Indicates that the rider can alight from the transit vehicle at any point along the vehicle\u2019s travel path as described by shapes.txt , on every trip of the route. Valid options are: 0 - Continuous stopping drop off. 1 or empty - No continuous stopping drop off. 2 - Must phone agency to arrange continuous stopping drop off. 3 - Must coordinate with driver to arrange continuous stopping drop off. Values for routes.continuous_drop_off may be overridden by defining values in stop_times.continuous_drop_off for specific stop_time s along the route. trips.txt \u00b6 File: Required Primary key ( trip_id ) Field Name Type Presence Description route_id Foreign ID referencing routes.route_id Required Identifies a route. service_id Foreign ID referencing calendar.service_id or calendar_dates.service_id Required Identifies a set of dates when service is available for one or more routes. trip_id Unique ID Required Identifies a trip. trip_headsign Text Optional Text that appears on signage identifying the trip's destination to riders. Should be used to distinguish between different patterns of service on the same route. If the headsign changes during a trip, values for trip_headsign may be overridden by defining values in stop_times.stop_headsign for specific stop_time s along the trip. trip_short_name Text Optional Public facing text used to identify the trip to riders, for instance, to identify train numbers for commuter rail trips. If riders do not commonly rely on trip names, trip_short_name should be empty. A trip_short_name value, if provided, should uniquely identify a trip within a service day; it should not be used for destination names or limited/express designations. direction_id Enum Optional Indicates the direction of travel for a trip. This field should not be used in routing; it provides a way to separate trips by direction when publishing time tables. Valid options are: 0 - Travel in one direction (e.g. outbound travel). 1 - Travel in the opposite direction (e.g. inbound travel). Example: The trip_headsign and direction_id fields may be used together to assign a name to travel in each direction for a set of trips. A trips.txt file could contain these records for use in time tables: trip_id,...,trip_headsign,direction_id 1234,...,Airport,0 1505,...,Downtown,1 block_id ID Optional Identifies the block to which the trip belongs. A block consists of a single trip or many sequential trips made using the same vehicle, defined by shared service days and block_id . A block_id may have trips with different service days, making distinct blocks. See the example below shape_id Foreign ID referencing shapes.shape_id Conditionally Required Identifies a geospatial shape describing the vehicle travel path for a trip. Conditionally Required: - Required if the trip has a continuous pickup or drop-off behavior defined either in routes.txt or in stop_times.txt . - Optional otherwise. wheelchair_accessible Enum Optional Indicates wheelchair accessibility. Valid options are: 0 or empty - No accessibility information for the trip. 1 - Vehicle being used on this particular trip can accommodate at least one rider in a wheelchair. 2 - No riders in wheelchairs can be accommodated on this trip. bikes_allowed Enum Optional Indicates whether bikes are allowed. Valid options are: 0 or empty - No bike information for the trip. 1 - Vehicle being used on this particular trip can accommodate at least one bicycle. 2 - No bicycles are allowed on this trip. Example: Blocks and service day \u00b6 The example below is valid, with distinct blocks every day of the week. route_id trip_id service_id block_id (first stop time) (last stop time) red trip_1 mon-tues-wed-thurs-fri-sat-sun red_loop 22:00:00 22:55:00 red trip_2 fri-sat-sun red_loop 23:00:00 23:55:00 red trip_3 fri-sat red_loop 24:00:00 24:55:00 red trip_4 mon-tues-wed-thurs red_loop 20:00:00 20:50:00 red trip_5 mon-tues-wed-thurs red_loop 21:00:00 21:50:00 Notes on above table: On Friday into Saturday morning, for example, a single vehicle operates trip_1 , trip_2 , and trip_3 (10:00 PM through 12:55 AM). Note that the last trip occurs on Saturday, 12:00 AM to 12:55 AM, but is part of the Friday \u201cservice day\u201d because the times are 24:00:00 to 24:55:00. On Monday, Tuesday, Wednesday, and Thursday, a single vehicle operates trip_1 , trip_4 , and trip_5 in a block from 8:00 PM to 10:55 PM. stop_times.txt \u00b6 File: Required Primary key ( trip_id , stop_sequence ) Field Name Type Presence Description trip_id Foreign ID referencing trips.trip_id Required Identifies a trip. arrival_time Time Conditionally Required Arrival time at the stop (defined by stop_times.stop_id ) for a specific trip (defined by stop_times.trip_id ). If there are not separate times for arrival and departure at a stop, arrival_time and departure_time should be the same. For times occurring after midnight on the service day, enter the time as a value greater than 24:00:00 in HH:MM:SS local time for the day on which the trip schedule begins. If exact arrival and departure times ( timepoint=1 or empty) are not available, estimated or interpolated arrival and departure times ( timepoint=0 ) should be provided. Conditionally Required: - Required for the first and last stop in a trip (defined by stop_times.stop_sequence ). - Required for timepoint=1 . - Optional otherwise. departure_time Time Conditionally Required Departure time from the stop (defined by stop_times.stop_id ) for a specific trip (defined by stop_times.trip_id ). If there are not separate times for arrival and departure at a stop, arrival_time and departure_time should be the same. For times occurring after midnight on the service day, enter the time as a value greater than 24:00:00 in HH:MM:SS local time for the day on which the trip schedule begins. If exact arrival and departure times ( timepoint=1 or empty) are not available, estimated or interpolated arrival and departure times ( timepoint=0 ) should be provided. Conditionally Required: - Required for timepoint=1 . - Optional otherwise. stop_id Foreign ID referencing stops.stop_id Required Identifies the serviced stop. All stops serviced during a trip must have a record in stop_times.txt . Referenced locations must be stops/platforms, i.e. their stops.location_type value must be 0 or empty. A stop may be serviced multiple times in the same trip, and multiple trips and routes may service the same stop. stop_sequence Non-negative integer Required Order of stops for a particular trip. The values must increase along the trip but do not need to be consecutive. Example: The first location on the trip could have a stop_sequence = 1 , the second location on the trip could have a stop_sequence = 23 , the third location could have a stop_sequence = 40 , and so on. stop_headsign Text Optional Text that appears on signage identifying the trip's destination to riders. This field overrides the default trips.trip_headsign when the headsign changes between stops. If the headsign is displayed for an entire trip, trips.trip_headsign should be used instead. A stop_headsign value specified for one stop_time does not apply to subsequent stop_time s in the same trip. If you want to override the trip_headsign for multiple stop_time s in the same trip, the stop_headsign value must be repeated in each stop_time row. pickup_type Enum Optional Indicates pickup method. Valid options are: 0 or empty - Regularly scheduled pickup. 1 - No pickup available. 2 - Must phone agency to arrange pickup. 3 - Must coordinate with driver to arrange pickup. drop_off_type Enum Optional Indicates drop off method. Valid options are: 0 or empty - Regularly scheduled drop off. 1 - No drop off available. 2 - Must phone agency to arrange drop off. 3 - Must coordinate with driver to arrange drop off. continuous_pickup Enum Optional Indicates that the rider can board the transit vehicle at any point along the vehicle\u2019s travel path as described by shapes.txt , from this stop_time to the next stop_time in the trip\u2019s stop_sequence . Valid options are: 0 - Continuous stopping pickup. 1 or empty - No continuous stopping pickup. 2 - Must phone agency to arrange continuous stopping pickup. 3 - Must coordinate with driver to arrange continuous stopping pickup. If this field is populated, it overrides any continuous pickup behavior defined in routes.txt . If this field is empty, the stop_time inherits any continuous pickup behavior defined in routes.txt . continuous_drop_off Enum Optional Indicates that the rider can alight from the transit vehicle at any point along the vehicle\u2019s travel path as described by shapes.txt , from this stop_time to the next stop_time in the trip\u2019s stop_sequence . Valid options are: 0 - Continuous stopping drop off. 1 or empty - No continuous stopping drop off. 2 - Must phone agency to arrange continuous stopping drop off. 3 - Must coordinate with driver to arrange continuous stopping drop off. If this field is populated, it overrides any continuous drop-off behavior defined in routes.txt . If this field is empty, the stop_time inherits any continuous drop-off behavior defined in routes.txt . shape_dist_traveled Non-negative float Optional Actual distance traveled along the associated shape, from the first stop to the stop specified in this record. This field specifies how much of the shape to draw between any two stops during a trip. Must be in the same units used in shapes.txt . Values used for shape_dist_traveled must increase along with stop_sequence ; they must not be used to show reverse travel along a route. Example: If a bus travels a distance of 5.25 kilometers from the start of the shape to the stop, shape_dist_traveled = 5.25 . timepoint Enum Optional Indicates if arrival and departure times for a stop are strictly adhered to by the vehicle or if they are instead approximate and/or interpolated times. This field allows a GTFS producer to provide interpolated stop-times, while indicating that the times are approximate. Valid options are: 0 - Times are considered approximate. 1 or empty - Times are considered exact. calendar.txt \u00b6 File: Conditionally Required Primary key ( service_id ) Field Name Type Presence Description service_id Unique ID Required Identifies a set of dates when service is available for one or more routes. Each service_id value must be unique in a calendar.txt file. monday Enum Required Indicates whether the service operates on all Mondays in the date range specified by the start_date and end_date fields. Note that exceptions for particular dates may be listed in calendar_dates.txt . Valid options are: 1 - Service is available for all Mondays in the date range. 0 - Service is not available for Mondays in the date range. tuesday Enum Required Functions in the same way as monday except applies to Tuesdays wednesday Enum Required Functions in the same way as monday except applies to Wednesdays thursday Enum Required Functions in the same way as monday except applies to Thursdays friday Enum Required Functions in the same way as monday except applies to Fridays saturday Enum Required Functions in the same way as monday except applies to Saturdays. sunday Enum Required Functions in the same way as monday except applies to Sundays. start_date Date Required Start service day for the service interval. end_date Date Required End service day for the service interval. This service day is included in the interval. calendar_dates.txt \u00b6 File: Conditionally Required Primary key ( service_id , date ) The calendar_dates.txt table explicitly activates or disables service by date. It may be used in two ways. Recommended: Use calendar_dates.txt in conjunction with calendar.txt to define exceptions to the default service patterns defined in calendar.txt . If service is generally regular, with a few changes on explicit dates (for instance, to accommodate special event services, or a school schedule), this is a good approach. In this case calendar_dates.service_id is a foreign ID referencing calendar.service_id . Alternate: Omit calendar.txt , and specify each date of service in calendar_dates.txt . This allows for considerable service variation and accommodates service without normal weekly schedules. In this case service_id is an ID. Field Name Type Presence Description service_id Foreign ID referencing calendar.service_id or ID Required Identifies a set of dates when a service exception occurs for one or more routes. Each ( service_id , date ) pair may only appear once in calendar_dates.txt if using calendar.txt and calendar_dates.txt in conjunction. If a service_id value appears in both calendar.txt and calendar_dates.txt , the information in calendar_dates.txt modifies the service information specified in calendar.txt . date Date Required Date when service exception occurs. exception_type Enum Required Indicates whether service is available on the date specified in the date field. Valid options are: 1 - Service has been added for the specified date. 2 - Service has been removed for the specified date. Example: Suppose a route has one set of trips available on holidays and another set of trips available on all other days. One service_id could correspond to the regular service schedule and another service_id could correspond to the holiday schedule. For a particular holiday, the calendar_dates.txt file could be used to add the holiday to the holiday service_id and to remove the holiday from the regular service_id schedule. fare_attributes.txt \u00b6 File: Optional Primary key ( fare_id ) Field Name Type Presence Description fare_id Unique ID Required Identifies a fare class. price Non-negative float Required Fare price, in the unit specified by currency_type . currency_type Currency code Required Currency used to pay the fare. payment_method Enum Required Indicates when the fare must be paid. Valid options are: 0 - Fare is paid on board. 1 - Fare must be paid before boarding. transfers Enum Required Indicates the number of transfers permitted on this fare. Valid options are: 0 - No transfers permitted on this fare. 1 - Riders may transfer once. 2 - Riders may transfer twice. empty - Unlimited transfers are permitted. agency_id Foreign ID referencing agency.agency_id Conditionally Required Identifies the relevant agency for a fare. Conditionally Required: - Required if multiple agencies are defined in agency.txt . - Optional otherwise. transfer_duration Non-negative integer Optional Length of time in seconds before a transfer expires. When transfers = 0 this field may be used to indicate how long a ticket is valid for or it may be left empty. fare_rules.txt \u00b6 File: Optional Primary key ( * ) The fare_rules.txt table specifies how fares in fare_attributes.txt apply to an itinerary. Most fare structures use some combination of the following rules: Fare depends on origin or destination stations. Fare depends on which zones the itinerary passes through. Fare depends on which route the itinerary uses. For examples that demonstrate how to specify a fare structure with fare_rules.txt and fare_attributes.txt , see https://code.google.com/p/googletransitdatafeed/wiki/FareExamples in the GoogleTransitDataFeed open source project wiki. Field Name Type Presence Description fare_id Foreign ID referencing fare_attributes.fare_id Required Identifies a fare class. route_id Foreign ID referencing routes.route_id Optional Identifies a route associated with the fare class. If several routes with the same fare attributes exist, create a record in fare_rules.txt for each route. Example: If fare class \"b\" is valid on route \"TSW\" and \"TSE\", the fare_rules.txt file would contain these records for the fare class: fare_id,route_id b,TSW b,TSE origin_id Foreign ID referencing stops.zone_id Optional Identifies an origin zone. If a fare class has multiple origin zones, create a record in fare_rules.txt for each origin_id . Example: If fare class \"b\" is valid for all travel originating from either zone \"2\" or zone \"8\", the fare_rules.txt file would contain these records for the fare class: fare_id,...,origin_id b,...,2 b,...,8 destination_id Foreign ID referencing stops.zone_id Optional Identifies a destination zone. If a fare class has multiple destination zones, create a record in fare_rules.txt for each destination_id . Example: The origin_id and destination_id fields could be used together to specify that fare class \"b\" is valid for travel between zones 3 and 4, and for travel between zones 3 and 5, the fare_rules.txt file would contain these records for the fare class: fare_id,...,origin_id,destination_id b,...,3,4 b,...,3,5 contains_id Foreign ID referencing stops.zone_id Optional Identifies the zones that a rider will enter while using a given fare class. Used in some systems to calculate correct fare class. Example: If fare class \"c\" is associated with all travel on the GRT route that passes through zones 5, 6, and 7 the fare_rules.txt would contain these records: fare_id,route_id,...,contains_id c,GRT,...,5 c,GRT,...,6 c,GRT,...,7 Because all contains_id zones must be matched for the fare to apply, an itinerary that passes through zones 5 and 6 but not zone 7 would not have fare class \"c\". For more detail, see https://code.google.com/p/googletransitdatafeed/wiki/FareExamples in the GoogleTransitDataFeed project wiki. shapes.txt \u00b6 File: Optional Primary key ( shape_id , shape_pt_sequence ) Shapes describe the path that a vehicle travels along a route alignment, and are defined in the file shapes.txt. Shapes are associated with Trips, and consist of a sequence of points through which the vehicle passes in order. Shapes do not need to intercept the location of Stops exactly, but all Stops on a trip should lie within a small distance of the shape for that trip, i.e. close to straight line segments connecting the shape points. Field Name Type Presence Description shape_id ID Required Identifies a shape. shape_pt_lat Latitude Required Latitude of a shape point. Each record in shapes.txt represents a shape point used to define the shape. shape_pt_lon Longitude Required Longitude of a shape point. shape_pt_sequence Non-negative integer Required Sequence in which the shape points connect to form the shape. Values must increase along the trip but do not need to be consecutive. Example: If the shape \"A_shp\" has three points in its definition, the shapes.txt file might contain these records to define the shape: shape_id,shape_pt_lat,shape_pt_lon,shape_pt_sequence A_shp,37.61956,-122.48161,0 A_shp,37.64430,-122.41070,6 A_shp,37.65863,-122.30839,11 shape_dist_traveled Non-negative float Optional Actual distance traveled along the shape from the first shape point to the point specified in this record. Used by trip planners to show the correct portion of the shape on a map. Values must increase along with shape_pt_sequence ; they must not be used to show reverse travel along a route. Distance units must be consistent with those used in stop_times.txt . Example: If a bus travels along the three points defined above for A_shp, the additional shape_dist_traveled values (shown here in kilometers) would look like this: shape_id,shape_pt_lat,shape_pt_lon,shape_pt_sequence,shape_dist_traveled A_shp,37.61956,-122.48161,0,0 A_shp,37.64430,-122.41070,6,6.8310 A_shp,37.65863,-122.30839,11,15.8765 frequencies.txt \u00b6 File: Optional Primary key ( trip_id , start_time ) Frequencies.txt represents trips that operate on regular headways (time between trips). This file may be used to represent two different types of service. Frequency-based service ( exact_times = 0 ) in which service does not follow a fixed schedule throughout the day. Instead, operators attempt to strictly maintain predetermined headways for trips. A compressed representation of schedule-based service ( exact_times = 1 ) that has the exact same headway for trips over specified time period(s). In schedule-based service operators try to strictly adhere to a schedule. Field Name Type Presence Description trip_id Foreign ID referencing trips.trip_id Required Identifies a trip to which the specified headway of service applies. start_time Time Required Time at which the first vehicle departs from the first stop of the trip with the specified headway. end_time Time Required Time at which service changes to a different headway (or ceases) at the first stop in the trip. headway_secs Positive integer Required Time, in seconds, between departures from the same stop (headway) for the trip, during the time interval specified by start_time and end_time . Multiple headways may be defined for the same trip, but must not overlap. New headways may start at the exact time the previous headway ends. exact_times Enum Optional Indicates the type of service for a trip. See the file description for more information. Valid options are: 0 or empty - Frequency-based trips. 1 - Schedule-based trips with the exact same headway throughout the day. In this case the end_time value must be greater than the last desired trip start_time but less than the last desired trip start_time + headway_secs . transfers.txt \u00b6 File: Optional Primary key ( from_stop_id , to_stop_id , from_trip_id , to_trip_id , from_route_id , to_route_id ) When calculating an itinerary, GTFS-consuming applications interpolate transfers based on allowable time and stop proximity. Transfers.txt specifies additional rules and overrides for selected transfers. Fields from_trip_id , to_trip_id , from_route_id and to_route_id allow higher orders of specificity for transfer rules. Along with from_stop_id and to_stop_id , the ranking of specificity is as follows: Both trip_id s defined: from_trip_id and to_trip_id . One trip_id and route_id set defined: ( from_trip_id and to_route_id ) or ( from_route_id and to_trip_id ). One trip_id defined: from_trip_id or to_trip_id . Both route_id s defined: from_route_id and to_route_id . One route_id defined: from_route_id or to_route_id . Only from_stop_id and to_stop_id defined: no route or trip related fields set. For a given ordered pair of arriving trip and departing trip, the transfer with the greatest specificity that applies between these two trips is chosen. For any pair of trips, there should not be two transfers with equally maximal specificity that could apply. Field Name Type Presence Description from_stop_id Foreign ID referencing stops.stop_id Required Identifies a stop or station where a connection between routes begins. If this field refers to a station, the transfer rule applies to all its child stops. to_stop_id Foreign ID referencing stops.stop_id Required Identifies a stop or station where a connection between routes ends. If this field refers to a station, the transfer rule applies to all child stops. from_route_id Foreign ID referencing routes.route_id Optional Identifies a route where a connection begins. If from_route_id is defined, the transfer will apply to the arriving trip on the route for the given from_stop_id . If both from_trip_id and from_route_id are defined, the trip_id must belong to the route_id , and from_trip_id will take precedence. to_route_id Foreign ID referencing routes.route_id Optional Identifies a route where a connection ends. If to_route_id is defined, the transfer will apply to the departing trip on the route for the given to_stop_id . If both to_trip_id and to_route_id are defined, the trip_id must belong to the route_id , and to_trip_id will take precedence. from_trip_id Foreign ID referencing trips.trip_id Optional Identifies a trip where a connection between routes begins. If from_trip_id is defined, the transfer will apply to the arriving trip for the given from_stop_id . If both from_trip_id and from_route_id are defined, the trip_id must belong to the route_id , and from_trip_id will take precedence. to_trip_id Foreign ID referencing trips.trip_id Optional Identifies a trip where a connection between routes ends. If to_trip_id is defined, the transfer will apply to the departing trip for the given to_stop_id . If both to_trip_id and to_route_id are defined, the trip_id must belong to the route_id , and to_trip_id will take precedence. transfer_type Enum Required Indicates the type of connection for the specified ( from_stop_id , to_stop_id ) pair. Valid options are: 0 or empty - Recommended transfer point between routes. 1 - Timed transfer point between two routes. The departing vehicle is expected to wait for the arriving one and leave sufficient time for a rider to transfer between routes. 2 - Transfer requires a minimum amount of time between arrival and departure to ensure a connection. The time required to transfer is specified by min_transfer_time . 3 - Transfers are not possible between routes at the location. min_transfer_time Non-negative integer Optional Amount of time, in seconds, that must be available to permit a transfer between routes at the specified stops. The min_transfer_time should be sufficient to permit a typical rider to move between the two stops, including buffer time to allow for schedule variance on each route. pathways.txt \u00b6 File: Optional Primary key ( pathway_id ) Files pathways.txt and levels.txt use a graph representation to describe subway or train stations, with nodes representing locations and edges representing pathways. To navigate from the station entrance/exit (a node represented as a location with location_type=2 ) to a platform (a node represented as a location with location_type=0 or empty), the rider will move through walkways, fare gates, stairs, and other edges represented as pathways. Generic nodes (nodes represented with location_type=3 ) can be used to connect pathways throughout a station. Pathways must be defined exhaustively in a station. If any pathways are defined, it is assumed that all pathways throughout the station are represented. Therefore, the following guidelines apply: No dangling locations: If any location within a station has a pathway, then all locations within that station should have pathways, except for platforms that have boarding areas ( location_type=4 , see guideline below). No pathways for a platform with boarding areas: A platform ( location_type=0 or empty) that has boarding areas ( location_type=4 ) is treated as a parent object, not a point. In such cases, the platform must not have pathways assigned. All pathways should be assigned for each of the platform's boarding areas. No locked platforms: Each platform ( location_type=0 or empty) or boarding area ( location_type=4 ) must be connected to at least one entrance/exit ( location_type=2 ) via some chain of pathways. Stations not allowing a pathway to the outside of the station from a given platform are rare. Field Name Type Presence Description pathway_id Unique ID Required Identifies a pathway. Used by systems as an internal identifier for the record. Must be unique in the dataset. Different pathways may have the same values for from_stop_id and to_stop_id . Example: When two escalators are side-by-side in opposite directions, or when a stair set and elevator go from the same place to the same place, different pathway_id may have the same from_stop_id and to_stop_id values. from_stop_id Foreign ID referencing stops.stop_id Required Location at which the pathway begins. Must contain a stop_id that identifies a platform ( location_type=0 or empty), entrance/exit ( location_type=2 ), generic node ( location_type=3 ) or boarding area ( location_type=4 ). Values for stop_id that identify stations ( location_type=1 ) are forbidden. to_stop_id Foreign ID referencing stops.stop_id Required Location at which the pathway ends. Must contain a stop_id that identifies a platform ( location_type=0 or empty), entrance/exit ( location_type=2 ), generic node ( location_type=3 ) or boarding area ( location_type=4 ). Values for stop_id that identify stations ( location_type=1 ) are forbidden. pathway_mode Enum Required Type of pathway between the specified ( from_stop_id , to_stop_id ) pair. Valid options are: 1 - Walkway. 2 - Stairs. 3 - Moving sidewalk/travelator. 4 - Escalator. 5 - Elevator. 6 - Fare gate (or payment gate): A pathway that crosses into an area of the station where proof of payment is required to cross. Fare gates may separate paid areas of the station from unpaid ones, or separate different payment areas within the same station from each other. This information can be used to avoid routing passengers through stations using shortcuts that would require passengers to make unnecessary payments, like directing a passenger to walk through a subway platform to reach a busway. 7 - Exit gate: A pathway exiting a paid area into an unpaid area where proof of payment is not required to cross. is_bidirectional Enum Required Indicates the direction that the pathway can be taken: 0 - Unidirectional pathway that can only be used from from_stop_id to to_stop_id . 1 - Bidirectional pathway that can be used in both directions. Exit gates ( pathway_mode=7 ) must not be bidirectional. length Non-negative float Optional Horizontal length in meters of the pathway from the origin location (defined in from_stop_id ) to the destination location (defined in to_stop_id ). This field is recommended for walkways ( pathway_mode=1 ), fare gates ( pathway_mode=6 ) and exit gates ( pathway_mode=7 ). traversal_time Positive integer Optional Average time in seconds needed to walk through the pathway from the origin location (defined in from_stop_id ) to the destination location (defined in to_stop_id ). This field is recommended for moving sidewalks ( pathway_mode=3 ), escalators ( pathway_mode=4 ) and elevator ( pathway_mode=5 ). stair_count Non-null integer Optional Number of stairs of the pathway. A positive stair_count implies that the rider walk up from from_stop_id to to_stop_id . And a negative stair_count implies that the rider walk down from from_stop_id to to_stop_id . This field is recommended for stairs ( pathway_mode=2 ). If only an estimated stair count can be provided, it is recommended to approximate 15 stairs for 1 floor. max_slope Float Optional Maximum slope ratio of the pathway. Valid options are: 0 or empty - No slope. Float - Slope ratio of the pathway, positive for upwards, negative for downwards. This field should only be used with walkways ( pathway_mode=1 ) and moving sidewalks ( pathway_mode=3 ). Example: In the US, 0.083 (also written 8.3%) is the maximum slope ratio for hand-propelled wheelchair, which mean an increase of 0.083m (so 8.3cm) for each 1m. min_width Positive float Optional Minimum width of the pathway in meters. This field is recommended if the minimum width is less than 1 meter. signposted_as Text Optional Public facing text from physical signage that is visible to riders. May be used to provide text directions to riders, such as 'follow signs to '. The text in singposted_as should appear exactly how it is printed on the signs. When the physical signage is multilingual, this field may be populated and translated following the example of stops.stop_name in the field definition of feed_info.feed_lang . reversed_signposted_as Text Optional Same as signposted_as , but when the pathway is used from the to_stop_id to the from_stop_id . levels.txt \u00b6 File: Conditionally Required Primary key ( level_id ) Describes levels in a station. Useful in conjunction with pathways.txt , and is required for navigating pathways with elevators ( pathway_mode=5 ). Field Name Type Presence Description level_id Unique ID Required Identifies a level in a station. level_index Float Required Numeric index of the level that indicates its relative position. Ground level should have index 0 , with levels above ground indicated by positive indices and levels below ground by negative indices. level_name Text Optional Name of the level as seen by the rider inside the building or station. Example: Take the elevator to \"Mezzanine\" or \"Platform\" or \"-1\". translations.txt \u00b6 File: Optional Primary key ( * ) In regions that have multiple official languages, transit agencies/operators typically have language-specific names and web pages. In order to best serve riders in those regions, it is useful for the dataset to include these language-dependent values. Field Name Type Presence Description table_name Enum Required Defines the table that contains the field to be translated. Allowed values are: - agency - stops - routes - trips - stop_times - pathways - levels - feed_info - attributions Any file added to GTFS will have a table_name value equivalent to the file name, as listed above (i.e., not including the .txt file extension). field_name Text Required Name of the field to be translated. Fields with type Text may be translated, fields with type URL , Email and Phone number may also be \u201ctranslated\u201d to provide resources in the correct language. Fields with other types should not be translated. language Language code Required Language of translation. If the language is the same as in feed_info.feed_lang , the original value of the field will be assumed to be the default value to use in languages without specific translations (if default_lang doesn't specify otherwise). Example: In Switzerland, a city in an officially bilingual canton is officially called \u201cBiel/Bienne\u201d, but would simply be called \u201cBienne\u201d in French and \u201cBiel\u201d in German. translation Text or URL or Email or Phone number Required Translated value. record_id Foreign ID Conditionally Required Defines the record that corresponds to the field to be translated. The value in record_id must be the first or only field of a table's primary key, as defined in the primary key attribute for each table and below: - agency_id for agency.txt - stop_id for stops.txt ; - route_id for routes.txt ; - trip_id for trips.txt ; - trip_id for stop_times.txt ; - pathway_id for pathways.txt ; - level_id for levels.txt ; - attribution_id for attribution.txt . Fields in tables not defined above should not be translated. However producers sometimes add extra fields that are outside the official specification and these unofficial fields may be translated. Below is the recommended way to use record_id for those tables: - service_id for calendar.txt ; - service_id for calendar_dates.txt ; - fare_id for fare_attributes.txt ; - fare_id for fare_rules.txt ; - shape_id for shapes.txt ; - trip_id for frequencies.txt ; - from_stop_id for transfers.txt . Conditionally Required: - Forbidden if table_name is feed_info . - Forbidden if field_value is defined. - Required if field_value is empty. record_sub_id Foreign ID Conditionally Required Helps the record that contains the field to be translated when the table doesn\u2019t have a unique ID. Therefore, the value in record_sub_id is the secondary ID of the table, as defined by the table below: - None for agency.txt ; - None for stops.txt ; - None for routes.txt ; - None for trips.txt ; - stop_sequence for stop_times.txt ; - None for pathways.txt ; - None for levels.txt ; - None for attributions.txt . Fields in tables not defined above should not be translated. However producers sometimes add extra fields that are outside the official specification and these unofficial fields may be translated. Below is the recommended way to use record_sub_id for those tables: - None for calendar.txt ; - date for calendar_dates.txt ; - None for fare_attributes.txt ; - route_id for fare_rules.txt ; - None for shapes.txt ; - start_time for frequencies.txt ; - to_stop_id for transfers.txt . Conditionally Required: - Forbidden if table_name is feed_info . - Forbidden if field_value is defined. - Required if table_name=stop_times and record_id is defined. field_value Text or URL or Email or Phone number Conditionally Required Instead of defining which record should be translated by using record_id and record_sub_id , this field can be used to define the value which should be translated. When used, the translation will be applied when the fields identified by table_name and field_name contains the exact same value defined in field_value. The field must have exactly the value defined in field_value . If only a subset of the value matches field_value , the translation won\u2019t be applied. If two translation rules match the same record (one with field_value , and the other one with record_id ), the rule with record_id takes precedence. Conditionally Required: - Forbidden if table_name is feed_info . - Forbidden if record_id is defined. - Required if record_id is empty. feed_info.txt \u00b6 File: Optional ( Required if translations.txt is provided) Primary key (none) The file contains information about the dataset itself, rather than the services that the dataset describes. In some cases, the publisher of the dataset is a different entity than any of the agencies. Field Name Type Presence Description feed_publisher_name Text Required Full name of the organization that publishes the dataset. This may be the same as one of the agency.agency_name values. feed_publisher_url URL Required URL of the dataset publishing organization's website. This may be the same as one of the agency.agency_url values. feed_lang Language code Required Default language used for the text in this dataset. This setting helps GTFS consumers choose capitalization rules and other language-specific settings for the dataset. The file translations.txt can be used if the text needs to be translated into languages other than the default one. The default language may be multilingual for datasets with the original text in multiple languages. In such cases, the feed_lang field should contain the language code mul defined by the norm ISO 639-2, and a translation for each language used in the dataset should be provided in translations.txt . If all the original text in the dataset is in the same language, then mul should not be used. Example: Consider a dataset from a multilingual country like Switzerland, with the original stops.stop_name field populated with stop names in different languages. Each stop name is written according to the dominant language in that stop\u2019s geographic location, e.g. Gen\u00e8ve for the French-speaking city of Geneva, Z\u00fcrich for the German-speaking city of Zurich, and Biel/Bienne for the bilingual city of Biel/Bienne. The dataset feed_lang should be mul and translations would be provided in translations.txt , in German: Genf , Z\u00fcrich and Biel ; in French: Gen\u00e8ve , Zurich and Bienne ; in Italian: Ginevra , Zurigo and Bienna ; and in English: Geneva , Zurich and Biel/Bienne . default_lang Language code Optional Defines the language that should be used when the data consumer doesn\u2019t know the language of the rider. It will often be en (English). feed_start_date Date Optional The dataset provides complete and reliable schedule information for service in the period from the beginning of the feed_start_date day to the end of the feed_end_date day. Both days may be left empty if unavailable. The feed_end_date date must not precede the feed_start_date date if both are given. It is recommended that dataset providers give schedule data outside this period to advise of likely future service, but dataset consumers should treat it mindful of its non-authoritative status. If feed_start_date or feed_end_date extend beyond the active calendar dates defined in calendar.txt and calendar_dates.txt , the dataset is making an explicit assertion that there is no service for dates within the feed_start_date or feed_end_date range but not included in the active calendar dates. feed_end_date Date Optional (see above) feed_version Text Optional String that indicates the current version of their GTFS dataset. GTFS-consuming applications can display this value to help dataset publishers determine whether the latest dataset has been incorporated. feed_contact_email Email Optional Email address for communication regarding the GTFS dataset and data publishing practices. feed_contact_email is a technical contact for GTFS-consuming applications. Provide customer service contact information through agency.txt . feed_contact_url URL Optional URL for contact information, a web-form, support desk, or other tools for communication regarding the GTFS dataset and data publishing practices. feed_contact_url is a technical contact for GTFS-consuming applications. Provide customer service contact information through agency.txt . attributions.txt \u00b6 File: Optional Primary key ( attribution_id ) The file defines the attributions applied to the dataset. Field Name Type Presence Description attribution_id Unique ID Optional Identifies an attribution for the dataset or a subset of it. This is mostly useful for translations. agency_id Foreign ID referencing agency.agency_id Optional Agency to which the attribution applies. If one agency_id , route_id , or trip_id attribution is defined, the other ones must be empty. If none of them is specified, the attribution will apply to the whole dataset. route_id Foreign ID referencing routes.route_id Optional Functions in the same way as agency_id except the attribution applies to a route. Multiple attributions may apply to the same route. trip_id Foreign ID referencing trips.trip_id Optional Functions in the same way as agency_id except the attribution applies to a trip. Multiple attributions may apply to the same trip. organization_name Text Required Name of the organization that the dataset is attributed to. is_producer Enum Optional The role of the organization is producer. Valid options are: 0 or empty - Organization doesn\u2019t have this role. 1 - Organization does have this role. At least one of the fields is_producer , is_operator , or is_authority should be set at 1 . is_operator Enum Optional Functions in the same way as is_producer except the role of the organization is operator. is_authority Enum Optional Functions in the same way as is_producer except the role of the organization is authority. attribution_url URL Optional URL of the organization. attribution_email Email Optional Email of the organization. attribution_phone Phone number Optional Phone number of the organization.","title":"Reference"},{"location":"schedule/reference/#gtfs-schedule-reference","text":"Revised September 15, 2021. See Revision History for more details. This document defines the format and structure of the files that comprise a GTFS dataset.","title":"GTFS Schedule Reference"},{"location":"schedule/reference/#table-of-contents","text":"Document Conventions Dataset Files File Requirements Field Definitions agency.txt stops.txt routes.txt trips.txt stop_times.txt calendar.txt calendar_dates.txt fare_attributes.txt fare_rules.txt shapes.txt frequencies.txt transfers.txt pathways.txt levels.txt translations.txt feed_info.txt attributions.txt","title":"Table of Contents"},{"location":"schedule/reference/#document-conventions","text":"The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \u201cSHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 .","title":"Document Conventions"},{"location":"schedule/reference/#term-definitions","text":"This section defines terms that are used throughout this document. Dataset - A complete set of files defined by this specification reference. Altering the dataset creates a new version of the dataset. Datasets should be published at a public, permanent URL, including the zip file name. (e.g., https://www.agency.org/gtfs/gtfs.zip). Record - A basic data structure comprised of a number of different field values describing a single entity (e.g. transit agency, stop, route, etc.). Represented, in a table, as a row. Field - A property of an object or entity. Represented, in a table, as a column. Field value - An individual entry in a field. Represented, in a table, as a single cell. Service day - A service day is a time period used to indicate route scheduling. The exact definition of service day varies from agency to agency but service days often do not correspond with calendar days. A service day may exceed 24:00:00 if service begins on one day and ends on a following day. For example, service that runs from 08:00:00 on Friday to 02:00:00 on Saturday, could be denoted as running from 08:00:00 to 26:00:00 on a single service day. Text-to-speech field - The field should contain the same information than its parent field (on which it falls back if it is empty). It is aimed to be read as text-to-speech, therefore, abbreviation should be either removed (\"St\" should be either read as \"Street\" or \"Saint\"; \"Elizabeth I\" should be \"Elizabeth the first\") or kept to be read as it (\"JFK Airport\" is said abbreviated).","title":"Term Definitions"},{"location":"schedule/reference/#presence","text":"Presence conditions applicable to fields and files: Required - The field or file must be included in the dataset and contain a valid value for each record. Optional - The field or file may be omitted from the dataset. Conditionally Required - The field or file must be included under conditions outlined in the field or file description.","title":"Presence"},{"location":"schedule/reference/#field-types","text":"Color - A color encoded as a six-digit hexadecimal number. Refer to https://htmlcolorcodes.com to generate a valid value (the leading \"#\" must not be included). Example: FFFFFF for white, 000000 for black or 0039A6 for the A,C,E lines in NYMTA. Currency code - An ISO 4217 alphabetical currency code. For the list of current currency, refer to https://en.wikipedia.org/wiki/ISO_4217#Active_codes . Example: CAD for Canadian dollars, EUR for euros or JPY for Japanese yen. Date - Service day in the YYYYMMDD format. Since time within a service day may be above 24:00:00, a service day may contain information for the subsequent day(s). Example: 20180913 for September 13th, 2018. Email - An email address. Example: example@example.com Enum - An option from a set of predefined constants defined in the \"Description\" column. Example: The route_type field contains a 0 for tram, a 1 for subway... ID - An ID field value is an internal ID, not intended to be shown to riders, and is a sequence of any UTF-8 characters. Using only printable ASCII characters is recommended. An ID is labeled \"unique ID\" when it must be unique within a file. IDs defined in one .txt file are often referenced in another .txt file. IDs that reference an ID in another table are labeled \"foreign ID\". Example: The stop_id field in stops.txt is a \"unique ID\". The parent_station field in stops.txt is a \"foreign ID referencing stops.stop_id \". Language code - An IETF BCP 47 language code. For an introduction to IETF BCP 47, refer to https://www.rfc-editor.org/rfc/bcp/bcp47.txt and https://www.w3.org/International/articles/language-tags/ . Example: en for English, en-US for American English or de for German. Latitude - WGS84 latitude in decimal degrees. The value must be greater than or equal to -90.0 and less than or equal to 90.0. Example: 41.890169 for the Colosseum in Rome. Longitude - WGS84 longitude in decimal degrees. The value must be greater than or equal to -180.0 and less than or equal to 180.0. Example: 12.492269 for the Colosseum in Rome. Float - A floating point number. Integer - An integer. Phone number - A phone number. Time - Time in the HH:MM:SS format (H:MM:SS is also accepted). The time is measured from \"noon minus 12h\" of the service day (effectively midnight except for days on which daylight savings time changes occur). For times occurring after midnight, enter the time as a value greater than 24:00:00 in HH:MM:SS local time for the day on which the trip schedule begins. Example: 14:30:00 for 2:30PM or 25:35:00 for 1:35AM on the next day. Text - A string of UTF-8 characters, which is aimed to be displayed and which must therefore be human readable. Timezone - TZ timezone from the https://www.iana.org/time-zones . Timezone names never contain the space character but may contain an underscore. Refer to https://en.wikipedia.org/wiki/List_of_tz_zones for a list of valid values. Example: Asia/Tokyo , America/Los_Angeles or Africa/Cairo . URL - A fully qualified URL that includes http:// or https://, and any special characters in the URL must be correctly escaped. See the following https://www.w3.org/Addressing/URL/4_URI_Recommentations.html for a description of how to create fully qualified URL values.","title":"Field Types"},{"location":"schedule/reference/#field-signs","text":"Signs applicable to Float or Integer field types: Non-negative - Greater than or equal to 0. Non-zero - Not equal to 0. Positive - Greater than 0. Example: Non-negative float - A floating point number greater than or equal to 0.","title":"Field Signs"},{"location":"schedule/reference/#dataset-attributes","text":"The primary key of a dataset is the field or combination of fields that uniquely identify a row. Primary key (*) is used when all provided fields for a file are used to uniquely identify a row. Primary key (none) means that the file allows only one row. Example: the trip_id and stop_sequence fields make the primary key of stop_times.txt .","title":"Dataset Attributes"},{"location":"schedule/reference/#dataset-files","text":"This specification defines the following files: File Name Presence Description agency.txt Required Transit agencies with service represented in this dataset. stops.txt Required Stops where vehicles pick up or drop off riders. Also defines stations and station entrances. routes.txt Required Transit routes. A route is a group of trips that are displayed to riders as a single service. trips.txt Required Trips for each route. A trip is a sequence of two or more stops that occur during a specific time period. stop_times.txt Required Times that a vehicle arrives at and departs from stops for each trip. calendar.txt Conditionally Required Service dates specified using a weekly schedule with start and end dates. Conditionally Required: - Required unless all dates of service are defined in calendar_dates.txt . - Optional otherwise. calendar_dates.txt Conditionally Required Exceptions for the services defined in the calendar.txt . Conditionally Required: - Required if calendar.txt is omitted. In which case calendar_dates.txt must contain all dates of service. - Optional otherwise. fare_attributes.txt Optional Fare information for a transit agency's routes. fare_rules.txt Optional Rules to apply fares for itineraries. shapes.txt Optional Rules for mapping vehicle travel paths, sometimes referred to as route alignments. frequencies.txt Optional Headway (time between trips) for headway-based service or a compressed representation of fixed-schedule service. transfers.txt Optional Rules for making connections at transfer points between routes. pathways.txt Optional Pathways linking together locations within stations. levels.txt Conditionally Required Levels within stations. Conditionally Required: - Required when describing pathways with elevators ( pathway_mode=5 ). - Optional otherwise. translations.txt Optional Translations of customer-facing dataset values. feed_info.txt Optional Dataset metadata, including publisher, version, and expiration information. attributions.txt Optional Dataset attributions.","title":"Dataset Files"},{"location":"schedule/reference/#file-requirements","text":"The following requirements apply to the format and contents of the dataset files: All files must be saved as comma-delimited text. The first line of each file must contain field names. Each subsection of the Field Definitions section corresponds to one of the files in a GTFS dataset and lists the field names that may be used in that file. All file and field names are case-sensitive. Field values must not contain tabs, carriage returns or new lines. Field values that contain quotation marks or commas must be enclosed within quotation marks. In addition, each quotation mark in the field value must be preceded with a quotation mark. This is consistent with the manner in which Microsoft Excel outputs comma-delimited (CSV) files. For more information on the CSV file format, see https://tools.ietf.org/html/rfc4180 . The following example demonstrates how a field value would appear in a comma-delimited file: Original field value: Contains \"quotes\", commas and text Field value in CSV file: \"Contains \"\"quotes\"\", commas and text\" Field values must not contain HTML tags, comments or escape sequences. Extra spaces between fields or field names should be removed. Many parsers consider the spaces to be part of the value, which may cause errors. Each line must end with a CRLF or LF linebreak character. Files should be encoded in UTF-8 to support all Unicode characters. Files that include the Unicode byte-order mark (BOM) character are acceptable. See https://unicode.org/faq/utf_bom.html#BOM for more information on the BOM character and UTF-8. All dataset files must be zipped together.","title":"File Requirements"},{"location":"schedule/reference/#field-definitions","text":"","title":"Field Definitions"},{"location":"schedule/reference/#agencytxt","text":"File: Required Primary key ( agency_id ) Field Name Type Presence Description agency_id Unique ID Conditionally Required Identifies a transit brand which is often synonymous with a transit agency. Note that in some cases, such as when a single agency operates multiple separate services, agencies and brands are distinct. This document uses the term \"agency\" in place of \"brand\". A dataset may contain data from multiple agencies. Conditionally Required: - Required when the dataset contains data for multiple transit agencies. - Optional otherwise. agency_name Text Required Full name of the transit agency. agency_url URL Required URL of the transit agency. agency_timezone Timezone Required Timezone where the transit agency is located. If multiple agencies are specified in the dataset, each must have the same agency_timezone . agency_lang Language code Optional Primary language used by this transit agency. Should be provided to help GTFS consumers choose capitalization rules and other language-specific settings for the dataset. agency_phone Phone number Optional A voice telephone number for the specified agency. This field is a string value that presents the telephone number as typical for the agency's service area. It may contain punctuation marks to group the digits of the number. Dialable text (for example, TriMet's \"503-238-RIDE\") is permitted, but the field must not contain any other descriptive text. agency_fare_url URL Optional URL of a web page that allows a rider to purchase tickets or other fare instruments for that agency online. agency_email Email Optional Email address actively monitored by the agency\u2019s customer service department. This email address should be a direct contact point where transit riders can reach a customer service representative at the agency.","title":"agency.txt"},{"location":"schedule/reference/#stopstxt","text":"File: Required Primary key ( stop_id ) Field Name Type Presence Description stop_id Unique ID Required Identifies a location: stop/platform, station, entrance/exit, generic node or boarding area (see location_type ). Multiple routes may use the same stop_id . stop_code Text Optional Short text or a number that identifies the location for riders. These codes are often used in phone-based transit information systems or printed on signage to make it easier for riders to get information for a particular location. The stop_code may be the same as stop_id if it is public facing. This field should be left empty for locations without a code presented to riders. stop_name Text Conditionally Required Name of the location. The stop_name should match the agency's rider-facing name for the location as printed on a timetable, published online, or represented on signage. For translations into other languages, use translations.txt . When the location is a boarding area ( location_type=4 ), the stop_name should contains the name of the boarding area as displayed by the agency. It could be just one letter (like on some European intercity railway stations), or text like \u201cWheelchair boarding area\u201d (NYC\u2019s Subway) or \u201cHead of short trains\u201d (Paris\u2019 RER). Conditionally Required: - Required for locations which are stops ( location_type=0 ), stations ( location_type=1 ) or entrances/exits ( location_type=2 ). - Optional for locations which are generic nodes ( location_type=3 ) or boarding areas ( location_type=4 ). tts_stop_name Text Optional Readable version of the stop_name . See \"Text-to-speech field\" in the Term Definitions for more. stop_desc Text Optional Description of the location that provides useful, quality information. Should not be a duplicate of stop_name . stop_lat Latitude Conditionally Required Latitude of the location. For stops/platforms ( location_type=0 ) and boarding area ( location_type=4 ), the coordinates must be the ones of the bus pole \u2014 if exists \u2014 and otherwise of where the travelers are boarding the vehicle (on the sidewalk or the platform, and not on the roadway or the track where the vehicle stops). Conditionally Required: - Required for locations which are stops ( location_type=0 ), stations ( location_type=1 ) or entrances/exits ( location_type=2 ). - Optional for locations which are generic nodes ( location_type=3 ) or boarding areas ( location_type=4 ). stop_lon Longitude Conditionally Required Longitude of the location. For stops/platforms ( location_type=0 ) and boarding area ( location_type=4 ), the coordinates must be the ones of the bus pole \u2014 if exists \u2014 and otherwise of where the travelers are boarding the vehicle (on the sidewalk or the platform, and not on the roadway or the track where the vehicle stops). Conditionally Required: - Required for locations which are stops ( location_type=0 ), stations ( location_type=1 ) or entrances/exits ( location_type=2 ). - Optional for locations which are generic nodes ( location_type=3 ) or boarding areas ( location_type=4 ). zone_id ID Conditionally Required Identifies the fare zone for a stop. If this record represents a station or station entrance, the zone_id is ignored. Conditionally Required: - Required if providing fare information using fare_rules.txt - Optional otherwise. stop_url URL Optional URL of a web page about the location. This should be different from the agency.agency_url and the routes.route_url field values. location_type Enum Optional Location type. Valid options are: 0 (or blank) - Stop (or Platform ). A location where passengers board or disembark from a transit vehicle. Is called a platform when defined within a parent_station . 1 - Station . A physical structure or area that contains one or more platform. 2 - Entrance/Exit . A location where passengers can enter or exit a station from the street. If an entrance/exit belongs to multiple stations, it may be linked by pathways to both, but the data provider must pick one of them as parent. 3 - Generic Node . A location within a station, not matching any other location_type , that may be used to link together pathways define in pathways.txt. 4 - Boarding Area . A specific location on a platform, where passengers can board and/or alight vehicles. parent_station Foreign ID referencing stops.stop_id Conditionally Required Defines hierarchy between the different locations defined in stops.txt . It contains the ID of the parent location, as followed: - Stop/platform ( location_type=0 ): the parent_station field contains the ID of a station. - Station ( location_type=1 ): this field must be empty. - Entrance/exit ( location_type=2 ) or generic node ( location_type=3 ): the parent_station field contains the ID of a station ( location_type=1 ) - Boarding Area ( location_type=4 ): the parent_station field contains ID of a platform. Conditionally Required: - Required for locations which are entrances ( location_type=2 ), generic nodes ( location_type=3 ) or boarding areas ( location_type=4 ). - Optional for stops/platforms ( location_type=0 ). - Forbidden for stations ( location_type=1 ). stop_timezone Timezone Optional Timezone of the location. If the location has a parent station, it inherits the parent station\u2019s timezone instead of applying its own. Stations and parentless stops with empty stop_timezone inherit the timezone specified by agency.agency_timezone . If stop_timezone values are provided, the times in stop_times.txt should be entered as the time since midnight in the timezone specified by agency.agency_timezone . This ensures that the time values in a trip always increase over the course of a trip, regardless of which timezones the trip crosses. wheelchair_boarding Enum Optional Indicates whether wheelchair boardings are possible from the location. Valid options are: For parentless stops: 0 or empty - No accessibility information for the stop. 1 - Some vehicles at this stop can be boarded by a rider in a wheelchair. 2 - Wheelchair boarding is not possible at this stop. For child stops: 0 or empty - Stop will inherit its wheelchair_boarding behavior from the parent station, if specified in the parent. 1 - There exists some accessible path from outside the station to the specific stop/platform. 2 - There exists no accessible path from outside the station to the specific stop/platform. For station entrances/exits: 0 or empty - Station entrance will inherit its wheelchair_boarding behavior from the parent station, if specified for the parent. 1 - Station entrance is wheelchair accessible. 2 - No accessible path from station entrance to stops/platforms. level_id Foreign ID referencing levels.level_id Optional Level of the location. The same level may be used by multiple unlinked stations. platform_code Text Optional Platform identifier for a platform stop (a stop belonging to a station). This should be just the platform identifier (eg. \"G\" or \"3\"). Words like \u201cplatform\u201d or \"track\" (or the feed\u2019s language-specific equivalent) should not be included. This allows feed consumers to more easily internationalize and localize the platform identifier into other languages.","title":"stops.txt"},{"location":"schedule/reference/#routestxt","text":"File: Required Primary key ( route_id ) Field Name Type Presence Description route_id Unique ID Required Identifies a route. agency_id Foreign ID referencing agency.agency_id Conditionally Required Agency for the specified route. Conditionally Required: - Required if multiple agencies are defined in agency.txt . - Optional otherwise. route_short_name Text Conditionally Required Short name of a route. Often a short, abstract identifier (e.g., \"32\", \"100X\", \"Green\") that riders use to identify a route. Both route_short_name and route_long_name may be defined. Conditionally Required: - Required if routes.route_long_name is empty. - Optional otherwise. route_long_name Text Conditionally Required Full name of a route. This name is generally more descriptive than the route_short_name and often includes the route's destination or stop. Both route_short_name and route_long_name may be defined. Conditionally Required: - Required if routes.route_short_name is empty. - Optional otherwise. route_desc Text Optional Description of a route that provides useful, quality information. Should not be a duplicate of route_short_name or route_long_name . Example: \"A\" trains operate between Inwood-207 St, Manhattan and Far Rockaway-Mott Avenue, Queens at all times. Also from about 6AM until about midnight, additional \"A\" trains operate between Inwood-207 St and Lefferts Boulevard (trains typically alternate between Lefferts Blvd and Far Rockaway). route_type Enum Required Indicates the type of transportation used on a route. Valid options are: 0 - Tram, Streetcar, Light rail. Any light rail or street level system within a metropolitan area. 1 - Subway, Metro. Any underground rail system within a metropolitan area. 2 - Rail. Used for intercity or long-distance travel. 3 - Bus. Used for short- and long-distance bus routes. 4 - Ferry. Used for short- and long-distance boat service. 5 - Cable tram. Used for street-level rail cars where the cable runs beneath the vehicle (e.g., cable car in San Francisco). 6 - Aerial lift, suspended cable car (e.g., gondola lift, aerial tramway). Cable transport where cabins, cars, gondolas or open chairs are suspended by means of one or more cables. 7 - Funicular. Any rail system designed for steep inclines. 11 - Trolleybus. Electric buses that draw power from overhead wires using poles. 12 - Monorail. Railway in which the track consists of a single rail or a beam. route_url URL Optional URL of a web page about the particular route. Should be different from the agency.agency_url value. route_color Color Optional Route color designation that matches public facing material. Defaults to white ( FFFFFF ) when omitted or left empty. The color difference between route_color and route_text_color should provide sufficient contrast when viewed on a black and white screen. route_text_color Color Optional Legible color to use for text drawn against a background of route_color . Defaults to black ( 000000 ) when omitted or left empty. The color difference between route_color and route_text_color should provide sufficient contrast when viewed on a black and white screen. route_sort_order Non-negative integer Optional Orders the routes in a way which is ideal for presentation to customers. Routes with smaller route_sort_order values should be displayed first. continuous_pickup Enum Optional Indicates that the rider can board the transit vehicle at any point along the vehicle\u2019s travel path as described by shapes.txt , on every trip of the route. Valid options are: 0 - Continuous stopping pickup. 1 or empty - No continuous stopping pickup. 2 - Must phone agency to arrange continuous stopping pickup. 3 - Must coordinate with driver to arrange continuous stopping pickup. Values for routes.continuous_pickup may be overridden by defining values in stop_times.continuous_pickup for specific stop_time s along the route. continuous_drop_off Enum Optional Indicates that the rider can alight from the transit vehicle at any point along the vehicle\u2019s travel path as described by shapes.txt , on every trip of the route. Valid options are: 0 - Continuous stopping drop off. 1 or empty - No continuous stopping drop off. 2 - Must phone agency to arrange continuous stopping drop off. 3 - Must coordinate with driver to arrange continuous stopping drop off. Values for routes.continuous_drop_off may be overridden by defining values in stop_times.continuous_drop_off for specific stop_time s along the route.","title":"routes.txt"},{"location":"schedule/reference/#tripstxt","text":"File: Required Primary key ( trip_id ) Field Name Type Presence Description route_id Foreign ID referencing routes.route_id Required Identifies a route. service_id Foreign ID referencing calendar.service_id or calendar_dates.service_id Required Identifies a set of dates when service is available for one or more routes. trip_id Unique ID Required Identifies a trip. trip_headsign Text Optional Text that appears on signage identifying the trip's destination to riders. Should be used to distinguish between different patterns of service on the same route. If the headsign changes during a trip, values for trip_headsign may be overridden by defining values in stop_times.stop_headsign for specific stop_time s along the trip. trip_short_name Text Optional Public facing text used to identify the trip to riders, for instance, to identify train numbers for commuter rail trips. If riders do not commonly rely on trip names, trip_short_name should be empty. A trip_short_name value, if provided, should uniquely identify a trip within a service day; it should not be used for destination names or limited/express designations. direction_id Enum Optional Indicates the direction of travel for a trip. This field should not be used in routing; it provides a way to separate trips by direction when publishing time tables. Valid options are: 0 - Travel in one direction (e.g. outbound travel). 1 - Travel in the opposite direction (e.g. inbound travel). Example: The trip_headsign and direction_id fields may be used together to assign a name to travel in each direction for a set of trips. A trips.txt file could contain these records for use in time tables: trip_id,...,trip_headsign,direction_id 1234,...,Airport,0 1505,...,Downtown,1 block_id ID Optional Identifies the block to which the trip belongs. A block consists of a single trip or many sequential trips made using the same vehicle, defined by shared service days and block_id . A block_id may have trips with different service days, making distinct blocks. See the example below shape_id Foreign ID referencing shapes.shape_id Conditionally Required Identifies a geospatial shape describing the vehicle travel path for a trip. Conditionally Required: - Required if the trip has a continuous pickup or drop-off behavior defined either in routes.txt or in stop_times.txt . - Optional otherwise. wheelchair_accessible Enum Optional Indicates wheelchair accessibility. Valid options are: 0 or empty - No accessibility information for the trip. 1 - Vehicle being used on this particular trip can accommodate at least one rider in a wheelchair. 2 - No riders in wheelchairs can be accommodated on this trip. bikes_allowed Enum Optional Indicates whether bikes are allowed. Valid options are: 0 or empty - No bike information for the trip. 1 - Vehicle being used on this particular trip can accommodate at least one bicycle. 2 - No bicycles are allowed on this trip.","title":"trips.txt"},{"location":"schedule/reference/#example-blocks-and-service-day","text":"The example below is valid, with distinct blocks every day of the week. route_id trip_id service_id block_id (first stop time) (last stop time) red trip_1 mon-tues-wed-thurs-fri-sat-sun red_loop 22:00:00 22:55:00 red trip_2 fri-sat-sun red_loop 23:00:00 23:55:00 red trip_3 fri-sat red_loop 24:00:00 24:55:00 red trip_4 mon-tues-wed-thurs red_loop 20:00:00 20:50:00 red trip_5 mon-tues-wed-thurs red_loop 21:00:00 21:50:00 Notes on above table: On Friday into Saturday morning, for example, a single vehicle operates trip_1 , trip_2 , and trip_3 (10:00 PM through 12:55 AM). Note that the last trip occurs on Saturday, 12:00 AM to 12:55 AM, but is part of the Friday \u201cservice day\u201d because the times are 24:00:00 to 24:55:00. On Monday, Tuesday, Wednesday, and Thursday, a single vehicle operates trip_1 , trip_4 , and trip_5 in a block from 8:00 PM to 10:55 PM.","title":"Example: Blocks and service day"},{"location":"schedule/reference/#stop_timestxt","text":"File: Required Primary key ( trip_id , stop_sequence ) Field Name Type Presence Description trip_id Foreign ID referencing trips.trip_id Required Identifies a trip. arrival_time Time Conditionally Required Arrival time at the stop (defined by stop_times.stop_id ) for a specific trip (defined by stop_times.trip_id ). If there are not separate times for arrival and departure at a stop, arrival_time and departure_time should be the same. For times occurring after midnight on the service day, enter the time as a value greater than 24:00:00 in HH:MM:SS local time for the day on which the trip schedule begins. If exact arrival and departure times ( timepoint=1 or empty) are not available, estimated or interpolated arrival and departure times ( timepoint=0 ) should be provided. Conditionally Required: - Required for the first and last stop in a trip (defined by stop_times.stop_sequence ). - Required for timepoint=1 . - Optional otherwise. departure_time Time Conditionally Required Departure time from the stop (defined by stop_times.stop_id ) for a specific trip (defined by stop_times.trip_id ). If there are not separate times for arrival and departure at a stop, arrival_time and departure_time should be the same. For times occurring after midnight on the service day, enter the time as a value greater than 24:00:00 in HH:MM:SS local time for the day on which the trip schedule begins. If exact arrival and departure times ( timepoint=1 or empty) are not available, estimated or interpolated arrival and departure times ( timepoint=0 ) should be provided. Conditionally Required: - Required for timepoint=1 . - Optional otherwise. stop_id Foreign ID referencing stops.stop_id Required Identifies the serviced stop. All stops serviced during a trip must have a record in stop_times.txt . Referenced locations must be stops/platforms, i.e. their stops.location_type value must be 0 or empty. A stop may be serviced multiple times in the same trip, and multiple trips and routes may service the same stop. stop_sequence Non-negative integer Required Order of stops for a particular trip. The values must increase along the trip but do not need to be consecutive. Example: The first location on the trip could have a stop_sequence = 1 , the second location on the trip could have a stop_sequence = 23 , the third location could have a stop_sequence = 40 , and so on. stop_headsign Text Optional Text that appears on signage identifying the trip's destination to riders. This field overrides the default trips.trip_headsign when the headsign changes between stops. If the headsign is displayed for an entire trip, trips.trip_headsign should be used instead. A stop_headsign value specified for one stop_time does not apply to subsequent stop_time s in the same trip. If you want to override the trip_headsign for multiple stop_time s in the same trip, the stop_headsign value must be repeated in each stop_time row. pickup_type Enum Optional Indicates pickup method. Valid options are: 0 or empty - Regularly scheduled pickup. 1 - No pickup available. 2 - Must phone agency to arrange pickup. 3 - Must coordinate with driver to arrange pickup. drop_off_type Enum Optional Indicates drop off method. Valid options are: 0 or empty - Regularly scheduled drop off. 1 - No drop off available. 2 - Must phone agency to arrange drop off. 3 - Must coordinate with driver to arrange drop off. continuous_pickup Enum Optional Indicates that the rider can board the transit vehicle at any point along the vehicle\u2019s travel path as described by shapes.txt , from this stop_time to the next stop_time in the trip\u2019s stop_sequence . Valid options are: 0 - Continuous stopping pickup. 1 or empty - No continuous stopping pickup. 2 - Must phone agency to arrange continuous stopping pickup. 3 - Must coordinate with driver to arrange continuous stopping pickup. If this field is populated, it overrides any continuous pickup behavior defined in routes.txt . If this field is empty, the stop_time inherits any continuous pickup behavior defined in routes.txt . continuous_drop_off Enum Optional Indicates that the rider can alight from the transit vehicle at any point along the vehicle\u2019s travel path as described by shapes.txt , from this stop_time to the next stop_time in the trip\u2019s stop_sequence . Valid options are: 0 - Continuous stopping drop off. 1 or empty - No continuous stopping drop off. 2 - Must phone agency to arrange continuous stopping drop off. 3 - Must coordinate with driver to arrange continuous stopping drop off. If this field is populated, it overrides any continuous drop-off behavior defined in routes.txt . If this field is empty, the stop_time inherits any continuous drop-off behavior defined in routes.txt . shape_dist_traveled Non-negative float Optional Actual distance traveled along the associated shape, from the first stop to the stop specified in this record. This field specifies how much of the shape to draw between any two stops during a trip. Must be in the same units used in shapes.txt . Values used for shape_dist_traveled must increase along with stop_sequence ; they must not be used to show reverse travel along a route. Example: If a bus travels a distance of 5.25 kilometers from the start of the shape to the stop, shape_dist_traveled = 5.25 . timepoint Enum Optional Indicates if arrival and departure times for a stop are strictly adhered to by the vehicle or if they are instead approximate and/or interpolated times. This field allows a GTFS producer to provide interpolated stop-times, while indicating that the times are approximate. Valid options are: 0 - Times are considered approximate. 1 or empty - Times are considered exact.","title":"stop_times.txt"},{"location":"schedule/reference/#calendartxt","text":"File: Conditionally Required Primary key ( service_id ) Field Name Type Presence Description service_id Unique ID Required Identifies a set of dates when service is available for one or more routes. Each service_id value must be unique in a calendar.txt file. monday Enum Required Indicates whether the service operates on all Mondays in the date range specified by the start_date and end_date fields. Note that exceptions for particular dates may be listed in calendar_dates.txt . Valid options are: 1 - Service is available for all Mondays in the date range. 0 - Service is not available for Mondays in the date range. tuesday Enum Required Functions in the same way as monday except applies to Tuesdays wednesday Enum Required Functions in the same way as monday except applies to Wednesdays thursday Enum Required Functions in the same way as monday except applies to Thursdays friday Enum Required Functions in the same way as monday except applies to Fridays saturday Enum Required Functions in the same way as monday except applies to Saturdays. sunday Enum Required Functions in the same way as monday except applies to Sundays. start_date Date Required Start service day for the service interval. end_date Date Required End service day for the service interval. This service day is included in the interval.","title":"calendar.txt"},{"location":"schedule/reference/#calendar_datestxt","text":"File: Conditionally Required Primary key ( service_id , date ) The calendar_dates.txt table explicitly activates or disables service by date. It may be used in two ways. Recommended: Use calendar_dates.txt in conjunction with calendar.txt to define exceptions to the default service patterns defined in calendar.txt . If service is generally regular, with a few changes on explicit dates (for instance, to accommodate special event services, or a school schedule), this is a good approach. In this case calendar_dates.service_id is a foreign ID referencing calendar.service_id . Alternate: Omit calendar.txt , and specify each date of service in calendar_dates.txt . This allows for considerable service variation and accommodates service without normal weekly schedules. In this case service_id is an ID. Field Name Type Presence Description service_id Foreign ID referencing calendar.service_id or ID Required Identifies a set of dates when a service exception occurs for one or more routes. Each ( service_id , date ) pair may only appear once in calendar_dates.txt if using calendar.txt and calendar_dates.txt in conjunction. If a service_id value appears in both calendar.txt and calendar_dates.txt , the information in calendar_dates.txt modifies the service information specified in calendar.txt . date Date Required Date when service exception occurs. exception_type Enum Required Indicates whether service is available on the date specified in the date field. Valid options are: 1 - Service has been added for the specified date. 2 - Service has been removed for the specified date. Example: Suppose a route has one set of trips available on holidays and another set of trips available on all other days. One service_id could correspond to the regular service schedule and another service_id could correspond to the holiday schedule. For a particular holiday, the calendar_dates.txt file could be used to add the holiday to the holiday service_id and to remove the holiday from the regular service_id schedule.","title":"calendar_dates.txt"},{"location":"schedule/reference/#fare_attributestxt","text":"File: Optional Primary key ( fare_id ) Field Name Type Presence Description fare_id Unique ID Required Identifies a fare class. price Non-negative float Required Fare price, in the unit specified by currency_type . currency_type Currency code Required Currency used to pay the fare. payment_method Enum Required Indicates when the fare must be paid. Valid options are: 0 - Fare is paid on board. 1 - Fare must be paid before boarding. transfers Enum Required Indicates the number of transfers permitted on this fare. Valid options are: 0 - No transfers permitted on this fare. 1 - Riders may transfer once. 2 - Riders may transfer twice. empty - Unlimited transfers are permitted. agency_id Foreign ID referencing agency.agency_id Conditionally Required Identifies the relevant agency for a fare. Conditionally Required: - Required if multiple agencies are defined in agency.txt . - Optional otherwise. transfer_duration Non-negative integer Optional Length of time in seconds before a transfer expires. When transfers = 0 this field may be used to indicate how long a ticket is valid for or it may be left empty.","title":"fare_attributes.txt"},{"location":"schedule/reference/#fare_rulestxt","text":"File: Optional Primary key ( * ) The fare_rules.txt table specifies how fares in fare_attributes.txt apply to an itinerary. Most fare structures use some combination of the following rules: Fare depends on origin or destination stations. Fare depends on which zones the itinerary passes through. Fare depends on which route the itinerary uses. For examples that demonstrate how to specify a fare structure with fare_rules.txt and fare_attributes.txt , see https://code.google.com/p/googletransitdatafeed/wiki/FareExamples in the GoogleTransitDataFeed open source project wiki. Field Name Type Presence Description fare_id Foreign ID referencing fare_attributes.fare_id Required Identifies a fare class. route_id Foreign ID referencing routes.route_id Optional Identifies a route associated with the fare class. If several routes with the same fare attributes exist, create a record in fare_rules.txt for each route. Example: If fare class \"b\" is valid on route \"TSW\" and \"TSE\", the fare_rules.txt file would contain these records for the fare class: fare_id,route_id b,TSW b,TSE origin_id Foreign ID referencing stops.zone_id Optional Identifies an origin zone. If a fare class has multiple origin zones, create a record in fare_rules.txt for each origin_id . Example: If fare class \"b\" is valid for all travel originating from either zone \"2\" or zone \"8\", the fare_rules.txt file would contain these records for the fare class: fare_id,...,origin_id b,...,2 b,...,8 destination_id Foreign ID referencing stops.zone_id Optional Identifies a destination zone. If a fare class has multiple destination zones, create a record in fare_rules.txt for each destination_id . Example: The origin_id and destination_id fields could be used together to specify that fare class \"b\" is valid for travel between zones 3 and 4, and for travel between zones 3 and 5, the fare_rules.txt file would contain these records for the fare class: fare_id,...,origin_id,destination_id b,...,3,4 b,...,3,5 contains_id Foreign ID referencing stops.zone_id Optional Identifies the zones that a rider will enter while using a given fare class. Used in some systems to calculate correct fare class. Example: If fare class \"c\" is associated with all travel on the GRT route that passes through zones 5, 6, and 7 the fare_rules.txt would contain these records: fare_id,route_id,...,contains_id c,GRT,...,5 c,GRT,...,6 c,GRT,...,7 Because all contains_id zones must be matched for the fare to apply, an itinerary that passes through zones 5 and 6 but not zone 7 would not have fare class \"c\". For more detail, see https://code.google.com/p/googletransitdatafeed/wiki/FareExamples in the GoogleTransitDataFeed project wiki.","title":"fare_rules.txt"},{"location":"schedule/reference/#shapestxt","text":"File: Optional Primary key ( shape_id , shape_pt_sequence ) Shapes describe the path that a vehicle travels along a route alignment, and are defined in the file shapes.txt. Shapes are associated with Trips, and consist of a sequence of points through which the vehicle passes in order. Shapes do not need to intercept the location of Stops exactly, but all Stops on a trip should lie within a small distance of the shape for that trip, i.e. close to straight line segments connecting the shape points. Field Name Type Presence Description shape_id ID Required Identifies a shape. shape_pt_lat Latitude Required Latitude of a shape point. Each record in shapes.txt represents a shape point used to define the shape. shape_pt_lon Longitude Required Longitude of a shape point. shape_pt_sequence Non-negative integer Required Sequence in which the shape points connect to form the shape. Values must increase along the trip but do not need to be consecutive. Example: If the shape \"A_shp\" has three points in its definition, the shapes.txt file might contain these records to define the shape: shape_id,shape_pt_lat,shape_pt_lon,shape_pt_sequence A_shp,37.61956,-122.48161,0 A_shp,37.64430,-122.41070,6 A_shp,37.65863,-122.30839,11 shape_dist_traveled Non-negative float Optional Actual distance traveled along the shape from the first shape point to the point specified in this record. Used by trip planners to show the correct portion of the shape on a map. Values must increase along with shape_pt_sequence ; they must not be used to show reverse travel along a route. Distance units must be consistent with those used in stop_times.txt . Example: If a bus travels along the three points defined above for A_shp, the additional shape_dist_traveled values (shown here in kilometers) would look like this: shape_id,shape_pt_lat,shape_pt_lon,shape_pt_sequence,shape_dist_traveled A_shp,37.61956,-122.48161,0,0 A_shp,37.64430,-122.41070,6,6.8310 A_shp,37.65863,-122.30839,11,15.8765","title":"shapes.txt"},{"location":"schedule/reference/#frequenciestxt","text":"File: Optional Primary key ( trip_id , start_time ) Frequencies.txt represents trips that operate on regular headways (time between trips). This file may be used to represent two different types of service. Frequency-based service ( exact_times = 0 ) in which service does not follow a fixed schedule throughout the day. Instead, operators attempt to strictly maintain predetermined headways for trips. A compressed representation of schedule-based service ( exact_times = 1 ) that has the exact same headway for trips over specified time period(s). In schedule-based service operators try to strictly adhere to a schedule. Field Name Type Presence Description trip_id Foreign ID referencing trips.trip_id Required Identifies a trip to which the specified headway of service applies. start_time Time Required Time at which the first vehicle departs from the first stop of the trip with the specified headway. end_time Time Required Time at which service changes to a different headway (or ceases) at the first stop in the trip. headway_secs Positive integer Required Time, in seconds, between departures from the same stop (headway) for the trip, during the time interval specified by start_time and end_time . Multiple headways may be defined for the same trip, but must not overlap. New headways may start at the exact time the previous headway ends. exact_times Enum Optional Indicates the type of service for a trip. See the file description for more information. Valid options are: 0 or empty - Frequency-based trips. 1 - Schedule-based trips with the exact same headway throughout the day. In this case the end_time value must be greater than the last desired trip start_time but less than the last desired trip start_time + headway_secs .","title":"frequencies.txt"},{"location":"schedule/reference/#transferstxt","text":"File: Optional Primary key ( from_stop_id , to_stop_id , from_trip_id , to_trip_id , from_route_id , to_route_id ) When calculating an itinerary, GTFS-consuming applications interpolate transfers based on allowable time and stop proximity. Transfers.txt specifies additional rules and overrides for selected transfers. Fields from_trip_id , to_trip_id , from_route_id and to_route_id allow higher orders of specificity for transfer rules. Along with from_stop_id and to_stop_id , the ranking of specificity is as follows: Both trip_id s defined: from_trip_id and to_trip_id . One trip_id and route_id set defined: ( from_trip_id and to_route_id ) or ( from_route_id and to_trip_id ). One trip_id defined: from_trip_id or to_trip_id . Both route_id s defined: from_route_id and to_route_id . One route_id defined: from_route_id or to_route_id . Only from_stop_id and to_stop_id defined: no route or trip related fields set. For a given ordered pair of arriving trip and departing trip, the transfer with the greatest specificity that applies between these two trips is chosen. For any pair of trips, there should not be two transfers with equally maximal specificity that could apply. Field Name Type Presence Description from_stop_id Foreign ID referencing stops.stop_id Required Identifies a stop or station where a connection between routes begins. If this field refers to a station, the transfer rule applies to all its child stops. to_stop_id Foreign ID referencing stops.stop_id Required Identifies a stop or station where a connection between routes ends. If this field refers to a station, the transfer rule applies to all child stops. from_route_id Foreign ID referencing routes.route_id Optional Identifies a route where a connection begins. If from_route_id is defined, the transfer will apply to the arriving trip on the route for the given from_stop_id . If both from_trip_id and from_route_id are defined, the trip_id must belong to the route_id , and from_trip_id will take precedence. to_route_id Foreign ID referencing routes.route_id Optional Identifies a route where a connection ends. If to_route_id is defined, the transfer will apply to the departing trip on the route for the given to_stop_id . If both to_trip_id and to_route_id are defined, the trip_id must belong to the route_id , and to_trip_id will take precedence. from_trip_id Foreign ID referencing trips.trip_id Optional Identifies a trip where a connection between routes begins. If from_trip_id is defined, the transfer will apply to the arriving trip for the given from_stop_id . If both from_trip_id and from_route_id are defined, the trip_id must belong to the route_id , and from_trip_id will take precedence. to_trip_id Foreign ID referencing trips.trip_id Optional Identifies a trip where a connection between routes ends. If to_trip_id is defined, the transfer will apply to the departing trip for the given to_stop_id . If both to_trip_id and to_route_id are defined, the trip_id must belong to the route_id , and to_trip_id will take precedence. transfer_type Enum Required Indicates the type of connection for the specified ( from_stop_id , to_stop_id ) pair. Valid options are: 0 or empty - Recommended transfer point between routes. 1 - Timed transfer point between two routes. The departing vehicle is expected to wait for the arriving one and leave sufficient time for a rider to transfer between routes. 2 - Transfer requires a minimum amount of time between arrival and departure to ensure a connection. The time required to transfer is specified by min_transfer_time . 3 - Transfers are not possible between routes at the location. min_transfer_time Non-negative integer Optional Amount of time, in seconds, that must be available to permit a transfer between routes at the specified stops. The min_transfer_time should be sufficient to permit a typical rider to move between the two stops, including buffer time to allow for schedule variance on each route.","title":"transfers.txt"},{"location":"schedule/reference/#pathwaystxt","text":"File: Optional Primary key ( pathway_id ) Files pathways.txt and levels.txt use a graph representation to describe subway or train stations, with nodes representing locations and edges representing pathways. To navigate from the station entrance/exit (a node represented as a location with location_type=2 ) to a platform (a node represented as a location with location_type=0 or empty), the rider will move through walkways, fare gates, stairs, and other edges represented as pathways. Generic nodes (nodes represented with location_type=3 ) can be used to connect pathways throughout a station. Pathways must be defined exhaustively in a station. If any pathways are defined, it is assumed that all pathways throughout the station are represented. Therefore, the following guidelines apply: No dangling locations: If any location within a station has a pathway, then all locations within that station should have pathways, except for platforms that have boarding areas ( location_type=4 , see guideline below). No pathways for a platform with boarding areas: A platform ( location_type=0 or empty) that has boarding areas ( location_type=4 ) is treated as a parent object, not a point. In such cases, the platform must not have pathways assigned. All pathways should be assigned for each of the platform's boarding areas. No locked platforms: Each platform ( location_type=0 or empty) or boarding area ( location_type=4 ) must be connected to at least one entrance/exit ( location_type=2 ) via some chain of pathways. Stations not allowing a pathway to the outside of the station from a given platform are rare. Field Name Type Presence Description pathway_id Unique ID Required Identifies a pathway. Used by systems as an internal identifier for the record. Must be unique in the dataset. Different pathways may have the same values for from_stop_id and to_stop_id . Example: When two escalators are side-by-side in opposite directions, or when a stair set and elevator go from the same place to the same place, different pathway_id may have the same from_stop_id and to_stop_id values. from_stop_id Foreign ID referencing stops.stop_id Required Location at which the pathway begins. Must contain a stop_id that identifies a platform ( location_type=0 or empty), entrance/exit ( location_type=2 ), generic node ( location_type=3 ) or boarding area ( location_type=4 ). Values for stop_id that identify stations ( location_type=1 ) are forbidden. to_stop_id Foreign ID referencing stops.stop_id Required Location at which the pathway ends. Must contain a stop_id that identifies a platform ( location_type=0 or empty), entrance/exit ( location_type=2 ), generic node ( location_type=3 ) or boarding area ( location_type=4 ). Values for stop_id that identify stations ( location_type=1 ) are forbidden. pathway_mode Enum Required Type of pathway between the specified ( from_stop_id , to_stop_id ) pair. Valid options are: 1 - Walkway. 2 - Stairs. 3 - Moving sidewalk/travelator. 4 - Escalator. 5 - Elevator. 6 - Fare gate (or payment gate): A pathway that crosses into an area of the station where proof of payment is required to cross. Fare gates may separate paid areas of the station from unpaid ones, or separate different payment areas within the same station from each other. This information can be used to avoid routing passengers through stations using shortcuts that would require passengers to make unnecessary payments, like directing a passenger to walk through a subway platform to reach a busway. 7 - Exit gate: A pathway exiting a paid area into an unpaid area where proof of payment is not required to cross. is_bidirectional Enum Required Indicates the direction that the pathway can be taken: 0 - Unidirectional pathway that can only be used from from_stop_id to to_stop_id . 1 - Bidirectional pathway that can be used in both directions. Exit gates ( pathway_mode=7 ) must not be bidirectional. length Non-negative float Optional Horizontal length in meters of the pathway from the origin location (defined in from_stop_id ) to the destination location (defined in to_stop_id ). This field is recommended for walkways ( pathway_mode=1 ), fare gates ( pathway_mode=6 ) and exit gates ( pathway_mode=7 ). traversal_time Positive integer Optional Average time in seconds needed to walk through the pathway from the origin location (defined in from_stop_id ) to the destination location (defined in to_stop_id ). This field is recommended for moving sidewalks ( pathway_mode=3 ), escalators ( pathway_mode=4 ) and elevator ( pathway_mode=5 ). stair_count Non-null integer Optional Number of stairs of the pathway. A positive stair_count implies that the rider walk up from from_stop_id to to_stop_id . And a negative stair_count implies that the rider walk down from from_stop_id to to_stop_id . This field is recommended for stairs ( pathway_mode=2 ). If only an estimated stair count can be provided, it is recommended to approximate 15 stairs for 1 floor. max_slope Float Optional Maximum slope ratio of the pathway. Valid options are: 0 or empty - No slope. Float - Slope ratio of the pathway, positive for upwards, negative for downwards. This field should only be used with walkways ( pathway_mode=1 ) and moving sidewalks ( pathway_mode=3 ). Example: In the US, 0.083 (also written 8.3%) is the maximum slope ratio for hand-propelled wheelchair, which mean an increase of 0.083m (so 8.3cm) for each 1m. min_width Positive float Optional Minimum width of the pathway in meters. This field is recommended if the minimum width is less than 1 meter. signposted_as Text Optional Public facing text from physical signage that is visible to riders. May be used to provide text directions to riders, such as 'follow signs to '. The text in singposted_as should appear exactly how it is printed on the signs. When the physical signage is multilingual, this field may be populated and translated following the example of stops.stop_name in the field definition of feed_info.feed_lang . reversed_signposted_as Text Optional Same as signposted_as , but when the pathway is used from the to_stop_id to the from_stop_id .","title":"pathways.txt"},{"location":"schedule/reference/#levelstxt","text":"File: Conditionally Required Primary key ( level_id ) Describes levels in a station. Useful in conjunction with pathways.txt , and is required for navigating pathways with elevators ( pathway_mode=5 ). Field Name Type Presence Description level_id Unique ID Required Identifies a level in a station. level_index Float Required Numeric index of the level that indicates its relative position. Ground level should have index 0 , with levels above ground indicated by positive indices and levels below ground by negative indices. level_name Text Optional Name of the level as seen by the rider inside the building or station. Example: Take the elevator to \"Mezzanine\" or \"Platform\" or \"-1\".","title":"levels.txt"},{"location":"schedule/reference/#translationstxt","text":"File: Optional Primary key ( * ) In regions that have multiple official languages, transit agencies/operators typically have language-specific names and web pages. In order to best serve riders in those regions, it is useful for the dataset to include these language-dependent values. Field Name Type Presence Description table_name Enum Required Defines the table that contains the field to be translated. Allowed values are: - agency - stops - routes - trips - stop_times - pathways - levels - feed_info - attributions Any file added to GTFS will have a table_name value equivalent to the file name, as listed above (i.e., not including the .txt file extension). field_name Text Required Name of the field to be translated. Fields with type Text may be translated, fields with type URL , Email and Phone number may also be \u201ctranslated\u201d to provide resources in the correct language. Fields with other types should not be translated. language Language code Required Language of translation. If the language is the same as in feed_info.feed_lang , the original value of the field will be assumed to be the default value to use in languages without specific translations (if default_lang doesn't specify otherwise). Example: In Switzerland, a city in an officially bilingual canton is officially called \u201cBiel/Bienne\u201d, but would simply be called \u201cBienne\u201d in French and \u201cBiel\u201d in German. translation Text or URL or Email or Phone number Required Translated value. record_id Foreign ID Conditionally Required Defines the record that corresponds to the field to be translated. The value in record_id must be the first or only field of a table's primary key, as defined in the primary key attribute for each table and below: - agency_id for agency.txt - stop_id for stops.txt ; - route_id for routes.txt ; - trip_id for trips.txt ; - trip_id for stop_times.txt ; - pathway_id for pathways.txt ; - level_id for levels.txt ; - attribution_id for attribution.txt . Fields in tables not defined above should not be translated. However producers sometimes add extra fields that are outside the official specification and these unofficial fields may be translated. Below is the recommended way to use record_id for those tables: - service_id for calendar.txt ; - service_id for calendar_dates.txt ; - fare_id for fare_attributes.txt ; - fare_id for fare_rules.txt ; - shape_id for shapes.txt ; - trip_id for frequencies.txt ; - from_stop_id for transfers.txt . Conditionally Required: - Forbidden if table_name is feed_info . - Forbidden if field_value is defined. - Required if field_value is empty. record_sub_id Foreign ID Conditionally Required Helps the record that contains the field to be translated when the table doesn\u2019t have a unique ID. Therefore, the value in record_sub_id is the secondary ID of the table, as defined by the table below: - None for agency.txt ; - None for stops.txt ; - None for routes.txt ; - None for trips.txt ; - stop_sequence for stop_times.txt ; - None for pathways.txt ; - None for levels.txt ; - None for attributions.txt . Fields in tables not defined above should not be translated. However producers sometimes add extra fields that are outside the official specification and these unofficial fields may be translated. Below is the recommended way to use record_sub_id for those tables: - None for calendar.txt ; - date for calendar_dates.txt ; - None for fare_attributes.txt ; - route_id for fare_rules.txt ; - None for shapes.txt ; - start_time for frequencies.txt ; - to_stop_id for transfers.txt . Conditionally Required: - Forbidden if table_name is feed_info . - Forbidden if field_value is defined. - Required if table_name=stop_times and record_id is defined. field_value Text or URL or Email or Phone number Conditionally Required Instead of defining which record should be translated by using record_id and record_sub_id , this field can be used to define the value which should be translated. When used, the translation will be applied when the fields identified by table_name and field_name contains the exact same value defined in field_value. The field must have exactly the value defined in field_value . If only a subset of the value matches field_value , the translation won\u2019t be applied. If two translation rules match the same record (one with field_value , and the other one with record_id ), the rule with record_id takes precedence. Conditionally Required: - Forbidden if table_name is feed_info . - Forbidden if record_id is defined. - Required if record_id is empty.","title":"translations.txt"},{"location":"schedule/reference/#feed_infotxt","text":"File: Optional ( Required if translations.txt is provided) Primary key (none) The file contains information about the dataset itself, rather than the services that the dataset describes. In some cases, the publisher of the dataset is a different entity than any of the agencies. Field Name Type Presence Description feed_publisher_name Text Required Full name of the organization that publishes the dataset. This may be the same as one of the agency.agency_name values. feed_publisher_url URL Required URL of the dataset publishing organization's website. This may be the same as one of the agency.agency_url values. feed_lang Language code Required Default language used for the text in this dataset. This setting helps GTFS consumers choose capitalization rules and other language-specific settings for the dataset. The file translations.txt can be used if the text needs to be translated into languages other than the default one. The default language may be multilingual for datasets with the original text in multiple languages. In such cases, the feed_lang field should contain the language code mul defined by the norm ISO 639-2, and a translation for each language used in the dataset should be provided in translations.txt . If all the original text in the dataset is in the same language, then mul should not be used. Example: Consider a dataset from a multilingual country like Switzerland, with the original stops.stop_name field populated with stop names in different languages. Each stop name is written according to the dominant language in that stop\u2019s geographic location, e.g. Gen\u00e8ve for the French-speaking city of Geneva, Z\u00fcrich for the German-speaking city of Zurich, and Biel/Bienne for the bilingual city of Biel/Bienne. The dataset feed_lang should be mul and translations would be provided in translations.txt , in German: Genf , Z\u00fcrich and Biel ; in French: Gen\u00e8ve , Zurich and Bienne ; in Italian: Ginevra , Zurigo and Bienna ; and in English: Geneva , Zurich and Biel/Bienne . default_lang Language code Optional Defines the language that should be used when the data consumer doesn\u2019t know the language of the rider. It will often be en (English). feed_start_date Date Optional The dataset provides complete and reliable schedule information for service in the period from the beginning of the feed_start_date day to the end of the feed_end_date day. Both days may be left empty if unavailable. The feed_end_date date must not precede the feed_start_date date if both are given. It is recommended that dataset providers give schedule data outside this period to advise of likely future service, but dataset consumers should treat it mindful of its non-authoritative status. If feed_start_date or feed_end_date extend beyond the active calendar dates defined in calendar.txt and calendar_dates.txt , the dataset is making an explicit assertion that there is no service for dates within the feed_start_date or feed_end_date range but not included in the active calendar dates. feed_end_date Date Optional (see above) feed_version Text Optional String that indicates the current version of their GTFS dataset. GTFS-consuming applications can display this value to help dataset publishers determine whether the latest dataset has been incorporated. feed_contact_email Email Optional Email address for communication regarding the GTFS dataset and data publishing practices. feed_contact_email is a technical contact for GTFS-consuming applications. Provide customer service contact information through agency.txt . feed_contact_url URL Optional URL for contact information, a web-form, support desk, or other tools for communication regarding the GTFS dataset and data publishing practices. feed_contact_url is a technical contact for GTFS-consuming applications. Provide customer service contact information through agency.txt .","title":"feed_info.txt"},{"location":"schedule/reference/#attributionstxt","text":"File: Optional Primary key ( attribution_id ) The file defines the attributions applied to the dataset. Field Name Type Presence Description attribution_id Unique ID Optional Identifies an attribution for the dataset or a subset of it. This is mostly useful for translations. agency_id Foreign ID referencing agency.agency_id Optional Agency to which the attribution applies. If one agency_id , route_id , or trip_id attribution is defined, the other ones must be empty. If none of them is specified, the attribution will apply to the whole dataset. route_id Foreign ID referencing routes.route_id Optional Functions in the same way as agency_id except the attribution applies to a route. Multiple attributions may apply to the same route. trip_id Foreign ID referencing trips.trip_id Optional Functions in the same way as agency_id except the attribution applies to a trip. Multiple attributions may apply to the same trip. organization_name Text Required Name of the organization that the dataset is attributed to. is_producer Enum Optional The role of the organization is producer. Valid options are: 0 or empty - Organization doesn\u2019t have this role. 1 - Organization does have this role. At least one of the fields is_producer , is_operator , or is_authority should be set at 1 . is_operator Enum Optional Functions in the same way as is_producer except the role of the organization is operator. is_authority Enum Optional Functions in the same way as is_producer except the role of the organization is authority. attribution_url URL Optional URL of the organization. attribution_email Email Optional Email of the organization. attribution_phone Phone number Optional Phone number of the organization.","title":"attributions.txt"},{"location":"schedule/revision-history/","text":"Revision History \u00b6 September 15, 2021 Allowed fare gates (pathway_mode=6) to be bidirectional. See discussion . September 13, 2021 Updated stop_name best practices. See discussion . August 27, 2021 Updated GTFS Schedule to RFC 2119 . See discussion . January 4, 2021 Clarified description of stop_times.stop_id . See discussion . Defined positive and non-zero field signs. See discussion . October 2, 2020 Changed field type of frequencies.headway_secs from non-negative to positive integer. See discussion . May 25, 2020 Defined pathways.txt , levels.txt and attributions.txt as translatable tables. Added recommendations for translating multilingual signposted_as values. See discussion . May 13, 2020 Added continuous_pickup and continuous_drop_off to routes.txt and stop_times.txt . Changed shape_id from \"Optional\" to \"Conditionally required\". See discussion . March 24, 2020 Defined text-to-speech field and added tts_stop_name to stops.txt . See discussion . February 5, 2020 Added trolleybus and monorail route_types . See discussion . January 9, 2020 Added translations.txt . See discussion . December 26, 2019 Updated definitions for cable tram and aerial lift in route_type . See discussion . December 20, 2019 Added attributions.txt . See discussion . August 26, 2019 Specified that stop_lat and stop_lon be positioned where passengers wait to board the vehicle. See discussion . July 9, 2019 Added arrival and departure time best practices. See discussion . Added headsign best practices. See discussion . Added stop_id best practices. See discussion . June 25, 2019 Clarified relationship of shape points and stops. See discussion . April 4, 2019 Added platform_code field in stops.txt . See discussion . March 27, 2019 Added pathways.txt and levels.txt . See discussion . February 6, 2019 Editorial and formatting changes for clarity. See discussion . October 2, 2018 Factorized field types. See discussion . September 14, 2018 Added \"Conditionally required\" concept. See discussion . September 4, 2018 Unified the definitions of agency_lang and feed_lang . See discussion . August 27, 2018 Updated CHANGES.md and last revised date. See discussion . August 22, 2018 Added feed_contact_email and feed_contact_url fields in the feed_info.txt file. See discussion . December 11, 2017 Added route_sort_order to routes.txt . See discussion . March 15, 2017 Clarified that a proposer's vote does not count towards total. See discussion . Specified that at before calling a vote, at least one GTFS producer and one GTFS consumer should implement the proposed change. See discussion . February 7, 2017 Clarified relationship of block_id and service_id . See discussion . Clarified that frequency-based service begins at vehicle departure. See discussion . Clarified descriptions of stop_id and stop_code . See discussion . December 11, 2017 Added route_sort_order field in the routes.txt file. See discussion . November 27, 2016 Added station entrance as a stops.location_type . See discussion . September 2, 2016 Updated documentation to add agency_id under fare_attributes.txt . See discussion . March 16, 2016 Transition of GTFS documentation to Github at https://github.com/google/transit February 3, 2016 Added agency_email to agency.txt proposal to spec: discussion February 2, 2015 Added stop_times.txt 'timepoint' proposal to spec: discussion February 17, 2014 Added trips.txt 'bikes_allowed' proposal to spec: discussion October 15, 2012 Added trips.txt 'wheelchair_accessible' proposal to spec: discussion June 20, 2012 Added 'wheelchair_boarding' proposal to spec: discussion February 2, 2012 Added 'stop_timezone' proposal to spec: discussion January 18, 2012 Migrated documentation from old code.google.com to their new location at developers.google.com. September 26, 2011 Added 'feed_info' proposal to spec: discussion September 6, 2011 Added 'agency_fare_url' proposal to spec: discussion Added 'exact_times' proposal to spec: discussion March 30, 2009 A new section on making a transit feed publicly available. This wasn't previously discussed on the group, because it wasn't strictly a change to how the data is interpreted or written. However, some of the folks at Google thought that it would be informative to include discussion of non-Google uses of GTFS, since there are an increasing number of applications that can make use of GTFS-formatted data. CSV format clarifications: discussion . Additional guidance on how to pick contrasting colors in the descriptions of the route_color and route_text_color fields. trip_short_name, as proposed and tested in these threads: a and b. A fix for a minor error in the sample data included at the end of the document (giving stop S7 the parent_station S8). Added \"agency_lang\" information to the sample data at the end of the document, as suggested by Marcy during the comment period: discussion . Updated the link to OCTA's GTFS feed in the sidebar See original summary . February 26, 2009 Removed most of the Google-specific feed submission instructions, since there are many other applications that consume GTFS data at this point. Fixed a broken link in the sidebar to Orange County OCTA's public feed. August 7, 2008 Restored the stop_url field, which was accidentally omitted in the August 6 version Added agency_phone to sample data Added a mention of the data use agreement when submitting a feed to Google August 6, 2008 Added transfers.txt file, allowing the feed publishers to provide hints on preferred transfer behavior ( original proposal ) Added location_type and parent_station fields to stops.txt, allowing stop points to be grouped into stations ( original proposal ) Added agency_phone field for providing voice telephone number for an agency ( original proposal ) Added \"Testing Your Feeds\" section mentioning open-source testing tools Added clarifications about CSV format, agency_timezone, agency_lang, route_color, route_text_color, arrival_time, departure_time, calendar.txt vs. calendar_dates.txt, fare tables, and frequencies.txt Added link to feed history document, and corrected some public feed links Updated example images to depict the current Google Maps UI Updated/fixed sample data in document February 29, 2008 Added the stop_code field in stops.txt to allow for the specification of rider-facing stop codes ( original proposal ) Clarified the descriptions of route_short_name and route_long_name in routes.txt Clarified the descriptions of arrival_time and departure_time in stop_times.txt Fixed typos in the Sample Data section November 20, 2007 Clarified block_id description Changed language to de-emphasize Google Transit (since non-Google applications are using GTFS, and transit routing is now an integrated feature of Google Maps), and to fix assorted typos Updated example screenshots to reflect the presentation of GTFS fields in the current Google Maps UI Updated the Google contact email address for transit data providers Updated formatting October 5, 2007 Changed stop_sequence and shape_pt_sequence to allow for any increasing non-negative integers Clarified descriptions and fixed typos May 31, 2007 Updated page style, made HTML cleaner and more accessible Added links to public feed examples and other useful sites Removed examples from individual field descriptions April 9, 2007 Added section on submitting a feed . Added the Example Demo Transit Agency feed . Added note that calendar.txt can be omitted if all the service dates are defined in calendar_dates.txt. Made the agency_id field optional in feeds containing only one agency. This allows existing feeds without agency_id to remain valid. Added fuller specification of agency_url, stop_url, and route_url, and additional example values for those fields. Added 6 (Gondola) and 7 (Funicular) as valid route_type values. March 8, 2007 Minor edit to move the stop_url field from stop_times.txt, where it was incorrectly specified in the Feb. 28 update, to stops.txt, where it belongs. March 5, 2007 Minor edit to clarify the description of the route_long_name field. February 28, 2007 Addition of frequencies.txt for headway-based schedule support. Multiple agencies now allowed in the the same feed. Also added new agency_id field in both agencies.txt and routes.txt that lets you specify which route is operated by which agency. Addition of per-route and per-stop URLs. Addition of direction_id field in trips.txt. Support for mid-trip headsign changes with addition of stop_headsign field in stop_times.txt. Support for route colors with addition of optional route_color and route_text_color in routes.txt. Removed the ability to specify stops using street addresses. The previous version of the spec allowed you to give the location of a transit stop using a street address in the stop_street, stop_city, stop_region, stop_postcode, and stop_country fields. Now stop locations must be given using stop_lat for latitude and stop_lon for longitude, which are more useful for most applications. Addition of cable car vehicle type for route_type field in routes.txt. See the original Headway blog post summary of the changes. November 29, 2006 Added support for trip shape information via shapes.txt Clarified the definition of stop_sequence Marked pickup_type and drop_off_type optional October 31, 2006 Added support for fare information Removed dates from individual file names Changed the route_type value definitions Allowed for multiple feed files to be posted at the same time, as long as their service periods didn't overlap Fixed block_id in trips.txt so that it was correctly marked Optional Noted that column headers must be included September 29, 2006 Minor edit to fix a couple errors in the examples. September 25, 2006 Initial version.","title":"Revision History"},{"location":"schedule/revision-history/#revision-history","text":"September 15, 2021 Allowed fare gates (pathway_mode=6) to be bidirectional. See discussion . September 13, 2021 Updated stop_name best practices. See discussion . August 27, 2021 Updated GTFS Schedule to RFC 2119 . See discussion . January 4, 2021 Clarified description of stop_times.stop_id . See discussion . Defined positive and non-zero field signs. See discussion . October 2, 2020 Changed field type of frequencies.headway_secs from non-negative to positive integer. See discussion . May 25, 2020 Defined pathways.txt , levels.txt and attributions.txt as translatable tables. Added recommendations for translating multilingual signposted_as values. See discussion . May 13, 2020 Added continuous_pickup and continuous_drop_off to routes.txt and stop_times.txt . Changed shape_id from \"Optional\" to \"Conditionally required\". See discussion . March 24, 2020 Defined text-to-speech field and added tts_stop_name to stops.txt . See discussion . February 5, 2020 Added trolleybus and monorail route_types . See discussion . January 9, 2020 Added translations.txt . See discussion . December 26, 2019 Updated definitions for cable tram and aerial lift in route_type . See discussion . December 20, 2019 Added attributions.txt . See discussion . August 26, 2019 Specified that stop_lat and stop_lon be positioned where passengers wait to board the vehicle. See discussion . July 9, 2019 Added arrival and departure time best practices. See discussion . Added headsign best practices. See discussion . Added stop_id best practices. See discussion . June 25, 2019 Clarified relationship of shape points and stops. See discussion . April 4, 2019 Added platform_code field in stops.txt . See discussion . March 27, 2019 Added pathways.txt and levels.txt . See discussion . February 6, 2019 Editorial and formatting changes for clarity. See discussion . October 2, 2018 Factorized field types. See discussion . September 14, 2018 Added \"Conditionally required\" concept. See discussion . September 4, 2018 Unified the definitions of agency_lang and feed_lang . See discussion . August 27, 2018 Updated CHANGES.md and last revised date. See discussion . August 22, 2018 Added feed_contact_email and feed_contact_url fields in the feed_info.txt file. See discussion . December 11, 2017 Added route_sort_order to routes.txt . See discussion . March 15, 2017 Clarified that a proposer's vote does not count towards total. See discussion . Specified that at before calling a vote, at least one GTFS producer and one GTFS consumer should implement the proposed change. See discussion . February 7, 2017 Clarified relationship of block_id and service_id . See discussion . Clarified that frequency-based service begins at vehicle departure. See discussion . Clarified descriptions of stop_id and stop_code . See discussion . December 11, 2017 Added route_sort_order field in the routes.txt file. See discussion . November 27, 2016 Added station entrance as a stops.location_type . See discussion . September 2, 2016 Updated documentation to add agency_id under fare_attributes.txt . See discussion . March 16, 2016 Transition of GTFS documentation to Github at https://github.com/google/transit February 3, 2016 Added agency_email to agency.txt proposal to spec: discussion February 2, 2015 Added stop_times.txt 'timepoint' proposal to spec: discussion February 17, 2014 Added trips.txt 'bikes_allowed' proposal to spec: discussion October 15, 2012 Added trips.txt 'wheelchair_accessible' proposal to spec: discussion June 20, 2012 Added 'wheelchair_boarding' proposal to spec: discussion February 2, 2012 Added 'stop_timezone' proposal to spec: discussion January 18, 2012 Migrated documentation from old code.google.com to their new location at developers.google.com. September 26, 2011 Added 'feed_info' proposal to spec: discussion September 6, 2011 Added 'agency_fare_url' proposal to spec: discussion Added 'exact_times' proposal to spec: discussion March 30, 2009 A new section on making a transit feed publicly available. This wasn't previously discussed on the group, because it wasn't strictly a change to how the data is interpreted or written. However, some of the folks at Google thought that it would be informative to include discussion of non-Google uses of GTFS, since there are an increasing number of applications that can make use of GTFS-formatted data. CSV format clarifications: discussion . Additional guidance on how to pick contrasting colors in the descriptions of the route_color and route_text_color fields. trip_short_name, as proposed and tested in these threads: a and b. A fix for a minor error in the sample data included at the end of the document (giving stop S7 the parent_station S8). Added \"agency_lang\" information to the sample data at the end of the document, as suggested by Marcy during the comment period: discussion . Updated the link to OCTA's GTFS feed in the sidebar See original summary . February 26, 2009 Removed most of the Google-specific feed submission instructions, since there are many other applications that consume GTFS data at this point. Fixed a broken link in the sidebar to Orange County OCTA's public feed. August 7, 2008 Restored the stop_url field, which was accidentally omitted in the August 6 version Added agency_phone to sample data Added a mention of the data use agreement when submitting a feed to Google August 6, 2008 Added transfers.txt file, allowing the feed publishers to provide hints on preferred transfer behavior ( original proposal ) Added location_type and parent_station fields to stops.txt, allowing stop points to be grouped into stations ( original proposal ) Added agency_phone field for providing voice telephone number for an agency ( original proposal ) Added \"Testing Your Feeds\" section mentioning open-source testing tools Added clarifications about CSV format, agency_timezone, agency_lang, route_color, route_text_color, arrival_time, departure_time, calendar.txt vs. calendar_dates.txt, fare tables, and frequencies.txt Added link to feed history document, and corrected some public feed links Updated example images to depict the current Google Maps UI Updated/fixed sample data in document February 29, 2008 Added the stop_code field in stops.txt to allow for the specification of rider-facing stop codes ( original proposal ) Clarified the descriptions of route_short_name and route_long_name in routes.txt Clarified the descriptions of arrival_time and departure_time in stop_times.txt Fixed typos in the Sample Data section November 20, 2007 Clarified block_id description Changed language to de-emphasize Google Transit (since non-Google applications are using GTFS, and transit routing is now an integrated feature of Google Maps), and to fix assorted typos Updated example screenshots to reflect the presentation of GTFS fields in the current Google Maps UI Updated the Google contact email address for transit data providers Updated formatting October 5, 2007 Changed stop_sequence and shape_pt_sequence to allow for any increasing non-negative integers Clarified descriptions and fixed typos May 31, 2007 Updated page style, made HTML cleaner and more accessible Added links to public feed examples and other useful sites Removed examples from individual field descriptions April 9, 2007 Added section on submitting a feed . Added the Example Demo Transit Agency feed . Added note that calendar.txt can be omitted if all the service dates are defined in calendar_dates.txt. Made the agency_id field optional in feeds containing only one agency. This allows existing feeds without agency_id to remain valid. Added fuller specification of agency_url, stop_url, and route_url, and additional example values for those fields. Added 6 (Gondola) and 7 (Funicular) as valid route_type values. March 8, 2007 Minor edit to move the stop_url field from stop_times.txt, where it was incorrectly specified in the Feb. 28 update, to stops.txt, where it belongs. March 5, 2007 Minor edit to clarify the description of the route_long_name field. February 28, 2007 Addition of frequencies.txt for headway-based schedule support. Multiple agencies now allowed in the the same feed. Also added new agency_id field in both agencies.txt and routes.txt that lets you specify which route is operated by which agency. Addition of per-route and per-stop URLs. Addition of direction_id field in trips.txt. Support for mid-trip headsign changes with addition of stop_headsign field in stop_times.txt. Support for route colors with addition of optional route_color and route_text_color in routes.txt. Removed the ability to specify stops using street addresses. The previous version of the spec allowed you to give the location of a transit stop using a street address in the stop_street, stop_city, stop_region, stop_postcode, and stop_country fields. Now stop locations must be given using stop_lat for latitude and stop_lon for longitude, which are more useful for most applications. Addition of cable car vehicle type for route_type field in routes.txt. See the original Headway blog post summary of the changes. November 29, 2006 Added support for trip shape information via shapes.txt Clarified the definition of stop_sequence Marked pickup_type and drop_off_type optional October 31, 2006 Added support for fare information Removed dates from individual file names Changed the route_type value definitions Allowed for multiple feed files to be posted at the same time, as long as their service periods didn't overlap Fixed block_id in trips.txt so that it was correctly marked Optional Noted that column headers must be included September 29, 2006 Minor edit to fix a couple errors in the examples. September 25, 2006 Initial version.","title":"Revision History"},{"location":"schedule/changes/","text":"GTFS Schedule Changes \u00b6 The GTFS Specification is not set in stone. Instead, it is an open specification developed and maintained by the community of transit agencies, developers, and other stakeholders who use GTFS. It is expected that this community of producers and consumers of GTFS data will have proposals for extending the spec to enable new capabilities. To help manage that process, the following procedures and guidelines have been established. Specification Amendment Process Guiding Principles Revision History","title":"GTFS Schedule Changes"},{"location":"schedule/changes/#gtfs-schedule-changes","text":"The GTFS Specification is not set in stone. Instead, it is an open specification developed and maintained by the community of transit agencies, developers, and other stakeholders who use GTFS. It is expected that this community of producers and consumers of GTFS data will have proposals for extending the spec to enable new capabilities. To help manage that process, the following procedures and guidelines have been established. Specification Amendment Process Guiding Principles Revision History","title":"GTFS Schedule Changes"},{"location":"schedule/examples/","text":"GTFS Schedule Examples \u00b6 To help in understanding the GTFS specification and in producing tools that read and write GTFS data, take a look at the following examples of GTFS feeds: The Example GTFS Feed page provides a simple GTFS feed that can be used as a model to understand how a GTFS feed is put together. The Data Examples page provides instructions on modeling specific use cases. See OpenMobilityData for public feeds from real transit agencies.","title":"GTFS Schedule Examples"},{"location":"schedule/examples/#gtfs-schedule-examples","text":"To help in understanding the GTFS specification and in producing tools that read and write GTFS data, take a look at the following examples of GTFS feeds: The Example GTFS Feed page provides a simple GTFS feed that can be used as a model to understand how a GTFS feed is put together. The Data Examples page provides instructions on modeling specific use cases. See OpenMobilityData for public feeds from real transit agencies.","title":"GTFS Schedule Examples"}]}